/* ====================================================================
 *		      GNU GENERAL PUBLIC LICENSE
 *		         Version 2, June 1991
 *
 *    Copyright (C) 1989, 1991 Free Software Foundation, Inc.
 *                        51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *    Everyone is permitted to copy and distribute verbatim copies
 *  of this license document, but changing it is not allowed.
 *
 *  			    Preamble
 *
 *    The licenses for most software are designed to take away your
 *  freedom to share and change it.  By contrast, the GNU General Public
 *  License is intended to guarantee your freedom to share and change free
 *  software--to make sure the software is free for all its users.  This
 *  General Public License applies to most of the Free Software
 *  Foundation's software and to any other program whose authors commit to
 *  using it.  (Some other Free Software Foundation software is covered by
 *  the GNU Library General Public License instead.)  You can apply it to
 *  your programs, too.
 *
 *    When we speak of free software, we are referring to freedom, not
 *  price.  Our General Public Licenses are designed to make sure that you
 *  have the freedom to distribute copies of free software (and charge for
 *  this service if you wish), that you receive source code or can get it
 *  if you want it, that you can change the software or use pieces of it
 *  in new free programs; and that you know you can do these things.
 *
 *     To protect your rights, we need to make restrictions that forbid
 *  anyone to deny you these rights or to ask you to surrender the rights.
 *  These restrictions translate to certain responsibilities for you if you
 *  distribute copies of the software, or if you modify it.
 *
 *     For example, if you distribute copies of such a program, whether
 *  gratis or for a fee, you must give the recipients all the rights that
 *  you have.  You must make sure that they, too, receive or can get the
 *  source code.  And you must show them these terms so they know their
 *  rights.
 *
 *     We protect your rights with two steps: (1) copyright the software, and
 *  (2) offer you this license which gives you legal permission to copy,
 *  distribute and/or modify the software.
 *
 *     Also, for each author's protection and ours, we want to make certain
 *  that everyone understands that there is no warranty for this free
 *  software.  If the software is modified by someone else and passed on, we
 *  want its recipients to know that what they have is not the original, so
 *  that any problems introduced by others will not reflect on the original
 *  authors' reputations.
 *
 *     Finally, any free program is threatened constantly by software
 *  patents.  We wish to avoid the danger that redistributors of a free
 *  program will individually obtain patent licenses, in effect making the
 *  program proprietary.  To prevent this, we have made it clear that any
 *  patent must be licensed for everyone's free use or not licensed at all.
 *
 *     The precise terms and conditions for copying, distribution and
 *  modification follow.
 *  
 *	                	    GNU GENERAL PUBLIC LICENSE
 *       TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
 *
 *     0. This License applies to any program or other work which contains
 *  a notice placed by the copyright holder saying it may be distributed
 *  under the terms of this General Public License.  The "Program", below,
 *  refers to any such program or work, and a "work based on the Program"
 *  means either the Program or any derivative work under copyright law:
 *  that is to say, a work containing the Program or a portion of it,
 *  either verbatim or with modifications and/or translated into another
 *  language.  (Hereinafter, translation is included without limitation in
 *  the term "modification".)  Each licensee is addressed as "you".
 *
 *     Activities other than copying, distribution and modification are not
 *  covered by this License; they are outside its scope.  The act of
 *  running the Program is not restricted, and the output from the Program
 *  is covered only if its contents constitute a work based on the
 *  Program (independent of having been made by running the Program).
 *  Whether that is true depends on what the Program does.
 *
 *     1. You may copy and distribute verbatim copies of the Program's
 *  source code as you receive it, in any medium, provided that you
 *  conspicuously and appropriately publish on each copy an appropriate
 *  copyright notice and disclaimer of warranty; keep intact all the
 *  notices that refer to this License and to the absence of any warranty;
 *  and give any other recipients of the Program a copy of this License
 *  along with the Program.
 *
 *  You may charge a fee for the physical act of transferring a copy, and
 *  you may at your option offer warranty protection in exchange for a fee.
 *
 *     2. You may modify your copy or copies of the Program or any portion
 *  of it, thus forming a work based on the Program, and copy and
 *  distribute such modifications or work under the terms of Section 1
 *  above, provided that you also meet all of these conditions:
 *
 *        a) You must cause the modified files to carry prominent notices
 *     stating that you changed the files and the date of any change.
 *
 *        b) You must cause any work that you distribute or publish, that in
 *     whole or in part contains or is derived from the Program or any
 *     part thereof, to be licensed as a whole at no charge to all third
 *     parties under the terms of this License.
 *
 *        c) If the modified program normally reads commands interactively
 *     when run, you must cause it, when started running for such
 *     interactive use in the most ordinary way, to print or display an
 *     announcement including an appropriate copyright notice and a
 *     notice that there is no warranty (or else, saying that you provide
 *     a warranty) and that users may redistribute the program under
 *     these conditions, and telling the user how to view a copy of this
 *     License.  (Exception: if the Program itself is interactive but
 *     does not normally print such an announcement, your work based on
 *     the Program is not required to print an announcement.)
 *     
 *     These requirements apply to the modified work as a whole.  If
 *  identifiable sections of that work are not derived from the Program,
 *  and can be reasonably considered independent and separate works in
 *  themselves, then this License, and its terms, do not apply to those
 *  sections when you distribute them as separate works.  But when you
 *  distribute the same sections as part of a whole which is a work based
 *  on the Program, the distribution of the whole must be on the terms of
 *  this License, whose permissions for other licensees extend to the
 *  entire whole, and thus to each and every part regardless of who wrote it.
 *
 *     Thus, it is not the intent of this section to claim rights or contest
 *  your rights to work written entirely by you; rather, the intent is to
 *  exercise the right to control the distribution of derivative or
 *  collective works based on the Program.
 *
 *     In addition, mere aggregation of another work not based on the Program
 *  with the Program (or with a work based on the Program) on a volume of
 *  a storage or distribution medium does not bring the other work under
 *  the scope of this License.
 *
 *      3. You may copy and distribute the Program (or a work based on it,
 *  under Section 2) in object code or executable form under the terms of
 *  Sections 1 and 2 above provided that you also do one of the following:
 *
 *        a) Accompany it with the complete corresponding machine-readable
 *     source code, which must be distributed under the terms of Sections
 *     1 and 2 above on a medium customarily used for software interchange; or,
 *
 *        b) Accompany it with a written offer, valid for at least three
 *     years, to give any third party, for a charge no more than your
 *     cost of physically performing source distribution, a complete
 *     machine-readable copy of the corresponding source code, to be
 *     distributed under the terms of Sections 1 and 2 above on a medium
 *     customarily used for software interchange; or,
 *
 *        c) Accompany it with the information you received as to the offer
 *     to distribute corresponding source code.  (This alternative is
 *     allowed only for noncommercial distribution and only if you
 *     received the program in object code or executable form with such
 *     an offer, in accord with Subsection b above.)
 *
 *  The source code for a work means the preferred form of the work for
 *  making modifications to it.  For an executable work, complete source
 *  code means all the source code for all modules it contains, plus any
 *  associated interface definition files, plus the scripts used to
 *  control compilation and installation of the executable.  However, as a
 *  special exception, the source code distributed need not include
 *  anything that is normally distributed (in either source or binary
 *  form) with the major components (compiler, kernel, and so on) of the
 *  operating system on which the executable runs, unless that component
 *  itself accompanies the executable.
 *
 *  If distribution of executable or object code is made by offering
 *  access to copy from a designated place, then offering equivalent
 *  access to copy the source code from the same place counts as
 *  distribution of the source code, even though third parties are not
 *  compelled to copy the source along with the object code.
 *  
 *     4. You may not copy, modify, sublicense, or distribute the Program
 *  except as expressly provided under this License.  Any attempt
 *  otherwise to copy, modify, sublicense or distribute the Program is
 *  void, and will automatically terminate your rights under this License.
 *  However, parties who have received copies, or rights, from you under
 *  this License will not have their licenses terminated so long as such
 *  parties remain in full compliance.
 *
 *    5. You are not required to accept this License, since you have not
 *  signed it.  However, nothing else grants you permission to modify or
 *  distribute the Program or its derivative works.  These actions are
 *  prohibited by law if you do not accept this License.  Therefore, by
 *  modifying or distributing the Program (or any work based on the
 *  Program), you indicate your acceptance of this License to do so, and
 *  all its terms and conditions for copying, distributing or modifying
 *  the Program or works based on it.
 *
 *    6. Each time you redistribute the Program (or any work based on the
 *  Program), the recipient automatically receives a license from the
 *  original licensor to copy, distribute or modify the Program subject to
 *  these terms and conditions.  You may not impose any further
 *  restrictions on the recipients' exercise of the rights granted herein.
 *  You are not responsible for enforcing compliance by third parties to
 *  this License.
 *
 *    7. If, as a consequence of a court judgment or allegation of patent
 *  infringement or for any other reason (not limited to patent issues),
 *  conditions are imposed on you (whether by court order, agreement or
 *  otherwise) that contradict the conditions of this License, they do not
 *  excuse you from the conditions of this License.  If you cannot
 *  distribute so as to satisfy simultaneously your obligations under this
 *  License and any other pertinent obligations, then as a consequence you
 *  may not distribute the Program at all.  For example, if a patent
 *  license would not permit royalty-free redistribution of the Program by
 *  all those who receive copies directly or indirectly through you, then
 *  the only way you could satisfy both it and this License would be to
 *  refrain entirely from distribution of the Program.

 *  If any portion of this section is held invalid or unenforceable under
 *  any particular circumstance, the balance of the section is intended to
 *  apply and the section as a whole is intended to apply in other
 *  circumstances.

 *  It is not the purpose of this section to induce you to infringe any
 *  patents or other property right claims or to contest validity of any
 *  such claims; this section has the sole purpose of protecting the
 *  integrity of the free software distribution system, which is
 *  implemented by public license practices.  Many people have made
 *  generous contributions to the wide range of software distributed
 *  through that system in reliance on consistent application of that
 *  system; it is up to the author/donor to decide if he or she is willing
 *  to distribute software through any other system and a licensee cannot
 *  impose that choice.

 *  This section is intended to make thoroughly clear what is believed to
 *  be a consequence of the rest of this License.
 *  
 *    8. If the distribution and/or use of the Program is restricted in
 *  certain countries either by patents or by copyrighted interfaces, the
 *  original copyright holder who places the Program under this License
 *  may add an explicit geographical distribution limitation excluding
 *  those countries, so that distribution is permitted only in or among
 *  countries not thus excluded.  In such case, this License incorporates
 *  the limitation as if written in the body of this License.
 *
 *    9. The Free Software Foundation may publish revised and/or new versions
 *  of the General Public License from time to time.  Such new versions will
 *  be similar in spirit to the present version, but may differ in detail to
 *  address new problems or concerns.
 *
 *  Each version is given a distinguishing version number.  If the Program
 *  specifies a version number of this License which applies to it and "any
 *  later version", you have the option of following the terms and conditions
 *  either of that version or of any later version published by the Free
 *  Software Foundation.  If the Program does not specify a version number of
 *  this License, you may choose any version ever published by the Free Software
 *  Foundation.

 *    10. If you wish to incorporate parts of the Program into other free
 *  programs whose distribution conditions are different, write to the author
 *  to ask for permission.  For software which is copyrighted by the Free
 *  Software Foundation, write to the Free Software Foundation; we sometimes
 *  make exceptions for this.  Our decision will be guided by the two goals
 *  vof preserving the free status of all derivatives of our free software and
 *  of promoting the sharing and reuse of software generally.
 *
 *  			    NO WARRANTY
 *
 *    11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
 *  FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
 *  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
 *  PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
 *  OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
 *  TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
 *  PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
 *  REPAIR OR CORRECTION.
 *
 *    12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
 *  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
 *  REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
 *  INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
 *  OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
 *  TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
 *  YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
 *  PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGES.
 *
 *  		     END OF TERMS AND CONDITIONS
 *  
 *  	    How to Apply These Terms to Your New Programs
 *    If you develop a new program, and you want it to be of the greatest
 *  possible use to the public, the best way to achieve this is to make it
 *  free software which everyone can redistribute and change under these terms.
 *
 *    To do so, attach the following notices to the program.  It is safest
 *  to attach them to the start of each source file to most effectively
 *  convey the exclusion of warranty; and each file should have at least
 *  the "copyright" line and a pointer to where the full notice is found.
 *
 *      <one line to give the program's name and a brief idea of what it does.>
 *      Copyright (C) <year>  <name of author>
 *
 *      This program is free software; you can redistribute it and/or modify
 *      it under the terms of the GNU General Public License as published by
 *      the Free Software Foundation; either version 2 of the License, or
 *      (at your option) any later version.
 *
 *      This program is distributed in the hope that it will be useful,
 *      but WITHOUT ANY WARRANTY; without even the implied warranty of
 *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *      GNU General Public License for more details.
 *
 *      You should have received a copy of the GNU General Public License
 *      along with this program; if not, write to the Free Software
 *      Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *
 *
 *  Also add information on how to contact you by electronic and paper mail.
 *
 *  If the program is interactive, make it output a short notice like this
 *  when it starts in an interactive mode:
 *
 *      Gnomovision version 69, Copyright (C) year name of author
 *      Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
 *      This is free software, and you are welcome to redistribute it
 *      under certain conditions; type `show c' for details.
 *
 *  The hypothetical commands `show w' and `show c' should show the appropriate
 *  parts of the General Public License.  Of course, the commands you use may
 *  be called something other than `show w' and `show c'; they could even be
 *  mouse-clicks or menu items--whatever suits your program.
 *
 *  You should also get your employer (if you work as a programmer) or your
 *  school, if any, to sign a "copyright disclaimer" for the program, if
 *  necessary.  Here is a sample; alter the names:
 *
 *    Yoyodyne, Inc., hereby disclaims all copyright interest in the program
 *    `Gnomovision' (which makes passes at compilers) written by James Hacker.
 *
 *    <signature of Ty Coon>, 1 April 1989
 *    Ty Coon, President of Vice

 *  This General Public License does not permit incorporating your program into
 *  proprietary programs.  If your program is a subroutine library, you may
 *  consider it more useful to permit linking proprietary applications with the
 *  library.  If this is what you want to do, use the GNU Library General
 *  Public License instead of this License.

*/

package it.aco.mandragora.common.utils;

import it.aco.mandragora.common.Node;
import it.aco.mandragora.common.Utils;
import it.aco.mandragora.comparator.FieldComparator;

import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;

import org.apache.commons.beanutils.BeanUtilsBean;
import org.apache.commons.beanutils.ConstructorUtils;
import org.apache.commons.beanutils.PropertyUtilsBean;


public class BeanCollectionUtils {
    private static org.apache.log4j.Category log = org.apache.log4j.Logger.getLogger(BeanCollectionUtils.class.getName());

    /**
     * This method returns an array with the object values of the attributes of <code>pInstance</code> specified by <code>pAttributeNames</code>. </br>
     * @param pInstance value which attributes values have to be returned.
     * @param pAttributeNames names of the attributes of <code>pInstance</code> to return.
     * @return   The values of the attributes <code>pAttributeNames</code> of <code>pInstance</code>.
     * @throws Exception - If  <code>pInstance</code> or <code>pAttributeNames</code> are null
     */
    public static Object[] getAttributes(Object pInstance,String[] pAttributeNames) throws Exception{
        try{
            if (pInstance==null || pAttributeNames==null)throw new Exception("Exception thrown in BeanCollectionUtils.getAttributes(Object pInstance,String[] pAttributeNames): pInstance and pAttributeNames can't be null");
            PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();
            Object[] values = new Object[pAttributeNames.length];
            for (int i=0; i<pAttributeNames.length; i++){
                log.debug("getAttributes(Object pInstance,String[] pAttributeNames) :pAttributeNames["+i+"] ="+pAttributeNames[i]);
                values[i] =  propertyUtilsBean.getProperty(pInstance, pAttributeNames[i]);
            }
            return values;
        }catch (IllegalAccessException e) {
            log.error("IllegalAccessException caught in BeanCollectionUtils.getAttributes(Object pInstance,String[] pAttributeNames) " + e.toString());
            throw new Exception("Exception thrown in BeanCollectionUtils.getAttributes(Object pInstance,String[] pAttributeNames)" + e.toString(),e);
        }catch (InvocationTargetException e) {
            log.error("InvocationTargetException caught in BeanCollectionUtils.getAttributes(Object pInstance,String[] pAttributeNames) " + e.toString());
            throw new Exception("Exception thrown in BeanCollectionUtils.getAttributes(Object pInstance,String[] pAttributeNames)" + e.toString(),e);
        }catch (NoSuchMethodException e) {
            log.error("NoSuchMethodException caught in BeanCollectionUtils.getAttributes(Object pInstance,String[] pAttributeNames) " + e.toString());
            throw new Exception("Exception thrown in BeanCollectionUtils.getAttributes(Object pInstance,String[] pAttributeNames)" + e.toString(),e);
        }catch (Exception e) {
            log.error("Exception caught in BeanCollectionUtils.getAttributes(Object pInstance,String[] pAttributeNames) " + e.toString());
            throw new Exception("Exception thrown in BeanCollectionUtils.getAttributes(Object pInstance,String[] pAttributeNames)" + e.toString(),e);
        }
    }

    /**
     * This method populates the attributes of <code>targetPInstance</code> whose attributes names are in <code>targetPAttributeNames</code> with attributes values of <code>sourcePInstance</code> whose attributes names are in <code>sourcePAttributeNames</code>,
     * and if <code>pAttributeNames</code> and  <code>valuesArray</code> are not null, <code>targetPInstance</code> attributes names in <code>pAttributeNames</code> are set with values in <code>valuesArray</code>.</br>
     * In other words, for each <code>i</code> the attribute <code>targetPAttributeNames[i]</code> of  <code>targetPInstance</code>
     * will be set with the value of the attribute <code>sourcePAttributeNames[i]</code> of  <code>sourcePInstance</code>, for each <code>j</code>,
     * if <code>pAttributeNames</code> and  <code>valuesArray</code> are not null, the attribute <code>pAttributeNames[j]</code> of  <code>targetPInstance</code> will be set with <code>valuesArray[j]</code>.</br>
     * </br>
     * If <code>sourcePAttributeNames</code> and  <code>targetPAttributeNames</code> are both null, such attributes won't be set; if just one of them is null, it will assume the value of the other one.
     * For example if <code>sourcePAttributeNames</code> is null and <code>targetPAttributeNames</code> is not null, <code>sourcePAttributeNames</code> will have the value of <code>targetPAttributeNames</code> (and viceversa).</br>
     * <code>sourcePInstance</code> and <code>targetPInstance</code> can't be both null at the same time otherwise an Exception will be thrown.</br>
     * if just one of them is null, it will assume the value of the other one.
     * For example if <code>sourcePInstance</code> is null and <code>targetPInstance</code> is not null, <code>sourcePInstance</code> will have the value of <code>targetPInstance</code> (and viceversa).</br>
     * </br>
     * So if only one of the value objects <code>sourcePInstance</code> and <code>targetPInstance</code> is null, the attributes  <code>targetPAttributeNames</code> will be set with the attributes <code>sourcePAttributeNames</code> of the same value object (the not null one).</br>
     * If only one of <code>sourcePAttributeNames</code> and <code>targetPAttributeNames</code> is null, the value of the attributes of the not null array
     * will be copied from <code>sourcePInstance</code> to <code>targetPInstance</code>, that of course, both must have the attributes of the not null array of attributes.</br>
     * Note that if only one of the value objects <code>sourcePInstance</code> and <code>targetPInstance</code> is null, and only one of <code>sourcePAttributeNames</code> and <code>targetPAttributeNames</code> is null,
     * will be performed an useless operation to copy attributes values to the same attribute of the same value object
     * </br>
     * <code>pAttributeNames</code> and <code>valuesArray</code> have to be both null or both not null, and if they are not null must have the same length otherwise an Exception will be thrown.
     *
     * @param sourcePInstance bean holding source attributes. If it is null it will assume the value of  <code>targetPInstance</code>, and if this one is null as well  an Exception will be thrown.</br>
     * @param sourcePAttributeNames names of the attributes of <code>sourcePInstance</code> to use to populate <code>targetPInstance</code>  attributes whose names are in <code>targetPAttributeNames</code></br>
     *                              If null it will assume the value of <code>targetPAttributeNames</code>, and if this one is null as well no job is done.
     * @param targetPInstance    bean whose attributes have to be populated.If it is null it will assume the value of  <code>sourcePInstance</code>, and if this one is null as well  an Exception will be thrown.</br>
     * @param targetPAttributeNames names of the attributes of  <code>targetPInstance</code> to populate with <code>sourcePInstance</code>  attributes  whose names are in <code>sourcePAttributeNames</code></br>
     *                              If null it will assume the value of <code>sourcePAttributeNames</code>, and if this one is null as well no job is done.
     * @param pAttributeNames names of <code>targetPInstance</code>  attributes to populate with values in <code>valuesArray</code>
     * @param valuesArray  values to use to populate <code>targetPInstance</code> attributes in <code>pAttributeNames</code>.
     * @throws Exception
     */
    public static void setAttributes(Object sourcePInstance, String[] sourcePAttributeNames,Object targetPInstance, String[] targetPAttributeNames, String[] pAttributeNames,Object[] valuesArray) throws Exception{
        try{
            if (sourcePInstance==null) sourcePInstance=targetPInstance;
            if (targetPInstance==null) targetPInstance=sourcePInstance;
            setAttributes(sourcePInstance,sourcePAttributeNames,targetPInstance,targetPAttributeNames);
            setAttributes(targetPInstance, pAttributeNames, valuesArray);
        }catch (Exception e) {
            log.error("Exception caught in BeanCollectionUtils.setAttributes(Object sourcePInstance, String[] sourcePAttributeNames,Object targetPInstance, String[] targetPAttributeNames, String[] pAttributeNames,Object[] valuesArray): " + e.toString());
            throw new Exception("Exception thrown in PojoFacade.BeanCollectionUtils(Object sourcePInstance, String[] sourcePAttributeNames,Object targetPInstance, String[] targetPAttributeNames, String[] pAttributeNames,Object[] valuesArray)" + e.toString(),e);
        }
    }



    /**
     * This method populates the attributes of <code>targetPInstance</code> whose attributes names are in <code>targetPAttributeNames</code> with attributes values of <code>sourcePInstance</code> whose attributes names are in <code>sourcePAttributeNames</code>,
     * In other words, for each <code>i</code> the attribute <code>targetPAttributeNames[i]</code> of  <code>targetPInstance</code>
     * will be set with the value of the attribute <code>sourcePAttributeNames[i]</code> of  <code>sourcePInstance</code>.</br>
     * If <code>sourcePAttributeNames</code> and  <code>targetPAttributeNames</code> are both null, nothing is done; if just one of them is null, it will assume the value of the other one.
     * For example if <code>sourcePAttributeNames</code> is null and <code>targetPAttributeNames</code> is not null, <code>sourcePAttributeNames</code> will have the value of <code>targetPAttributeNames</code> (and viceversa).</br>
     * <code>sourcePInstance</code> and <code>targetPInstance</code> can't be both null at the same time otherwise an Exception will be thrown.</br>
     * if just one of them is null, it will assume the value of the other one.
     * For example if <code>sourcePInstance</code> is null and <code>targetPInstance</code> is not null, <code>sourcePInstance</code> will have the value of <code>targetPInstance</code> (and viceversa).</br>
     * So if only one of the value objects <code>sourcePInstance</code> and <code>targetPInstance</code> is null, the attributes  <code>targetPAttributeNames</code> will be set with the attributes <code>sourcePAttributeNames</code> of the same value object (the not null one).</br>
     * If only one of <code>sourcePAttributeNames</code> and <code>targetPAttributeNames</code> is null, the value of the attributes of the not null array
     * will be copied from <code>sourcePInstance</code> to <code>targetPInstance</code>, that of course, both must have the attributes of the not null array of attributes.</br>
     * Note that if only one of the value objects <code>sourcePInstance</code> and <code>targetPInstance</code> is null, and only one of <code>sourcePAttributeNames</code> and <code>targetPAttributeNames</code> is null,
     * will be performed an useless operation to copy attributes values to the same attribute of the same value object
     *
     *
     * @param sourcePInstance bean holding source attributes. If it is null it will assume the value of  <code>targetPInstance</code>, and if this one is null as well  an Exception will be thrown.</br>
     * @param sourcePAttributeNames names of the attributes of <code>sourcePInstance</code> to use to populate <code>targetPInstance</code>  attributes whose names are in <code>targetPAttributeNames</code></br>
     *                              If null it will assume the value of <code>targetPAttributeNames</code>, and if this one is null as well no job is done.
     * @param targetPInstance  bean whose attributes have to be populated.If it is null it will assume the value of  <code>sourcePInstance</code>, and if this one is null as well  an Exception will be thrown.</br>
     * @param targetPAttributeNames names of the attributes of  <code>targetPInstance</code> to populate with <code>sourcePInstance</code>  attributes  whose names are in <code>sourcePAttributeNames</code></br>
     *                              If null it will assume the value of <code>sourcePAttributeNames</code>, and if this one is null as well no job is done.
     * @throws Exception
     */
    public static void setAttributes(Object sourcePInstance, String[] sourcePAttributeNames,Object targetPInstance, String[] targetPAttributeNames) throws Exception{
        try{

            if (sourcePInstance==null) sourcePInstance=targetPInstance;
            if (targetPInstance==null) targetPInstance=sourcePInstance;

            if (sourcePAttributeNames==null) sourcePAttributeNames = targetPAttributeNames;
            if (targetPAttributeNames==null) targetPAttributeNames = sourcePAttributeNames;


            if (sourcePInstance == null ){ //targetPInstance == null sure
                throw new Exception("Exception thrown in  BeanCollectionUtils.setAttributes(Object sourcePInstance, String[] sourcePAttributeNames,Object targetPInstance, String[] targetPAttributeNames): sourcePInstance and targetPInstance can't be both null at the same time" );
            }

            if (sourcePAttributeNames==null ) return;  //targetPAttributeNames==null sure

            if (sourcePAttributeNames.length!=targetPAttributeNames.length ){
                throw new Exception("Exception thrown in  BeanCollectionUtils.setAttributes(Object sourcePInstance, String[] sourcePAttributeNames,Object targetPInstance, String[] targetPAttributeNames): bad parameters sourcePAttributeNames and targetPAttributeNames : they must have the same length" );
            }



            PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();
            for(int i=0;i<sourcePAttributeNames.length;i++){
//            	/***start added 12/08/2012**/
//            	String[] firstAttributeNameAndRemainingPath = Utils.getFirstAttributeNameAndRemainingPath(targetPAttributeNames[i]);
//            	String firstAttributeName = firstAttributeNameAndRemainingPath[0];
//            	String remainingPath = firstAttributeNameAndRemainingPath[1];
//            	Object currentTargetPInstance = targetPInstance;
//            	while (!remainingPath.trim().equals("")){
//            		if(propertyUtilsBean.getProperty(currentTargetPInstance,firstAttributeName)==null){
//            			Class currentTargetPInstanceClass = PersistenceUtil.getEntityClass(currentTargetPInstance);
//            			Class firstAttributeClass = currentTargetPInstanceClass.getDeclaredField(firstAttributeName).getType();
//            			Object firstAttribute = ConstructorUtils.invokeConstructor(firstAttributeClass,null,null) ;
//            			propertyUtilsBean.setProperty(currentTargetPInstance, firstAttributeName, firstAttribute);
//            		}
//            		currentTargetPInstance = propertyUtilsBean.getProperty(currentTargetPInstance,firstAttributeName);
//            		firstAttributeNameAndRemainingPath = Utils.getFirstAttributeNameAndRemainingPath(remainingPath);
//            		firstAttributeName = firstAttributeNameAndRemainingPath[0];
//                	remainingPath = firstAttributeNameAndRemainingPath[1];
//            	}
//            	
//            	/***end added 12/08/2012**/
//                propertyUtilsBean.setProperty(targetPInstance,targetPAttributeNames[i],propertyUtilsBean.getProperty(sourcePInstance,sourcePAttributeNames[i]));
            	//setAttribute(targetPInstance,targetPAttributeNames[i],propertyUtilsBean.getProperty(sourcePInstance,sourcePAttributeNames[i])); // added 14/08/2012
            	setAttribute(targetPInstance,targetPAttributeNames[i],getAttribute(sourcePInstance,sourcePAttributeNames[i])); // added 14/08/2012
            }
        }catch (IllegalAccessException e) {
            log.error("IllegalAccessException caught in BeanCollectionUtils.setAttributes(Object sourcePInstance, String[] sourcePAttributeNames,Object targetPInstance, String[] targetPAttributeNames): " + e.toString());
            throw new Exception("Exception thrown in  BeanCollectionUtils.setAttributes(Object sourcePInstance, String[] sourcePAttributeNames,Object targetPInstance, String[] targetPAttributeNames): " + e.toString(),e);
        }catch (NoSuchMethodException e) {
            log.error("NoSuchMethodException caught in BeanCollectionUtils.setAttributes(Object sourcePInstance, String[] sourcePAttributeNames,Object targetPInstance, String[] targetPAttributeNames): " + e.toString());
            throw new Exception("Exception thrown in  BeanCollectionUtils.setAttributes(Object sourcePInstance, String[] sourcePAttributeNames,Object targetPInstance, String[] targetPAttributeNames): " + e.toString(),e);
        }catch (InvocationTargetException e) {
            log.error("InvocationTargetException caught in BeanCollectionUtils.setAttributes(Object sourcePInstance, String[] sourcePAttributeNames,Object targetPInstance, String[] targetPAttributeNames): " + e.toString());
            throw new Exception("Exception thrown in  BeanCollectionUtils.setAttributes(Object sourcePInstance, String[] sourcePAttributeNames,Object targetPInstance, String[] targetPAttributeNames): " + e.toString(),e);
        } catch (Exception e) {
            log.error("Exception caught in BeanCollectionUtils.setAttributes(Object sourcePInstance, String[] sourcePAttributeNames,Object targetPInstance, String[] targetPAttributeNames): " + e.toString());
            throw new Exception("Exception thrown in  BeanCollectionUtils.setAttributes(Object sourcePInstance, String[] sourcePAttributeNames,Object targetPInstance, String[] targetPAttributeNames): " + e.toString(),e);
        }
    }

    /**
     * With this method, if <code>pAttributeNames</code> and  <code>valuesArray</code> are not null, <code>pInstance</code> attributes names in <code>pAttributeNames</code> are set with values in <code>valuesArray</code>.</br>
     * In other words,if <code>pAttributeNames</code> and  <code>valuesArray</code> are not null,  for each <code>j</code>,
     * the attribute <code>pAttributeNames[j]</code> of  <code>pInstance</code> will be set with <code>valuesArray[j]</code>.</br>
     * </br>
     * <code>pInstance</code>  can't be null otherwise an Exception will be thrown.</br>
     * <code>pAttributeNames</code> and <code>valuesArray</code> have to be both null or both not null, and if they are not null must have the same length otherwise an Exception will be thrown..</br>
     * Note that if <code>pAttributeNames</code> is null, nothing is done.
     *
     * @param pInstance  bean holding the attributes to set. If null an Exception will be thrown.</br>
     * @param pAttributeNames  names of <code>pInstance</code>  attributes to populate with values in <code>valuesArray</code>
     * @param valuesArray  values to use to populate <code>pInstance</code> attributes in <code>pAttributeNames</code>.
     * @throws Exception
     */
    public static void setAttributes(Object pInstance, String[] pAttributeNames,Object[] valuesArray)  throws Exception{

        try{
            if (pInstance == null) throw new Exception("Exception thrown in BeanCollectionUtils.setAttributes(Object pInstance, String[] pAttributeNames,Object[] valuesArray): pInstance ca't be null" );

            if ((pAttributeNames==null && valuesArray!=null)||(pAttributeNames!=null && valuesArray==null)){
                throw new Exception("Exception thrown in BeanCollectionUtils.setAttributes(Object pInstance, String[] pAttributeNames,Object[] valuesArray): parameters pAttributeNames and valuesArray must be both null or both not null" );
            }
            if (pAttributeNames!=null /*valuesArray != null surely*/ && pAttributeNames.length!=valuesArray.length){
                throw new Exception("Exception thrown in BeanCollectionUtils.setAttributes(Object pInstance, String[] pAttributeNames,Object[] valuesArray): parameters pAttributeNames and valuesArray must be both null or have the same length" );
            }

            PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();
            if (pAttributeNames!=null){/*valuesArray != null surely and has the same lenght of pAttributeNames*/
                for(int i=0;i<pAttributeNames.length;i++){
                   // propertyUtilsBean.setProperty(pInstance,pAttributeNames[i],valuesArray[i]);
                	 setAttribute(pInstance,pAttributeNames[i],valuesArray[i]); // changed 15/08/2012
                }
            }
        }catch (IllegalAccessException e) {
            log.error("IllegalAccessException caught in BeanCollectionUtils.setAttributes(Object pInstance, String[] pAttributeNames,Object[] valuesArray): " + e.toString());
            throw new Exception("Exception thrown in  BeanCollectionUtils.setAttributes(Object pInstance, String[] pAttributeNames,Object[] valuesArray): " + e.toString(),e);
        }catch (InvocationTargetException e) {
            log.error("InvocationTargetException caught in BeanCollectionUtils.setAttributes(Object pInstance, String[] pAttributeNames,Object[] valuesArray): " + e.toString());
            throw new Exception("Exception thrown in  BeanCollectionUtils.setAttributes(Object pInstance, String[] pAttributeNames,Object[] valuesArray): " + e.toString(),e);
        }catch (NoSuchMethodException e) {
            log.error("NoSuchMethodException caught in BeanCollectionUtils.setAttributes(Object pInstance, String[] pAttributeNames,Object[] valuesArray): " + e.toString());
            throw new Exception("Exception thrown in  BeanCollectionUtils.setAttributes(Object pInstance, String[] pAttributeNames,Object[] valuesArray): " + e.toString(),e);
        }catch (Exception e) {
            log.error("Exception caught in BeanCollectionUtils.setAttributes(Object pInstance, String[] pAttributeNames,Object[] valuesArray): " + e.toString());
            throw new Exception("Exception thrown in  BeanCollectionUtils.setAttributes(Object pInstance, String[] pAttributeNames,Object[] valuesArray): " + e.toString(),e);
        }
    }



    /**
     * This method has the same behavior of applying the method {@link #setAttributes(Object pInstance, String[] pAttributeNames,Object[] valuesArray)}
     * to all the elements of the collection <code>valueObjectsCollection</code>
     * @param valueObjectsCollection collection which elements attributes in <code>pAttributeNames</code>  have to be set to the values of <code>valuesArray</code>
     * @param pAttributeNames names of the attributes of the elements of <code>valueObjectsCollection</code> to populate with values in <code>valuesArray</code>
     * @param valuesArray values to use to populate the attributes of the elements of <code>valueObjectsCollection</code>  in <code>pAttributeNames</code>.
     * @throws Exception - if  <code>valueObjectsCollection</code> or someone of its elements is null.</br>
     *      <code>pAttributeNames</code> and <code>valuesArray</code> have to be both null or both not null, and if they are not null must have the same length otherwise an Exception will be thrown..</br>
     */
    public static void setAttributes(Collection valueObjectsCollection, String[] pAttributeNames,Object[] valuesArray)  throws Exception{
        try{
            if (valueObjectsCollection == null) throw new Exception("Exception thrown in BeanCollectionUtils.setAttributes(Collection valueObjectsCollection, String[] pAttributeNames,Object[] valuesArray): valueObjectsCollection can't be null" );
            Iterator iterator = valueObjectsCollection.iterator();
            while (iterator.hasNext()){
                setAttributes(iterator.next(), pAttributeNames, valuesArray);
            }
        }catch (Exception e) {
            log.error("Exception caught in BeanCollectionUtils.setAttributes(Object pInstance, String[] pAttributeNames,Object[] valuesArray): " + e.toString());
            throw new Exception("Exception thrown in  BeanCollectionUtils.setAttributes(Object pInstance, String[] pAttributeNames,Object[] valuesArray): " + e.toString(),e);
        }
    }

    /**
     * This method has the same behavior of applying the method {@link #setAttributes(Object pInstance, String[] pAttributeNames,Object[] valuesArray)}
     * to all the elements of the collection <code>valueObjectsCollection</code>
     * where <code>pAttributeNames</code> has just one elements that is the input string parameter <code>pAttributeName</code> and
     * <code>valuesArray</code> has has just one elements that is the input parameter <code>value</code>.</br>
     * @param valueObjectsCollection collection which elements attribute <code>pAttributeName</code>  has to be set to  <code>value</code>
     * @param pAttributeName names of the attribute of the elements of <code>valueObjectsCollection</code> to populate with <code>value</code>
     * @param value value to use to populate the attribute of the elements of <code>valueObjectsCollection</code> named <code>pAttributeName</code>.
     * @throws Exception  - if  <code>valueObjectsCollection</code> or someone of its elements is null.</br>
     *      If <code>pAttributeNames</code>  is null.</br>
     */
    public static void setAttributes(Collection valueObjectsCollection, String pAttributeName ,Object value)  throws Exception{
        try{
            if (valueObjectsCollection == null) throw new Exception("Exception thrown in BeanCollectionUtils.setAttributes(Collection valueObjectsCollection, String pAttributeName ,Object value): valueObjectsCollection can't be null" );
            if (pAttributeName == null) throw new Exception("Exception thrown in BeanCollectionUtils.setAttributes(Collection valueObjectsCollection, String pAttributeName ,Object value): pAttributeName can't be null" );
            Iterator iterator = valueObjectsCollection.iterator();
            String[] pAttributeNames = new String[]{pAttributeName};
            Object[] valuesArray = new Object[]{value};
            while (iterator.hasNext()){
                setAttributes(iterator.next(), pAttributeNames, valuesArray);
            }
        }catch (Exception e) {
            log.error("Exception caught in BeanCollectionUtils.setAttributes(Collection valueObjectsCollection, String pAttributeName ,Object value) : " + e.toString());
            throw new Exception("Exception thrown in  BeanCollectionUtils.setAttributes(Collection valueObjectsCollection, String pAttributeName ,Object value) : " + e.toString(),e);
        }
    }

    /**
     * This method sets the attribute <code>pAttributeName</code> of all the value objects of the collection <code>valueObjectsCollection</code> with the values of the collection
     * <code>valuesCollection</code></br>
     * If the two collection are both null nothing is done.</br>
     * @param valueObjectsCollection  collection holding the value objects which attribute <code>pAttributeName</code> has to be set with  with the values of the collection  <code>valuesCollection</code>
     * @param pAttributeName name of the attribute of the value objects of the collection <code>valuesCollection</code> that have to be set with the values of the collection  <code>valuesCollection</code>
     * @param valuesCollection collection holding the values to use to set the attribute <code>pAttributeName</code> of the elements of the collection <code>valuesCollection</code>
     * @throws Exception -
     *      if <code>valueObjectsCollection</code> and <code>valuesCollection</code> are not both null or both not null.</br>
     *      if <code>valueObjectsCollection</code> and <code>valuesCollection</code> are both not null but don't have the same size.</br>
     */
    public static void setAttributes(Collection valueObjectsCollection, String pAttributeName ,Collection valuesCollection)  throws Exception{
        try{
            if(valueObjectsCollection==null && valuesCollection!=null) throw new Exception("Exception thrown in BeanCollectionUtils.setAttributes(Collection valueObjectsCollection, String pAttributeName ,Collection valuesCollection): valueObjectsCollection and valuesCollection must be both null or both not null" );
            if(valueObjectsCollection!=null && valuesCollection==null) throw new Exception("Exception thrown in BeanCollectionUtils.setAttributes(Collection valueObjectsCollection, String pAttributeName ,Collection valuesCollection): valueObjectsCollection and valuesCollection must be both null or both not null" );
            if (pAttributeName == null) throw new Exception("Exception thrown in BeanCollectionUtils.setAttributes(Collection valueObjectsCollection, String pAttributeName ,Collection valuesCollection): pAttributeName can't be null" );
            if (valueObjectsCollection==null) return; // valuesCollection==null surely
            if(valueObjectsCollection.size()!=valuesCollection.size()) throw new Exception("Exception thrown in BeanCollectionUtils.setAttributes(Collection valueObjectsCollection, String pAttributeName ,Collection valuesCollection): valueObjectsCollection and valuesCollection musthave the same size" );
            PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();
            Iterator valueObjectsCollectionIterator =valueObjectsCollection.iterator();
            Iterator valuesCollectionIterator = valuesCollection.iterator();
            while (valueObjectsCollectionIterator.hasNext()){  //valuesCollectionIterator.hasNext() too.
                propertyUtilsBean.setProperty(valueObjectsCollectionIterator.next(),pAttributeName,valuesCollectionIterator.next());
            }
        }catch (IllegalAccessException e) {
            log.error("IllegalAccessException caught in BeanCollectionUtils.ssetAttributes(Collection valueObjectsCollection, String pAttributeName ,Collection valuesCollection) : " + e.toString());
            throw new Exception("Exception thrown in  BeanCollectionUtils.setAttributes(Collection valueObjectsCollection, String pAttributeName ,Collection valuesCollection) : " + e.toString(),e);
        }catch (InvocationTargetException e) {
            log.error("InvocationTargetException caught in BeanCollectionUtils.ssetAttributes(Collection valueObjectsCollection, String pAttributeName ,Collection valuesCollection) : " + e.toString());
            throw new Exception("Exception thrown in  BeanCollectionUtils.setAttributes(Collection valueObjectsCollection, String pAttributeName ,Collection valuesCollection) : " + e.toString(),e);
        }catch (NoSuchMethodException e) {
            log.error("NoSuchMethodException caught in BeanCollectionUtils.ssetAttributes(Collection valueObjectsCollection, String pAttributeName ,Collection valuesCollection) : " + e.toString());
            throw new Exception("Exception thrown in  BeanCollectionUtils.setAttributes(Collection valueObjectsCollection, String pAttributeName ,Collection valuesCollection) : " + e.toString(),e);
        }catch (Exception e) {
            log.error("Exception caught in BeanCollectionUtils.ssetAttributes(Collection valueObjectsCollection, String pAttributeName ,Collection valuesCollection) : " + e.toString());
            throw new Exception("Exception thrown in  BeanCollectionUtils.setAttributes(Collection valueObjectsCollection, String pAttributeName ,Collection valuesCollection) : " + e.toString(),e);
        }
    }

    /**
     * This method does the same job of {@link #createCollectionWithCollectionElements(Collection valueObjectsCollection,  Class realClass, String[] sourcePAttributeNames,String[] targetPAttributeNames, String[] pAttributeNames,Object[] valuesArray)}
     * with the difference that here there is an input parameter more <code>collectionImplClass</code> that specifies the implementation class of
     * the collection to create.</br>
     * If <code>collectionImplClass</code> is null, the behavior is exactly the same.
     *
     * @param collectionImplClass implementation class of the collection to create and return.
     * @param valueObjectsCollection Collecion whose elements will be used to create the new elements of the collection to create. If null, a null is returned.</br>
     * @param realClass  Class of the elements of the collection to create.
     * @param sourcePAttributeNames names of the attributes of the elements of <code>valueObjectsCollection</code> to use to populate the created instances of <code>realClass</code>  attributes whose names are in <code>targetPAttributeNames</code></br>
     *                              If null it will assume the value of <code>targetPAttributeNames</code>
     * @param targetPAttributeNames names of the attributes of the created instances of <code>realClass</code>  to populate with attributes,  whose names are in <code>sourcePAttributeNames</code>, of the elements of <code>valueObjectsCollection</code>.</br>
     *                              If null it will assume the value of <code>sourcePAttributeNames</code>
     * @param pAttributeNames names of the attributes of the created instances of <code>realClass</code> to populate with values in <code>valuesArray</code>
     * @param valuesArray values to use to populate the attributes of the created instances of <code>realClass</code> attributes in <code>pAttributeNames</code>.
     * @return a new collection of instances of <code>realClass</code>.
     * @throws Exception  -
     *      If <code>realClass</code> is null and <code>valueObjectsCollection</code> holds some null value.</br>
     */
    public static Collection createCollectionWithCollectionElements(Class collectionImplClass, Collection valueObjectsCollection,  Class realClass, String[] sourcePAttributeNames,String[] targetPAttributeNames, String[] pAttributeNames,Object[] valuesArray) throws Exception{
        try{
            if (valueObjectsCollection== null) return  null;
            Collection result;
            if (collectionImplClass!=null){
                result = (Collection) ConstructorUtils.invokeConstructor(collectionImplClass,null,null) ;
            } else{
                result = new ArrayList();
            }
            Iterator iterator = valueObjectsCollection.iterator();
            while (iterator.hasNext()){
                Object sourcePInstance = iterator.next();
                Object targetPInstance;
                if(realClass==null){
                    targetPInstance=sourcePInstance;
                } else{
                    targetPInstance = ConstructorUtils.invokeConstructor(realClass,null,null) ;
                }
                //Object targetPInstance = ConstructorUtils.invokeConstructor(realClass,null,null) ;
                setAttributes(sourcePInstance,sourcePAttributeNames,targetPInstance,targetPAttributeNames);
                setAttributes(targetPInstance,pAttributeNames,valuesArray);
                result.add(targetPInstance);
            }
            return result;
        }catch (NoSuchMethodException e) {
            log.error("NoSuchMethodException caught in BeanCollectionUtils.createCollectionWithCollectionElements((Class collectionImplClass,Collection valueObjectsCollection,  Class realClass, String[] sourcePAttributeNames,String[] targetPAttributeNames, String[] pAttributeNames,Object[] valuesArray): " + e.toString());
            throw new Exception("Exception thrown in BeanCollectionUtils.createCollectionWithCollectionElements((Class collectionImplClass,Collection valueObjectsCollection,  Class realClass, String[] sourcePAttributeNames,String[] targetPAttributeNames, String[] pAttributeNames,Object[] valuesArray)" + e.toString(),e);
        }catch (IllegalAccessException e) {
            log.error("IllegalAccessException caught in BeanCollectionUtils.createCollectionWithCollectionElements((Class collectionImplClass,Collection valueObjectsCollection,  Class realClass, String[] sourcePAttributeNames,String[] targetPAttributeNames, String[] pAttributeNames,Object[] valuesArray): " + e.toString());
            throw new Exception("Exception thrown in BeanCollectionUtils.createCollectionWithCollectionElements((Class collectionImplClass,Collection valueObjectsCollection,  Class realClass, String[] sourcePAttributeNames,String[] targetPAttributeNames, String[] pAttributeNames,Object[] valuesArray)" + e.toString(),e);
        }catch (InvocationTargetException e) {
            log.error("InvocationTargetException caught in BeanCollectionUtils.createCollectionWithCollectionElements((Class collectionImplClass,Collection valueObjectsCollection,  Class realClass, String[] sourcePAttributeNames,String[] targetPAttributeNames, String[] pAttributeNames,Object[] valuesArray): " + e.toString());
            throw new Exception("Exception thrown in BeanCollectionUtils.createCollectionWithCollectionElements((Class collectionImplClass,Collection valueObjectsCollection,  Class realClass, String[] sourcePAttributeNames,String[] targetPAttributeNames, String[] pAttributeNames,Object[] valuesArray)" + e.toString(),e);
        } catch (InstantiationException e) {
            log.error("InstantiationException caught in BeanCollectionUtils.createCollectionWithCollectionElements((Class collectionImplClass,Collection valueObjectsCollection,  Class realClass, String[] sourcePAttributeNames,String[] targetPAttributeNames, String[] pAttributeNames,Object[] valuesArray): " + e.toString());
            throw new Exception("Exception thrown in BeanCollectionUtils.createCollectionWithCollectionElements((Class collectionImplClass,Collection valueObjectsCollection,  Class realClass, String[] sourcePAttributeNames,String[] targetPAttributeNames, String[] pAttributeNames,Object[] valuesArray)" + e.toString(),e);
        } catch (Exception e) {
            log.error("Exception caught in BeanCollectionUtils.createCollectionWithCollectionElements((Class collectionImplClass,Collection valueObjectsCollection,  Class realClass, String[] sourcePAttributeNames,String[] targetPAttributeNames, String[] pAttributeNames,Object[] valuesArray): " + e.toString());
            throw new Exception("Exception thrown in BeanCollectionUtils.createCollectionWithCollectionElements((Class collectionImplClass,Collection valueObjectsCollection,  Class realClass, String[] sourcePAttributeNames,String[] targetPAttributeNames, String[] pAttributeNames,Object[] valuesArray)" + e.toString(),e);
        }
    }

    /**
     *
     * This method creates a new empty collection and, if <code>realClass</code> is not null,  for each element of <code>valueObjectsCollection</code>
     * a new instance of <code>realClass</code> is created and its attributes are set with the two methods called in sequence:</br>
     * {@link #setAttributes(Object sourcePInstance, String[] sourcePAttributeNames,Object targetPInstance, String[] targetPAttributeNames)} and
     * {@link #setAttributes(Object pInstance, String[] pAttributeNames,Object[] valuesArray)}
     * where sourcePInstance is the current processed element of <code>valueObjectsCollection</code>, and targetPInstance and pInstance are the new created instance of <code>realClass</code>.
     * If <code>realClass</code> is null, no new instance is created, and the same two methods are called in sequence , but
     * sourcePInstance, targetPInstance, and pInstance are the same current processed element of <code>valueObjectsCollection</code>.</br>
     * If <code>realClass</code> is not null the created instances of <code>realClass</code> will be added to the created collection to return,
     * while if <code>realClass</code> is null the same elements of <code>valueObjectsCollection</code> will be added to the created collection to return.</br>
     * Note that if <code>realClass</code> is null a side effect is produced on the elements  of <code>valueObjectsCollection</code> .</br>
     *
     * If <code>valueObjectsCollection</code> is null, a null is returned.</br>
     * If just one of <code>sourcePAttributeNames</code> and  <code>targetPAttributeNames</code> is null, it will assume the value of the other one.
     * For example if <code>sourcePAttributeNames</code> is null and <code>targetPAttributeNames</code> is not null, <code>sourcePAttributeNames</code> will have the value of <code>targetPAttributeNames</code> (and viceversa).</br>
     * <code>pAttributeNames</code> and <code>valuesArray</code> have to be both null or both not null, and if they are not null must have the same length otherwise an Exception will be thrown..</br>
     *
     * @param valueObjectsCollection Collecion whose elements will be used to create the new elements of the collection to create. If null, a null is returned.</br>
     * @param realClass  Class of the elements of the collection to create.
     * @param sourcePAttributeNames names of the attributes of the elements of <code>valueObjectsCollection</code> to use to populate the created instances of <code>realClass</code>  attributes whose names are in <code>targetPAttributeNames</code></br>
     *                              If null it will assume the value of <code>targetPAttributeNames</code>
     * @param targetPAttributeNames names of the attributes of the created instances of <code>realClass</code>  to populate with attributes,  whose names are in <code>sourcePAttributeNames</code>, of the elements of <code>valueObjectsCollection</code>.</br>
     *                              If null it will assume the value of <code>sourcePAttributeNames</code>
     * @param pAttributeNames names of the attributes of the created instances of <code>realClass</code> to populate with values in <code>valuesArray</code>
     * @param valuesArray values to use to populate the attributes of the created instances of <code>realClass</code> attributes in <code>pAttributeNames</code>.
     * @return a new collection of instances of <code>realClass</code>.
     * @throws Exception -
     *      If <code>realClass</code> is null and <code>valueObjectsCollection</code> holds some null value.</br>
     */
    public static Collection createCollectionWithCollectionElements(Collection valueObjectsCollection,  Class realClass, String[] sourcePAttributeNames,String[] targetPAttributeNames, String[] pAttributeNames,Object[] valuesArray) throws Exception{
        try{
            if (valueObjectsCollection== null) return  null;
            ArrayList result = new ArrayList();
            Iterator iterator = valueObjectsCollection.iterator();
            while (iterator.hasNext()){
                Object sourcePInstance = iterator.next();
                Object targetPInstance;
                if(realClass==null){
                    targetPInstance=sourcePInstance;
                } else{
                    targetPInstance = ConstructorUtils.invokeConstructor(realClass,null,null) ;
                }
                //Object targetPInstance = ConstructorUtils.invokeConstructor(realClass,null,null) ;
                setAttributes(sourcePInstance,sourcePAttributeNames,targetPInstance,targetPAttributeNames);
                setAttributes(targetPInstance,pAttributeNames,valuesArray);
                result.add(targetPInstance);
            }
            return result;
        }catch (NoSuchMethodException e) {
            log.error("NoSuchMethodException caught in BeanCollectionUtils.createCollectionWithCollectionElements(Collection valueObjectsCollection,  Class realClass, String[] sourcePAttributeNames,String[] targetPAttributeNames, String[] pAttributeNames,Object[] valuesArray): " + e.toString());
            throw new Exception("Exception thrown in BeanCollectionUtils.createCollectionWithCollectionElements(Collection valueObjectsCollection,  Class realClass, String[] sourcePAttributeNames,String[] targetPAttributeNames, String[] pAttributeNames,Object[] valuesArray)" + e.toString(),e);
        }catch (IllegalAccessException e) {
            log.error("IllegalAccessException caught in BeanCollectionUtils.createCollectionWithCollectionElements(Collection valueObjectsCollection,  Class realClass, String[] sourcePAttributeNames,String[] targetPAttributeNames, String[] pAttributeNames,Object[] valuesArray): " + e.toString());
            throw new Exception("Exception thrown in BeanCollectionUtils.createCollectionWithCollectionElements(Collection valueObjectsCollection,  Class realClass, String[] sourcePAttributeNames,String[] targetPAttributeNames, String[] pAttributeNames,Object[] valuesArray)" + e.toString(),e);
        }catch (InvocationTargetException e) {
            log.error("InvocationTargetException caught in BeanCollectionUtils.createCollectionWithCollectionElements(Collection valueObjectsCollection,  Class realClass, String[] sourcePAttributeNames,String[] targetPAttributeNames, String[] pAttributeNames,Object[] valuesArray): " + e.toString());
            throw new Exception("Exception thrown in BeanCollectionUtils.createCollectionWithCollectionElements(Collection valueObjectsCollection,  Class realClass, String[] sourcePAttributeNames,String[] targetPAttributeNames, String[] pAttributeNames,Object[] valuesArray)" + e.toString(),e);
        } catch (InstantiationException e) {
            log.error("InstantiationException caught in BeanCollectionUtils.createCollectionWithCollectionElements(Collection valueObjectsCollection,  Class realClass, String[] sourcePAttributeNames,String[] targetPAttributeNames, String[] pAttributeNames,Object[] valuesArray): " + e.toString());
            throw new Exception("Exception thrown in BeanCollectionUtils.createCollectionWithCollectionElements(Collection valueObjectsCollection,  Class realClass, String[] sourcePAttributeNames,String[] targetPAttributeNames, String[] pAttributeNames,Object[] valuesArray)" + e.toString(),e);
        } catch (Exception e) {
            log.error("Exception caught in BeanCollectionUtils.createCollectionWithCollectionElements(Collection valueObjectsCollection,  Class realClass, String[] sourcePAttributeNames,String[] targetPAttributeNames, String[] pAttributeNames,Object[] valuesArray): " + e.toString());
            throw new Exception("Exception thrown in BeanCollectionUtils.createCollectionWithCollectionElements(Collection valueObjectsCollection,  Class realClass, String[] sourcePAttributeNames,String[] targetPAttributeNames, String[] pAttributeNames,Object[] valuesArray)" + e.toString(),e);
        }
    }

    /**
     *
     * This method creates and returns a collection holding leaves of a tree of value objects, or of a collection of trees of value objects. Not all the leaves will be added to the
     * collection to be returned, but just the leaves that have the depth specified by the number of the dot separated tokens of the input string parameter <code>path</code>.</br>
     * The value object root of the tree, or the collection of the value object roots of the trees, is represented by the input parameter
     * <code>valueObjectOrCollection</code>, that, as his name states, can be a value object or a collection of value objects.</br>
     * <code>valueObjectOrCollection</code> (or each element of it, if it is a collection) must have an attribute named as the first token
     * of <code>path</code> (the separator is the dot), and such attribute represents a value object or an other collection of value objects. In both cases, these value objects,
     * must have in turn an attribute named as the second token of <code>path</code>, and so on.</br>
     * We can say that the two input parameters  <code>valueObjectOrCollection</code> and <code>path</code>  represent a tree of value objects or a collection of
     * trees of value objects (if <code>valueObjectOrCollection</code> is a collection), where the nodes are value objects and the branches
     * are tokens of <code>path</code>. </br>
     * Considering the root (or roots) the level 1, each node value object of level <code>i</code>, let's call it <code>NODE-N</code>, must have an attribute named as the <code>i-th</code> token
     * of <code>path</code>. As we saw such attribute value can be null, or can be a value object, or a not empty collection or an empty collection.
     * If the attribute value is null or empty collection, <code>NODE-N</code> doesn't have any child, so it is a leaf, but it won't be added to the collection to return.
     * If the attribute value is a value object, this is the only child of <code>NODE-N</code>,
     * and it is joined to <code>NODE-N</code> by a branch labeled as the <code>i-th</code> token of <code>path</code>.  If the attribute value is a not empty collection
     * of value objects, all of them are children of <code>NODE-N</code>, and are joined to <code>NODE-N</code> by a branch labeled as the <code>i-th</code> token of <code>path</code>.</br>
     * All the value object that are leaves and that are joined to their parent by the last token of <code>path</code> will be the elements (and the only elements) of the collection
     * to be returned.</br>
     * If no one of the leaves of the tree is suitable to be added to the collection (no one is depth enough) to return an empty collection is returned
     * </br>
     * If <code>path</code> is null or empty string or blank characters string, if <code>valueObjectOrCollection</code> is collection, <code>valueObjectOrCollection</code>
     * will be returned , otherwise a new collection holding the code>valueObjectOrCollection</code> will be returned.</br> 
     * If  <code>valueObjectOrCollection</code> is null,a null is returned.</br>
     * If  <code>valueObjectOrCollection</code> is an empty collection, an empty collection is returned.</br>
     *
     * @param valueObjectOrCollection this parameter is the value object root of the tree of value objects, or the collection of value object roots of the trees of value objects
     * @param path dot separated list of the attributes that represent the path from the root to the leaves
     * @return a collection holding leaves of depth of the number of tokens of <code>path</code>
     * @throws Exception for any trouble
     */
     
    public static Collection getTreeLeaves(Object valueObjectOrCollection, String path) throws Exception {
        log.info("************Entering the BeanCollectionUtils.getTreeLeaves(Object valueObjectOrCollection, String path) ***************");
        Collection result=null;
        try{
            log.debug("BeanCollectionUtils : path = "+path);
            //if (path==null||path.trim().equals("")||valueObjectOrCollection==null) return result ; // deleted by Alessandro on Nov the 5th 2008
            if(valueObjectOrCollection!=null)  {  // condition added by Alessandro on Nov the 27th 2008
                //if (path==null||path.trim().equals("")||valueObjectOrCollection==null) { // added by Alessandro on Nov the 5th 2008   and deleted on  Nov the 27th 2008
                if (path==null||path.trim().equals("")) { // added by Alessandro on  Nov the 27th 2008
                    //if (Collection.class.isInstance(valueObjectOrCollection))return (Collection)valueObjectOrCollection;   // deleted by Alessandro on  Nov the 27th 2008
                    if (Collection.class.isInstance(valueObjectOrCollection)) {   // block added by Alessandro on  Nov the 27th 2008
                        result = (Collection)valueObjectOrCollection;
                    } else{ // condition added by Alessandro on Nov the 27th 2008
                        result = new ArrayList();
                        result.add(valueObjectOrCollection);
                        //return result; // deleted by Alessandro on  Nov the 27th 2008
                    }
                } else {
                    String[] firstAttributeNameAndRemainingPath = Utils.getFirstAttributeNameAndRemainingPath( path);
                    String firstAttributeName = firstAttributeNameAndRemainingPath[0];
                    String remainingPath = firstAttributeNameAndRemainingPath[1];
                    log.debug("BeanCollectionUtils.getTreeLeaves:firstAttributeName="+firstAttributeName);
                    log.debug("BeanCollectionUtils.getTreeLeaves:remainingPath="+remainingPath);

                    PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();

                    if (Collection.class.isInstance(valueObjectOrCollection)){ //is a collection
                        log.debug("BeanCollectionUtils.getTreeLeaves: valueobjectOrCollection is a collection");
                        result = new ArrayList();
                        Iterator iterator= ((Collection) valueObjectOrCollection).iterator();
                        if(!remainingPath.equals("")){
                            while (iterator.hasNext()){
                                Collection collection = getTreeLeaves(propertyUtilsBean.getProperty(iterator.next(),firstAttributeName),remainingPath);
                                if(collection!=null){
                                    result.addAll(collection);
                                }
                            }
                        }else{
                            while (iterator.hasNext()){
                                Object beanOrCollection = propertyUtilsBean.getProperty(iterator.next(),firstAttributeName);
                                if (beanOrCollection!=null){
                                    if (Collection.class.isInstance(beanOrCollection)){
                                        result.addAll((Collection) beanOrCollection);
                                    }else{
                                        result.add(beanOrCollection);
                                    }

                                }
                            }
                        }
                    }else {//is a valueobject
                        log.debug("BeanCollectionUtils.getTreeLeaves: valueobjectOrCollection is a valueobject");
                        if(!remainingPath.equals("")){
                            result = getTreeLeaves(propertyUtilsBean.getProperty(valueObjectOrCollection,firstAttributeName),remainingPath);
                        }else {
                            result = new ArrayList();
                            Object beanOrCollection = propertyUtilsBean.getProperty(valueObjectOrCollection,firstAttributeName);
                            if (beanOrCollection!=null){
                                if (Collection.class.isInstance(beanOrCollection)){
                                    result.addAll((Collection) beanOrCollection);
                                }else{
                                    result.add(beanOrCollection);
                                }
                            }
                        }
                    }
                }
            }
        } catch (NoSuchMethodException e) {
            log.error("NoSuchMethodException caught in BeanCollectionUtils.getTreeLeaves(Object valueObjectOrCollection, String path): " + e.toString());
            throw new Exception("Exception thrown in BeanCollectionUtils.getTreeLeaves(Object valueobjectOrCollection, String path)" + e.toString(),e);
        } catch (IllegalAccessException e) {
            log.error("IllegalAccessException caught in BeanCollectionUtils.getTreeLeaves(Object valueObjectOrCollection, String path): " + e.toString());
            throw new Exception("Exception thrown in BeanCollectionUtils.getTreeLeaves(Object valueobjectOrCollection, String path)" + e.toString(),e);
        } catch (InvocationTargetException e) {
            log.error("InvocationTargetException caught in BeanCollectionUtils.getTreeLeaves(Object valueObjectOrCollection, String path): " + e.toString());
            throw new Exception("Exception thrown in BeanCollectionUtils.getTreeLeaves(Object valueobjectOrCollection, String path)" + e.toString(),e);
        } catch (Exception e) {
            log.error("Exception caught in BeanCollectionUtils.getTreeLeaves(Object valueObjectOrCollection, String path): " + e.toString());
            throw new Exception("Exception thrown in BeanCollectionUtils.getTreeLeaves(Object valueobjectOrCollection, String path)" + e.toString(),e);
        }
        log.info("************Done with the  BeanCollectionUtils.getTreeLeaves(Object valueObjectOrCollection, String path)**************");
        return result;
    }

    /**
     *
     * @param bean
     * @param path
     * @return
     * @throws Exception
     */
    public static Object getPropertyIfNotNullOnPath(Object bean, String path) throws Exception {
        log.info("************Entering the BeanCollectionUtils.getPropertyIfNotNullOnPath(Object bean, String path)***************");
        Object propertyValue = null;
        try{
            if(path.equals("")) { //added  by Alessandro on 13-dec-2008
                propertyValue=bean ;
            }else{
                PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();

                String[] firstAttributeNameAndRemainingPath = Utils.getFirstAttributeNameAndRemainingPath(path) ;
                String firstAttributeName = firstAttributeNameAndRemainingPath[0];
                String remainingPath = firstAttributeNameAndRemainingPath[1];
                Object firstAttributeValue = propertyUtilsBean.getProperty(bean,firstAttributeName);
                if(remainingPath.equals("") ||firstAttributeValue == null){
                    propertyValue = firstAttributeValue;
                } else {
                    propertyValue = getPropertyIfNotNullOnPath( firstAttributeValue, remainingPath);
                }
            }



        }catch (NoSuchMethodException e) {
            log.error("NoSuchMethodException caught in BeanCollectionUtils.getPropertyIfNotNullOnPath(Object bean, String path): " + e.toString());
            throw new Exception("Exception thrown in BeanCollectionUtils.getPropertyIfNotNullOnPath(Object bean, String path)" + e.toString(),e);
        } catch (IllegalAccessException e) {
            log.error("IllegalAccessException caught in BeanCollectionUtils.getPropertyIfNotNullOnPath(Object bean, String path): " + e.toString());
            throw new Exception("Exception thrown in BeanCollectionUtils.getPropertyIfNotNullOnPath(Object bean, String path)" + e.toString(),e);
        } catch (InvocationTargetException e) {
            log.error("InvocationTargetException caught in BeanCollectionUtils.getPropertyIfNotNullOnPath(Object bean, String path): " + e.toString());
            throw new Exception("Exception thrown in BeanCollectionUtils.getPropertyIfNotNullOnPath(Object bean, String path)" + e.toString(),e);
        } catch (Exception e) {
            throw new Exception("Exception thrown in BeanCollectionUtils.getPropertyIfNotNullOnPath(Object bean, String path): " + e.toString(),e);
        }
        log.info("************Done with the  BeanCollectionUtils.getPropertyIfNotNullOnPath(Object bean, String path)**************");
        return propertyValue ;
    }
    
    public static boolean retainAllInCollection(Collection valueObjectsCollection, Collection toRetainValueObjectsCollection, String[] pAttributeNames) throws Exception{
        boolean removed = false;
        try{
            if (valueObjectsCollection==null) return false;
            if (toRetainValueObjectsCollection == null || toRetainValueObjectsCollection.isEmpty()){
                if(valueObjectsCollection.isEmpty()){
                    return false;
                }else{
                    valueObjectsCollection.clear();
                    return true;
                }

            }
            //Comparator comparator = new BeanFieldComparator(pAttributeNames) ;
            Comparator comparator = new FieldComparator(pAttributeNames) ;
            ArrayList arrayList = Collections.list(Collections.enumeration(toRetainValueObjectsCollection));
            Collections.sort(arrayList,comparator);

            Object element;
            Iterator iterator = valueObjectsCollection.iterator();
            while (iterator.hasNext()){
                element = iterator.next();
                if(Collections.binarySearch(arrayList,element,comparator)<0){
                    iterator.remove();
                    removed=true; // added by Alessandro on 8-dec-2008
                }
            }

        }catch (Exception e) {
            log.error("Exception caught in BeanCollectionUtils.retainAllInCollection(Collection valueObjectsCollection, Collection toRetainValueObjectsCollection,String[] pAttributeNames): " + e.toString());
            throw new Exception("Exception thrown in BeanCollectionUtils.retainAllInCollection(Collection valueObjectsCollection, Collection toRetainValueObjectsCollection, String[] pAttributeNames)" + e.toString(),e);
        }
        return removed;
    }
    
    public static boolean removeFromCollection(Collection valueObjectsCollection, Object toRemovePInstance, String[] pAttributeNames) throws Exception{

        try{
            boolean removed = false;
            if (valueObjectsCollection==null) return false;
            if(pAttributeNames==null||pAttributeNames.length==0){
            	throw new Exception("Exception thrown in BeanCollectionUtils.removeFromCollection(Collection valueObjectsCollection, Object toRemovePInstance, String[] pAttributeNames): pAttributeNames is null or empty" );
            }
            Comparator comparator = new FieldComparator(pAttributeNames);
            Object element;
            Iterator iterator = valueObjectsCollection.iterator();
            while (iterator.hasNext()){
                element = iterator.next();
                if (comparator.compare(toRemovePInstance,element)==0) {  //added by Alessandro on 9-dec-2008
                    iterator.remove();
                    removed=true;
                }
            }
            return removed;
        }catch (Exception e) {
            log.error("Exception caught in BeanCollectionUtils.removeFromCollection(Collection valueObjectsCollection, Object toRemovePInstance, String[] pAttributeNames): " + e.toString());
            throw new Exception("BeanCollectionUtils thrown in BeanCollectionUtils.removeFromCollection(Collection valueObjectsCollection, Object toRemovePInstance, String[] pAttributeNames)" + e.toString(),e);
        }
    }
    
    public static boolean removeAllFromCollection(Collection valueObjectsCollection, Collection  valueObjectsCollectionToRemove, String[] pAttributeNames) throws Exception{
        try{
            boolean removed = false;
            if(valueObjectsCollection == null)  throw new Exception("Exception thrown in  BeanCollectionUtils.addAllToCollection(Collection valueObjectsCollection, Collection  valueObjectsCollectionToAdd, String[] pAttributeNames) :valueObjectsCollection can't be null" );
            if(valueObjectsCollectionToRemove == null)  return false;
            Iterator iterator = valueObjectsCollectionToRemove.iterator();
            while (iterator.hasNext()){
                if (removeFromCollection(valueObjectsCollection,iterator.next(),pAttributeNames)) removed=true;
            }
            return removed;
        }catch (Exception e) {
            log.error("Exception caught in BeanCollectionUtils.removeAllFromCollection(Collection valueObjectsCollection, Collection  valueObjectsCollectionToRemove, String[] pAttributeNames) : " + e.toString());
            throw new Exception("Exception thrown in BeanCollectionUtils.removeAllFromCollection(Collection valueObjectsCollection, Collection  valueObjectsCollectionToRemove, String[] pAttributeNames) " + e.toString(),e);
        }
    }
    
    private static void setAttribute(Object object, Node node, Object[] values, int valuesIndex) throws Exception{
    	
    	try {
			if(node !=null && node.getChildren()!=null){
				PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();
				//int valuesIndex = 0;
				
				Iterator<String> iterator =node.getChildren().keySet().iterator();
				while (iterator.hasNext()){
					String attribute = iterator.next();
					
					Node recursiveNode=node.getChildren().get(attribute);
					if(recursiveNode==null || recursiveNode.getChildren()==null||recursiveNode.getChildren().isEmpty()){
						propertyUtilsBean.setProperty(object, attribute, values[valuesIndex]);
						valuesIndex++;
					}else{
						Object attributeValue = propertyUtilsBean.getProperty(object, attribute);
						if(attributeValue==null){
							attributeValue = PersistenceUtil.getEntityClass(object).getDeclaredField(attribute).getType().getConstructor().newInstance();
							propertyUtilsBean.setProperty(object, attribute, attributeValue);
							
						}
						setAttribute(attributeValue, recursiveNode, values,  valuesIndex);
					}
				}
			}
		} catch (IllegalArgumentException e) {
            log.error("IllegalArgumentException caught in BeanCollectionUtils.setAttribute(Object object, Node node, Object[] values, int valuesIndex) : " + e.toString());
            throw new Exception("Exception thrown in BeanCollectionUtils.setAttribute(Object object, Node node, Object[] values, int valuesIndex) " + e.toString(),e);
		} catch (SecurityException e) {
            log.error("SecurityException caught in BeanCollectionUtils.setAttribute(Object object, Node node, Object[] values, int valuesIndex) : " + e.toString());
            throw new Exception("Exception thrown in BeanCollectionUtils.setAttribute(Object object, Node node, Object[] values, int valuesIndex) " + e.toString(),e);
		} catch (IllegalAccessException e) {
            log.error("IllegalAccessException caught in BeanCollectionUtils.setAttribute(Object object, Node node, Object[] values, int valuesIndex) : " + e.toString());
            throw new Exception("Exception thrown in BeanCollectionUtils.setAttribute(Object object, Node node, Object[] values, int valuesIndex) " + e.toString(),e);
		} catch (InvocationTargetException e) {
            log.error("InvocationTargetException caught in BeanCollectionUtils.setAttribute(Object object, Node node, Object[] values, int valuesIndex) : " + e.toString());
            throw new Exception("Exception thrown in BeanCollectionUtils.setAttribute(Object object, Node node, Object[] values, int valuesIndex) " + e.toString(),e);
		} catch (NoSuchMethodException e) {
            log.error("NoSuchMethodException caught in BeanCollectionUtils.setAttribute(Object object, Node node, Object[] values, int valuesIndex) : " + e.toString());
            throw new Exception("Exception thrown in BeanCollectionUtils.setAttribute(Object object, Node node, Object[] values, int valuesIndex) " + e.toString(),e);
		} catch (InstantiationException e) {
            log.error("InstantiationException caught in BeanCollectionUtils.setAttribute(Object object, Node node, Object[] values, int valuesIndex) : " + e.toString());
            throw new Exception("Exception thrown in BeanCollectionUtils.setAttribute(Object object, Node node, Object[] values, int valuesIndex) " + e.toString(),e);
		} catch (NoSuchFieldException e) {
            log.error("NoSuchFieldException caught in BeanCollectionUtils.setAttribute(Object object, Node node, Object[] values, int valuesIndex) : " + e.toString());
            throw new Exception("Exception thrown in BeanCollectionUtils.setAttribute(Object object, Node node, Object[] values, int valuesIndex) " + e.toString(),e);
		} catch (Exception e) {
            log.error("Exception caught in BeanCollectionUtils.setAttribute(Object object, Node node, Object[] values, int valuesIndex) : " + e.toString());
            throw new Exception("Exception thrown in BeanCollectionUtils.setAttribute(Object object, Node node, Object[] values, int valuesIndex) " + e.toString(),e);
		}
    	
    }
    
    
    public static void setAttribute(Object object, Node node, Object[] values) throws Exception{
    	setAttribute( object,  node,  values,0);
    	
    }
    
    public static void setAttribute(Object bean, String name, Object value) throws Exception{
    	/***start added 12/08/2012**/
    	try {
			PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();
			String[] firstAttributeNameAndRemainingPath = Utils.getFirstAttributeNameAndRemainingPath(name);
			String firstAttributeName = firstAttributeNameAndRemainingPath[0];
			String remainingPath = firstAttributeNameAndRemainingPath[1];
			Object currentTargetPInstance = bean;
			while (!remainingPath.trim().equals("")){
				if(propertyUtilsBean.getProperty(currentTargetPInstance,firstAttributeName)==null){
					Class currentTargetPInstanceClass = PersistenceUtil.getEntityClass(currentTargetPInstance);
					Class firstAttributeClass = currentTargetPInstanceClass.getDeclaredField(firstAttributeName).getType();
					Object firstAttribute = ConstructorUtils.invokeConstructor(firstAttributeClass,null,null) ;
					propertyUtilsBean.setProperty(currentTargetPInstance, firstAttributeName, firstAttribute);
				}
				currentTargetPInstance = propertyUtilsBean.getProperty(currentTargetPInstance,firstAttributeName);
				firstAttributeNameAndRemainingPath = Utils.getFirstAttributeNameAndRemainingPath(remainingPath);
				firstAttributeName = firstAttributeNameAndRemainingPath[0];
				remainingPath = firstAttributeNameAndRemainingPath[1];
			}
			propertyUtilsBean.setProperty(bean, name, value);
		} catch (Exception e) {
			log.error("Exception caught in BeanCollectionUtils.setAttribute(Object bean, String name, Object value) : " + e.toString());
            throw new Exception("Exception thrown in BeanCollectionUtils.setAttribute(Object bean, String name, Object value) " + e.toString(),e);
		}
    	/***end added 12/08/2012**/
    }
    
    public static Object getAttribute(Object bean, String name) throws Exception{
    	
    	Object attributeValue = null;
    	try {
			PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();
			if(name.equals("this")){
				attributeValue=bean;
			}else{
				attributeValue= propertyUtilsBean.getProperty(bean, name);
			}
			
		} catch (Exception e) {
			log.error("Exception caught in BeanCollectionUtils.getAttribute(Object bean, String name) : " + e.toString());
            throw new Exception("Exception thrown in BeanCollectionUtils.getAttribute(Object bean, String name) " + e.toString(),e);
		}
    	return attributeValue;
    }
}
