/* ====================================================================
 *		      GNU GENERAL PUBLIC LICENSE
 *		         Version 2, June 1991
 *
 *    Copyright (C) 1989, 1991 Free Software Foundation, Inc.
 *                        51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *    Everyone is permitted to copy and distribute verbatim copies
 *  of this license document, but changing it is not allowed.
 *
 *  			    Preamble
 *
 *    The licenses for most software are designed to take away your
 *  freedom to share and change it.  By contrast, the GNU General Public
 *  License is intended to guarantee your freedom to share and change free
 *  software--to make sure the software is free for all its users.  This
 *  General Public License applies to most of the Free Software
 *  Foundation's software and to any other program whose authors commit to
 *  using it.  (Some other Free Software Foundation software is covered by
 *  the GNU Library General Public License instead.)  You can apply it to
 *  your programs, too.
 *
 *    When we speak of free software, we are referring to freedom, not
 *  price.  Our General Public Licenses are designed to make sure that you
 *  have the freedom to distribute copies of free software (and charge for
 *  this service if you wish), that you receive source code or can get it
 *  if you want it, that you can change the software or use pieces of it
 *  in new free programs; and that you know you can do these things.
 *
 *     To protect your rights, we need to make restrictions that forbid
 *  anyone to deny you these rights or to ask you to surrender the rights.
 *  These restrictions translate to certain responsibilities for you if you
 *  distribute copies of the software, or if you modify it.
 *
 *     For example, if you distribute copies of such a program, whether
 *  gratis or for a fee, you must give the recipients all the rights that
 *  you have.  You must make sure that they, too, receive or can get the
 *  source code.  And you must show them these terms so they know their
 *  rights.
 *
 *     We protect your rights with two steps: (1) copyright the software, and
 *  (2) offer you this license which gives you legal permission to copy,
 *  distribute and/or modify the software.
 *
 *     Also, for each author's protection and ours, we want to make certain
 *  that everyone understands that there is no warranty for this free
 *  software.  If the software is modified by someone else and passed on, we
 *  want its recipients to know that what they have is not the original, so
 *  that any problems introduced by others will not reflect on the original
 *  authors' reputations.
 *
 *     Finally, any free program is threatened constantly by software
 *  patents.  We wish to avoid the danger that redistributors of a free
 *  program will individually obtain patent licenses, in effect making the
 *  program proprietary.  To prevent this, we have made it clear that any
 *  patent must be licensed for everyone's free use or not licensed at all.
 *
 *     The precise terms and conditions for copying, distribution and
 *  modification follow.
 *  
 *	                	    GNU GENERAL PUBLIC LICENSE
 *       TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
 *
 *     0. This License applies to any program or other work which contains
 *  a notice placed by the copyright holder saying it may be distributed
 *  under the terms of this General Public License.  The "Program", below,
 *  refers to any such program or work, and a "work based on the Program"
 *  means either the Program or any derivative work under copyright law:
 *  that is to say, a work containing the Program or a portion of it,
 *  either verbatim or with modifications and/or translated into another
 *  language.  (Hereinafter, translation is included without limitation in
 *  the term "modification".)  Each licensee is addressed as "you".
 *
 *     Activities other than copying, distribution and modification are not
 *  covered by this License; they are outside its scope.  The act of
 *  running the Program is not restricted, and the output from the Program
 *  is covered only if its contents constitute a work based on the
 *  Program (independent of having been made by running the Program).
 *  Whether that is true depends on what the Program does.
 *
 *     1. You may copy and distribute verbatim copies of the Program's
 *  source code as you receive it, in any medium, provided that you
 *  conspicuously and appropriately publish on each copy an appropriate
 *  copyright notice and disclaimer of warranty; keep intact all the
 *  notices that refer to this License and to the absence of any warranty;
 *  and give any other recipients of the Program a copy of this License
 *  along with the Program.
 *
 *  You may charge a fee for the physical act of transferring a copy, and
 *  you may at your option offer warranty protection in exchange for a fee.
 *
 *     2. You may modify your copy or copies of the Program or any portion
 *  of it, thus forming a work based on the Program, and copy and
 *  distribute such modifications or work under the terms of Section 1
 *  above, provided that you also meet all of these conditions:
 *
 *        a) You must cause the modified files to carry prominent notices
 *     stating that you changed the files and the date of any change.
 *
 *        b) You must cause any work that you distribute or publish, that in
 *     whole or in part contains or is derived from the Program or any
 *     part thereof, to be licensed as a whole at no charge to all third
 *     parties under the terms of this License.
 *
 *        c) If the modified program normally reads commands interactively
 *     when run, you must cause it, when started running for such
 *     interactive use in the most ordinary way, to print or display an
 *     announcement including an appropriate copyright notice and a
 *     notice that there is no warranty (or else, saying that you provide
 *     a warranty) and that users may redistribute the program under
 *     these conditions, and telling the user how to view a copy of this
 *     License.  (Exception: if the Program itself is interactive but
 *     does not normally print such an announcement, your work based on
 *     the Program is not required to print an announcement.)
 *     
 *     These requirements apply to the modified work as a whole.  If
 *  identifiable sections of that work are not derived from the Program,
 *  and can be reasonably considered independent and separate works in
 *  themselves, then this License, and its terms, do not apply to those
 *  sections when you distribute them as separate works.  But when you
 *  distribute the same sections as part of a whole which is a work based
 *  on the Program, the distribution of the whole must be on the terms of
 *  this License, whose permissions for other licensees extend to the
 *  entire whole, and thus to each and every part regardless of who wrote it.
 *
 *     Thus, it is not the intent of this section to claim rights or contest
 *  your rights to work written entirely by you; rather, the intent is to
 *  exercise the right to control the distribution of derivative or
 *  collective works based on the Program.
 *
 *     In addition, mere aggregation of another work not based on the Program
 *  with the Program (or with a work based on the Program) on a volume of
 *  a storage or distribution medium does not bring the other work under
 *  the scope of this License.
 *
 *      3. You may copy and distribute the Program (or a work based on it,
 *  under Section 2) in object code or executable form under the terms of
 *  Sections 1 and 2 above provided that you also do one of the following:
 *
 *        a) Accompany it with the complete corresponding machine-readable
 *     source code, which must be distributed under the terms of Sections
 *     1 and 2 above on a medium customarily used for software interchange; or,
 *
 *        b) Accompany it with a written offer, valid for at least three
 *     years, to give any third party, for a charge no more than your
 *     cost of physically performing source distribution, a complete
 *     machine-readable copy of the corresponding source code, to be
 *     distributed under the terms of Sections 1 and 2 above on a medium
 *     customarily used for software interchange; or,
 *
 *        c) Accompany it with the information you received as to the offer
 *     to distribute corresponding source code.  (This alternative is
 *     allowed only for noncommercial distribution and only if you
 *     received the program in object code or executable form with such
 *     an offer, in accord with Subsection b above.)
 *
 *  The source code for a work means the preferred form of the work for
 *  making modifications to it.  For an executable work, complete source
 *  code means all the source code for all modules it contains, plus any
 *  associated interface definition files, plus the scripts used to
 *  control compilation and installation of the executable.  However, as a
 *  special exception, the source code distributed need not include
 *  anything that is normally distributed (in either source or binary
 *  form) with the major components (compiler, kernel, and so on) of the
 *  operating system on which the executable runs, unless that component
 *  itself accompanies the executable.
 *
 *  If distribution of executable or object code is made by offering
 *  access to copy from a designated place, then offering equivalent
 *  access to copy the source code from the same place counts as
 *  distribution of the source code, even though third parties are not
 *  compelled to copy the source along with the object code.
 *  
 *     4. You may not copy, modify, sublicense, or distribute the Program
 *  except as expressly provided under this License.  Any attempt
 *  otherwise to copy, modify, sublicense or distribute the Program is
 *  void, and will automatically terminate your rights under this License.
 *  However, parties who have received copies, or rights, from you under
 *  this License will not have their licenses terminated so long as such
 *  parties remain in full compliance.
 *
 *    5. You are not required to accept this License, since you have not
 *  signed it.  However, nothing else grants you permission to modify or
 *  distribute the Program or its derivative works.  These actions are
 *  prohibited by law if you do not accept this License.  Therefore, by
 *  modifying or distributing the Program (or any work based on the
 *  Program), you indicate your acceptance of this License to do so, and
 *  all its terms and conditions for copying, distributing or modifying
 *  the Program or works based on it.
 *
 *    6. Each time you redistribute the Program (or any work based on the
 *  Program), the recipient automatically receives a license from the
 *  original licensor to copy, distribute or modify the Program subject to
 *  these terms and conditions.  You may not impose any further
 *  restrictions on the recipients' exercise of the rights granted herein.
 *  You are not responsible for enforcing compliance by third parties to
 *  this License.
 *
 *    7. If, as a consequence of a court judgment or allegation of patent
 *  infringement or for any other reason (not limited to patent issues),
 *  conditions are imposed on you (whether by court order, agreement or
 *  otherwise) that contradict the conditions of this License, they do not
 *  excuse you from the conditions of this License.  If you cannot
 *  distribute so as to satisfy simultaneously your obligations under this
 *  License and any other pertinent obligations, then as a consequence you
 *  may not distribute the Program at all.  For example, if a patent
 *  license would not permit royalty-free redistribution of the Program by
 *  all those who receive copies directly or indirectly through you, then
 *  the only way you could satisfy both it and this License would be to
 *  refrain entirely from distribution of the Program.

 *  If any portion of this section is held invalid or unenforceable under
 *  any particular circumstance, the balance of the section is intended to
 *  apply and the section as a whole is intended to apply in other
 *  circumstances.

 *  It is not the purpose of this section to induce you to infringe any
 *  patents or other property right claims or to contest validity of any
 *  such claims; this section has the sole purpose of protecting the
 *  integrity of the free software distribution system, which is
 *  implemented by public license practices.  Many people have made
 *  generous contributions to the wide range of software distributed
 *  through that system in reliance on consistent application of that
 *  system; it is up to the author/donor to decide if he or she is willing
 *  to distribute software through any other system and a licensee cannot
 *  impose that choice.

 *  This section is intended to make thoroughly clear what is believed to
 *  be a consequence of the rest of this License.
 *  
 *    8. If the distribution and/or use of the Program is restricted in
 *  certain countries either by patents or by copyrighted interfaces, the
 *  original copyright holder who places the Program under this License
 *  may add an explicit geographical distribution limitation excluding
 *  those countries, so that distribution is permitted only in or among
 *  countries not thus excluded.  In such case, this License incorporates
 *  the limitation as if written in the body of this License.
 *
 *    9. The Free Software Foundation may publish revised and/or new versions
 *  of the General Public License from time to time.  Such new versions will
 *  be similar in spirit to the present version, but may differ in detail to
 *  address new problems or concerns.
 *
 *  Each version is given a distinguishing version number.  If the Program
 *  specifies a version number of this License which applies to it and "any
 *  later version", you have the option of following the terms and conditions
 *  either of that version or of any later version published by the Free
 *  Software Foundation.  If the Program does not specify a version number of
 *  this License, you may choose any version ever published by the Free Software
 *  Foundation.

 *    10. If you wish to incorporate parts of the Program into other free
 *  programs whose distribution conditions are different, write to the author
 *  to ask for permission.  For software which is copyrighted by the Free
 *  Software Foundation, write to the Free Software Foundation; we sometimes
 *  make exceptions for this.  Our decision will be guided by the two goals
 *  vof preserving the free status of all derivatives of our free software and
 *  of promoting the sharing and reuse of software generally.
 *
 *  			    NO WARRANTY
 *
 *    11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
 *  FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
 *  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
 *  PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
 *  OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
 *  TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
 *  PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
 *  REPAIR OR CORRECTION.
 *
 *    12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
 *  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
 *  REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
 *  INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
 *  OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
 *  TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
 *  YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
 *  PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGES.
 *
 *  		     END OF TERMS AND CONDITIONS
 *  
 *  	    How to Apply These Terms to Your New Programs
 *    If you develop a new program, and you want it to be of the greatest
 *  possible use to the public, the best way to achieve this is to make it
 *  free software which everyone can redistribute and change under these terms.
 *
 *    To do so, attach the following notices to the program.  It is safest
 *  to attach them to the start of each source file to most effectively
 *  convey the exclusion of warranty; and each file should have at least
 *  the "copyright" line and a pointer to where the full notice is found.
 *
 *      <one line to give the program's name and a brief idea of what it does.>
 *      Copyright (C) <year>  <name of author>
 *
 *      This program is free software; you can redistribute it and/or modify
 *      it under the terms of the GNU General Public License as published by
 *      the Free Software Foundation; either version 2 of the License, or
 *      (at your option) any later version.
 *
 *      This program is distributed in the hope that it will be useful,
 *      but WITHOUT ANY WARRANTY; without even the implied warranty of
 *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *      GNU General Public License for more details.
 *
 *      You should have received a copy of the GNU General Public License
 *      along with this program; if not, write to the Free Software
 *      Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *
 *
 *  Also add information on how to contact you by electronic and paper mail.
 *
 *  If the program is interactive, make it output a short notice like this
 *  when it starts in an interactive mode:
 *
 *      Gnomovision version 69, Copyright (C) year name of author
 *      Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
 *      This is free software, and you are welcome to redistribute it
 *      under certain conditions; type `show c' for details.
 *
 *  The hypothetical commands `show w' and `show c' should show the appropriate
 *  parts of the General Public License.  Of course, the commands you use may
 *  be called something other than `show w' and `show c'; they could even be
 *  mouse-clicks or menu items--whatever suits your program.
 *
 *  You should also get your employer (if you work as a programmer) or your
 *  school, if any, to sign a "copyright disclaimer" for the program, if
 *  necessary.  Here is a sample; alter the names:
 *
 *    Yoyodyne, Inc., hereby disclaims all copyright interest in the program
 *    `Gnomovision' (which makes passes at compilers) written by James Hacker.
 *
 *    <signature of Ty Coon>, 1 April 1989
 *    Ty Coon, President of Vice

 *  This General Public License does not permit incorporating your program into
 *  proprietary programs.  If your program is a subroutine library, you may
 *  consider it more useful to permit linking proprietary applications with the
 *  library.  If this is what you want to do, use the GNU Library General
 *  Public License instead of this License.

*/


package it.aco.mandragora.as.impl;

import it.aco.mandragora.as.ApplicationService;
import it.aco.mandragora.bo.ValueObjectsAttributeMapBO;
import it.aco.mandragora.common.Utils;
import it.aco.mandragora.common.utils.BeanCollectionUtils;
import it.aco.mandragora.common.utils.PersistenceUtil;
import it.aco.mandragora.comparator.BeanFieldComparator;
import it.aco.mandragora.comparator.FieldComparator;
import it.aco.mandragora.dao.DAO;
import it.aco.mandragora.exception.ApplicationServiceException;
import it.aco.mandragora.exception.BusinessObjectException;
import it.aco.mandragora.exception.DataAccessException;
import it.aco.mandragora.exception.ServiceLocatorException;

import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.Map;
import java.util.Vector;

import org.apache.commons.beanutils.BeanUtilsBean;
import org.apache.commons.beanutils.ConstructorUtils;
import org.apache.commons.beanutils.PropertyUtilsBean;


public abstract class BaseApplicationService implements ApplicationService{



    private static  org.apache.log4j.Category log = org.apache.log4j.Logger.getLogger(BaseApplicationService.class.getName());




    protected abstract DAO getDAO()throws ApplicationServiceException;



    public Collection getReferenceCollectionOrRetrieveIfNull(Object pInstance, String pAttributeName) throws ApplicationServiceException{
        try{

            if (pInstance == null || pAttributeName== null || pAttributeName.trim().equals("")){
                throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.getReferenceCollectionOrRetrieveIfNull(Object pInstance, String pAttributeName): pInstance can't be null, pAttributeName can't be null, nor empty string nor blank characters string" );
            }
            //PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();
            //Collection collection= (Collection)propertyUtilsBean.getProperty(pInstance,pAttributeName);//deleted  by Alessandro on 7-Dec-2008
            //Collection collection= (Collection)Utils.getPropertyIfNotNullOnPath(pInstance,pAttributeName); //added  by Alessandro on 7-Dec-2008
            Collection collection= (Collection)BeanCollectionUtils.getPropertyIfNotNullOnPath(pInstance,pAttributeName); //added  by Alessandro on 7-Dec-2008
            if (collection == null) {
                DAO dao = getDAO();
                dao.retrievePathReference(pInstance,pAttributeName);
                //collection= (Collection)propertyUtilsBean.getProperty(pInstance,pAttributeName);  //deleted  by Alessandro on 7-Dec-2008
                //collection= (Collection)Utils.getPropertyIfNotNullOnPath(pInstance,pAttributeName);  //added  by Alessandro on 7-Dec-2008
                collection= (Collection)BeanCollectionUtils.getPropertyIfNotNullOnPath(pInstance,pAttributeName);  //added  by Alessandro on 7-Dec-2008
            }
            return collection;
        }catch (IllegalAccessException e) {
            log.error("IllegalAccessException caught in BaseApplicationService.getReferenceCollectionOrRetrieveIfNull(Object pInstance, String pAttributeName): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.getReferenceCollectionOrRetrieveIfNull(Object pInstance, String pAttributeName): " + e.toString(),e);
        }catch (NoSuchMethodException e) {
            log.error("NoSuchMethodException caught in BaseApplicationService.getReferenceCollectionOrRetrieveIfNull(Object pInstance, String pAttributeName): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.getReferenceCollectionOrRetrieveIfNull(Object pInstance, String pAttributeName) : " + e.toString(),e);
        }catch (InvocationTargetException e) {
            log.error("InvocationTargetException caught in BaseApplicationService.getReferenceCollectionOrRetrieveIfNull(Object pInstance, String pAttributeName): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.getReferenceCollectionOrRetrieveIfNull(Object pInstance, String pAttributeName) : " + e.toString(),e);
        }catch (DataAccessException e) {
            log.error("DataAccessException caught in BaseApplicationService.getReferenceCollectionOrRetrieveIfNull(Object pInstance, String pAttributeName): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.getReferenceCollectionOrRetrieveIfNull(Object pInstance, String pAttributeName) : " + e.toString(),e);
        } catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.getReferenceCollectionOrRetrieveIfNull(Object pInstance, String pAttributeName): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.getReferenceCollectionOrRetrieveIfNull(Object pInstance, String pAttributeName) : " + e.toString(),e);
        }
    }






    public Collection getReferenceCollectionOrEmptyIfNull(Object pInstance, String pAttributeName) throws ApplicationServiceException{
        return  getReferenceCollectionOrEmptyIfNull(pInstance, pAttributeName, null);
    }


    public Collection getReferenceCollectionOrEmptyIfNull(Object pInstance, String pAttributeName, Class collectionImplClass) throws ApplicationServiceException{
        try{
            Collection collection = null;
            if (pInstance == null || pAttributeName== null || pAttributeName.trim().equals("")){
                throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.getReferenceCollectionOrEmptyIfNull(Object pInstance, String pAttributeName, Class pAttributeNameClass): pInstance can't be null, pAttributeName can't be null, nor empty string nor blank characters string" );
            }
            PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();

            // start added by Alessandro on 29-Nov-2008
            String[] firstAttributeNameAndRemainingPath = Utils.getFirstAttributeNameAndRemainingPath(pAttributeName) ;
            String firstAttributeName = firstAttributeNameAndRemainingPath[0];
            String remainingPath = firstAttributeNameAndRemainingPath[1];
            Object valueObject = pInstance;
            while(!firstAttributeName.trim().equals("")){  // the two break inside the body make the truth of this condition never reached
                if(!remainingPath.trim().equals(""))  {
                    if (Collection.class.isInstance(valueObject)) {
                        throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.getReferenceCollectionOrEmptyIfNull(Object pInstance, String pAttributeName, Class pAttributeNameClass): The path have to be a walk through only value objects, with no collection on its walk, except for  the last attribute that must be a collection (note that if pAttributeName is a single token it must be a reference to a collection)." );
                    }
                    valueObject = propertyUtilsBean.getProperty(valueObject,firstAttributeName);
                    if(valueObject == null) break;
                } else { // is last token and must be a collection
                    collection= (Collection)propertyUtilsBean.getProperty(valueObject,firstAttributeName);
                    break; // this break force that when the loop ends  firstAttributeName is the last token.
                }
                firstAttributeNameAndRemainingPath = Utils.getFirstAttributeNameAndRemainingPath(remainingPath) ;
                firstAttributeName = firstAttributeNameAndRemainingPath[0];
                remainingPath = firstAttributeNameAndRemainingPath[1];
            }
            if(collection==null) {
                log.debug("getReferenceCollectionOrEmptyIfNull : collection is  null");
                DAO dao=getDAO();
                String[] exceptLastTokenAndLastToken = Utils.getExceptLastTokenAndLastToken(pAttributeName);

                if(valueObject==null) {
                    log.debug("getReferenceCollectionOrEmptyIfNull : valueObject is  null");
                    dao.retrieveNullPathReference(pInstance,exceptLastTokenAndLastToken[0]);
                }

                // start added  by Alessandro on 6-Dec-2008
                log.debug("getReferenceCollectionOrEmptyIfNull : before propertyUtilsBean.getProperty(pInstance,exceptLastTokenAndLastToken[0])   ");
                //valueObject = propertyUtilsBean.getProperty(pInstance,exceptLastTokenAndLastToken[0]); // added  by Alessandro on 6-Dec-2008 and deleted on  7-Dec-2008
                //valueObject = Utils.getPropertyIfNotNullOnPath(pInstance,exceptLastTokenAndLastToken[0]); // added  by Alessandro on 7-Dec-2008
                valueObject = BeanCollectionUtils.getPropertyIfNotNullOnPath(pInstance,exceptLastTokenAndLastToken[0]); // added  by Alessandro on 7-Dec-2008
                if(valueObject==null) {
                    return null;
                }
                // end added  by Alessandro on 6-Dec-2008
                if (collectionImplClass == null){
                    collectionImplClass = dao.getCollectionClassFromPath(getEntityClass(pInstance),pAttributeName);
                    log.debug("getReferenceCollectionOrEmptyIfNull : collectionImplClass is  "+collectionImplClass);
                }
                log.debug("getReferenceCollectionOrEmptyIfNull : definitive collectionImplClass is  "+collectionImplClass);
                collection = (Collection) ConstructorUtils.invokeConstructor(collectionImplClass,null,null) ;
                //valueObject = propertyUtilsBean.getProperty(pInstance,exceptLastTokenAndLastToken[0]); // deleted  by Alessandro on 6-Dec-2008

                log.debug("getReferenceCollectionOrEmptyIfNull : valueObject is  "+valueObject.toString());
                propertyUtilsBean.setProperty(valueObject, exceptLastTokenAndLastToken[1], collection );
            }
            // end added by Alessandro on 29-Nov-2008


            /* deleted   by Alessandro on 30-Nov-2008
            Collection collection= (Collection)propertyUtilsBean.getProperty(pInstance,pAttributeName);
            if (collection == null) {
                DAO dao=getDAO();
                if (collectionImplClass == null){
                    collectionImplClass = dao.getCollectionClassFromPath(pInstance.getClass(), pAttributeName);
                }

                String[] exceptLastTokenAndLastToken = Utils.getExceptLastTokenAndLastToken(pAttributeName);

                dao.retrieveNullPathReference(pInstance,exceptLastTokenAndLastToken[0]);

                Object valueObject = propertyUtilsBean.getProperty(pInstance,exceptLastTokenAndLastToken[0]);
                if (valueObject!=null){
                    collection = (Collection) ConstructorUtils.invokeConstructor(collectionImplClass,null,null) ;
                    propertyUtilsBean.setProperty(valueObject, exceptLastTokenAndLastToken[1], collection );
                }
            }
            */
            return collection;
        }catch (IllegalAccessException e) {
            log.error("IllegalAccessException caught in BaseApplicationService.getReferenceCollectionOrEmptyIfNull(Object pInstance, String pAttributeName, Class collectionImplClass): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.getReferenceCollectionOrEmptyIfNull(Object pInstance, String pAttributeName, Class collectionImplClass): " + e.toString(),e);
        }catch (InvocationTargetException e) {
            log.error("InvocationTargetException caught in BaseApplicationService.getReferenceCollectionOrEmptyIfNull(Object pInstance, String pAttributeName, Class collectionImplClass): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.getReferenceCollectionOrEmptyIfNull(Object pInstance, String pAttributeName, Class collectionImplClass): " + e.toString(),e);
        }catch (NoSuchMethodException e) {
            log.error("NoSuchMethodException caught in BaseApplicationService.getReferenceCollectionOrEmptyIfNull(Object pInstance, String pAttributeName, Class collectionImplClass): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.getReferenceCollectionOrEmptyIfNull(Object pInstance, String pAttributeName, Class collectionImplClass): " + e.toString(),e);
        }catch (InstantiationException e) {
            log.error("NoSuchMethodException caught in BaseApplicationService.getReferenceCollectionOrEmptyIfNull(Object pInstance, String pAttributeName, Class collectionImplClass): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.getReferenceCollectionOrEmptyIfNull(Object pInstance, String pAttributeName, Class collectionImplClass): " + e.toString(),e);
        }catch (DataAccessException e) {
            log.error("DataAccessException caught in BaseApplicationService.getReferenceCollectionOrEmptyIfNull(Object pInstance, String pAttributeName, Class collectionImplClass): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.getReferenceCollectionOrEmptyIfNull(Object pInstance, String pAttributeName, Class collectionImplClass): " + e.toString(),e);
        }catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.getReferenceCollectionOrEmptyIfNull(Object pInstance, String pAttributeName, Class collectionImplClass): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.getReferenceCollectionOrEmptyIfNull(Object pInstance, String pAttributeName, Class collectionImplClass): " + e.toString(),e);
        }
    }




    public Collection getInverseForeignKeyNotPKFields(Class realClass, String pAttributeName)throws ApplicationServiceException{
        try{
            DAO dao = getDAO();
            Collection inverseForeignKeyFields;
            inverseForeignKeyFields = dao.getInverseForeignKeyFields(realClass,pAttributeName);
            if (inverseForeignKeyFields!=null){
                String[] pkNames = getPkNames(realClass,  pAttributeName);
                if (pkNames!=null && pkNames.length!=0){
                    Iterator iterator = inverseForeignKeyFields.iterator();
                    while (iterator.hasNext()) {
                        String inverseForeignKeyField = (String)iterator.next();
                        for (int i =0; i<pkNames.length; i++){
                            if (inverseForeignKeyField.equals(pkNames[i])) {
                                iterator.remove();
                                break;
                            }
                        }
                    }
                }
            }
            return inverseForeignKeyFields;
        } catch (DataAccessException e) {
            log.error("DataAccessException caught in BaseApplicationService.getInverseForeignKeyNotPKFields(Class realClass, String pAttributeName)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.getInverseForeignKeyNotPKFields(Class realClass, String pAttributeName)" + e.toString(),e);
        } catch (Exception e) {
            log.error("DataAccessException caught in BaseApplicationService.getInverseForeignKeyNotPKFields(Class realClass, String pAttributeName)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.getInverseForeignKeyNotPKFields(Class realClass, String pAttributeName)" + e.toString(),e);
        }
    }





    public String[] getPkNotInverseForeignKeyFields(Class realClass, String pAttributeName) throws ApplicationServiceException{
        try{

            String[] pkNames = getPkNames(realClass,  pAttributeName);
            if(pkNames!=null && pkNames.length!=0){

                DAO dao = getDAO();
                Collection inverseForeignKeyFields;
                inverseForeignKeyFields = dao.getInverseForeignKeyFields(realClass,pAttributeName);

                if(inverseForeignKeyFields!=null &&!inverseForeignKeyFields.isEmpty()){
                    Vector pkNotInverseForeignKeyFields = new Vector();
                    for (int i =0; i<pkNames.length; i++){
                        boolean found = false;
                        Iterator inverseForeignKeyFieldsIterator = inverseForeignKeyFields.iterator();
                        while (inverseForeignKeyFieldsIterator.hasNext()){
                           String inverseForeignKeyField = (String)  inverseForeignKeyFieldsIterator.next();
                            if (inverseForeignKeyField.equals(pkNames[i])) {
                                found = true;
                                break;
                            }
                        }
                        if (!found)pkNotInverseForeignKeyFields.add(pkNames[i]);
                    }
                    pkNames = (String[]) pkNotInverseForeignKeyFields.toArray(new String[]{});
                }
            }
            return pkNames;
        } catch (DataAccessException e) {
            log.error("DataAccessException caught in BaseApplicationService.getPkNotInverseForeignKeyFields(Class realClass, String pAttributeName)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.getPkNotInverseForeignKeyFields(Class realClass, String pAttributeName)" + e.toString(),e);
        } catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.getPkNotInverseForeignKeyFields(Class realClass, String pAttributeName)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.getPkNotInverseForeignKeyFields(Class realClass, String pAttributeName)" + e.toString(),e);
        }
    }




    public String[] getPkNotForeignKeyFields(Class realClass, String pAttributeName) throws ApplicationServiceException{
        try{


            if (realClass == null ) throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.getPkNotInverseForeignKeyFields(Class realClass, String pAttributeName): real class can't be null ");
            if (pAttributeName == null ||pAttributeName.trim().equals("") ) throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.getPkNotInverseForeignKeyFields(Class realClass, String pAttributeName): pAttributeName can't be null nor empty or blank characters string");


            String[] exceptLastTokenAndLastToken = Utils.getExceptLastTokenAndLastToken(pAttributeName);

            String[] pkNames = getPkNames(realClass,  exceptLastTokenAndLastToken[0]);

            if(pkNames!=null && pkNames.length!=0){

                DAO dao = getDAO();
                Collection foreignKeyFields;
                foreignKeyFields = dao.getForeignKeyFields(realClass,pAttributeName);
                if(foreignKeyFields!=null &&!foreignKeyFields.isEmpty()){
                    Vector pkNotForeignKeyFields = new Vector();
                    for (int i =0; i<pkNames.length; i++){
                        boolean found = false;
                        Iterator foreignKeyFieldsFieldsIterator = foreignKeyFields.iterator();
                        while (foreignKeyFieldsFieldsIterator.hasNext()){
                           String foreignKeyField = (String)  foreignKeyFieldsFieldsIterator.next();
                            if (foreignKeyField.equals(pkNames[i])) {
                                found = true;
                                break;
                            }
                        }
                        if (!found)pkNotForeignKeyFields.add(pkNames[i]);
                    }
                    pkNames = (String[]) pkNotForeignKeyFields.toArray(new String[]{});
                }
            }
            return pkNames;
         } catch (DataAccessException e) {
            log.error("DataAccessException caught in BaseApplicationService.getPkNotForeignKeyFields(Class realClass, String pAttributeName)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.getPkNotForeignKeyFields(Class realClass, String pAttributeName)" + e.toString(),e);
         } catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.getPkNotForeignKeyFields(Class realClass, String pAttributeName)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.getPkNotForeignKeyFields(Class realClass, String pAttributeName)" + e.toString(),e);
         }
    }





    public String[] getPkNames(Class realClass, String pAttributeName) throws ApplicationServiceException{
        try{

            if (realClass == null) throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.getPkNames(Class realClass, String pAttributeName): realClass can't be null" );
            DAO dao = getDAO();

            if (pAttributeName==null || pAttributeName.trim().equals("")) return dao.getPkNames(realClass);
            return dao.getPkNames(dao.getClassFromPath(realClass,pAttributeName));
        } catch (DataAccessException e) {
            log.error("DataAccessException caught in BaseApplicationServicegetPkNames(Class realClass, String pAttributeName)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.getPkNames(Class realClass, String pAttributeName)" + e.toString(),e);
        } catch (Exception e) {
            log.error("Exception caught in BaseApplicationServicegetPkNames(Class realClass, String pAttributeName)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.getPkNames(Class realClass, String pAttributeName)" + e.toString(),e);
        }
    }


    /**
     * TODO use DAO.getKeyValues(Object pInstance,String pAttributeName)
     * @param pInstance
     * @param pAttributeName
     * @return
     * @throws it.aco.mandragora.exception.ApplicationServiceException
     */
    public Object[] getKeyValues(Object pInstance,String pAttributeName) throws ApplicationServiceException{
        try{


            if (pInstance==null) return null; // modified by alessandro on 02/02/2008
            DAO dao = getDAO();
            if (pAttributeName==null || pAttributeName.trim().equals("")) {
                return dao.getKeyValues(pInstance);
            }
            //PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();
            //Object valueObjectToGetKeyValues=propertyUtilsBean.getProperty(pInstance,pAttributeName);   // deleted by Alessandro on 7-dec 2008
            //Object valueObjectToGetKeyValues=Utils.getPropertyIfNotNullOnPath(pInstance,pAttributeName); // added by Alessandro on 7-dec 2008
            Object valueObjectToGetKeyValues=BeanCollectionUtils.getPropertyIfNotNullOnPath(pInstance,pAttributeName); // added by Alessandro on 7-dec 2008
            if(valueObjectToGetKeyValues==null) return null;

            return dao.getKeyValues(valueObjectToGetKeyValues);
        } catch (DataAccessException e) {
            log.error("DataAccessException caught in BaseApplicationService.getKeyValues(Object pInstance,String pAttributeName) " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.getKeyValues(Object pInstance,String pAttributeName)" + e.toString(),e);
        } catch (IllegalAccessException e) {
            log.error("IllegalAccessException caught in BaseApplicationService.getKeyValues(Object pInstance,String pAttributeName) " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.getKeyValues(Object pInstance,String pAttributeName)" + e.toString(),e);
        } catch (InvocationTargetException e) {
            log.error("InvocationTargetException caught in BaseApplicationService.getKeyValues(Object pInstance,String pAttributeName) " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.getKeyValues(Object pInstance,String pAttributeName)" + e.toString(),e);
        } catch (NoSuchMethodException e) {
            log.error("NoSuchMethodException caught in BaseApplicationService.getKeyValues(Object pInstance,String pAttributeName) " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.getKeyValues(Object pInstance,String pAttributeName)" + e.toString(),e);
        } catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.getKeyValues(Object pInstance,String pAttributeName) " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.getKeyValues(Object pInstance,String pAttributeName)" + e.toString(),e);
        }
    }


    /**
     * 
     * @param pInstance
     * @param pAttributeName
     * @throws it.aco.mandragora.exception.ApplicationServiceException
     */
    public void setInverseForeignKeyFields(Object pInstance, String pAttributeName) throws ApplicationServiceException{
        try{


            DAO dao = getDAO();
            dao.setInverseForeignKeyFields(pInstance, pAttributeName);
            //changed for direct use of DAO on 10-09-2011
//            String [] exceptLastTokenAndLastToken = Utils.getExceptLastTokenAndLastToken(pAttributeName);
//
//            Collection inverseForeignKeyFields;
//            Object[] keyValues;
//
//            inverseForeignKeyFields = dao.getInverseForeignKeyFields(pInstance.getClass(),pAttributeName);
//            keyValues=getKeyValues(pInstance,exceptLastTokenAndLastToken[0]);
//
//
//            if (inverseForeignKeyFields== null||inverseForeignKeyFields.isEmpty()) throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.setInverseForeignKeyFields(Object pInstance, String pAttributeName):No Foreign Key Fields found" );
//            if (keyValues== null||keyValues.length==0) throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.setInverseForeignKeyFields(Object pInstance, String pAttributeName):No pInstance PKValues found" );
//            if (keyValues.length!=inverseForeignKeyFields.size())  throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.setInverseForeignKeyFields(Object pInstance, String pAttributeName):Foreign Key Fields and pInstance PKValues do not have the same number of elements " );
//            PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();
//            Collection pAttributeNameCollection =(Collection) propertyUtilsBean.getProperty(pInstance,pAttributeName);
//            if(pAttributeNameCollection!=null){
//
//                Iterator pAttributeNameCollectionIterator = pAttributeNameCollection.iterator();
//                while (pAttributeNameCollectionIterator.hasNext()){
//                    Object pAttributeNameCollectionElement= pAttributeNameCollectionIterator.next();
//                    int i=0;
//                    Iterator inverseForeignKeyFieldsIterator = inverseForeignKeyFields.iterator();
//                    while(inverseForeignKeyFieldsIterator.hasNext()){
//                        propertyUtilsBean.setProperty(pAttributeNameCollectionElement,(String)inverseForeignKeyFieldsIterator.next(),keyValues[i]);
//                        i++;
//                    }
//                }
//            }
        } catch (DataAccessException e) {
            log.error("DataAccessException caught in BaseApplicationService.setInverseForeignKeyFields(Object pInstance, String pAttributeName): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.setInverseForeignKeyFields(Object pInstance, String pAttributeName)" + e.toString(),e);
        } /*catch (IllegalAccessException e) {
            log.error("IllegalAccessException caught in BaseApplicationService.setInverseForeignKeyFields(Object pInstance, String pAttributeName): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.setInverseForeignKeyFields(Object pInstance, String pAttributeName)" + e.toString(),e);
        } catch (InvocationTargetException e) {
            log.error("InvocationTargetException caught in BaseApplicationService.setInverseForeignKeyFields(Object pInstance, String pAttributeName): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.setInverseForeignKeyFields(Object pInstance, String pAttributeName)" + e.toString(),e);
        } catch (NoSuchMethodException e) {
            log.error("NoSuchMethodException caught in BaseApplicationService.setInverseForeignKeyFields(Object pInstance, String pAttributeName): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.setInverseForeignKeyFields(Object pInstance, String pAttributeName)" + e.toString(),e);
        }*/ catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.setInverseForeignKeyFields(Object pInstance, String pAttributeName): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.setInverseForeignKeyFields(Object pInstance, String pAttributeName)" + e.toString(),e);
        }
    }


    //TODO do using the dao.setForeignKeyFields(Object pInstance, String pAttributeName) (when is done!!!)
    public void setForeignKeyFields(Object pInstance, String pAttributeName) throws ApplicationServiceException{
        try{

            if (pInstance == null) throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.setForeignKeyFields(Object pInstance, String pAttributeName): pInstance can't be null ");
            if(pAttributeName.trim().equals("")) return;
            DAO dao = getDAO();
            Object[] foreignKeyFieldsValues;
            foreignKeyFieldsValues = getKeyValues(pInstance,pAttributeName);
            Collection foreignKeyFieldsCollection=dao.getForeignKeyFields( getEntityClass(pInstance),  pAttributeName);
            if (foreignKeyFieldsValues !=null && foreignKeyFieldsCollection!=null &&!foreignKeyFieldsCollection.isEmpty() ){
            	
                String[] foreignKeyFields =(String[]) foreignKeyFieldsCollection.toArray(new String[]{});
                String[] exceptLastTokenAndLastToken =Utils.getExceptLastTokenAndLastToken(pAttributeName);
                PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();
                Object objectToSet;
                if (exceptLastTokenAndLastToken[0].equals("")){
                    objectToSet = pInstance;
                }else{
                    objectToSet = propertyUtilsBean.getProperty(pInstance,exceptLastTokenAndLastToken[0]);
                }
                BeanCollectionUtils.setAttributes(objectToSet, foreignKeyFields, foreignKeyFieldsValues);
            }
        } catch (DataAccessException e) {
            log.error("DataAccessException caught in BaseApplicationService.setForeignKeyFields(Object pInstance, String pAttributeName): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.setForeignKeyFields(Object pInstance, String pAttributeName)" + e.toString(),e);
        } catch (IllegalAccessException e) {
            log.error("IllegalAccessException caught in BaseApplicationService.setForeignKeyFields(Object pInstance, String pAttributeName): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.setForeignKeyFields(Object pInstance, String pAttributeName)" + e.toString(),e);
        } catch (InvocationTargetException e) {
            log.error("InvocationTargetException caught in BaseApplicationService.setForeignKeyFields(Object pInstance, String pAttributeName): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.setForeignKeyFields(Object pInstance, String pAttributeName)" + e.toString(),e);
        } catch (NoSuchMethodException e) {
            log.error("NoSuchMethodException caught in BaseApplicationService.setForeignKeyFields(Object pInstance, String pAttributeName): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.setForeignKeyFields(Object pInstance, String pAttributeName)" + e.toString(),e);
        } catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.setForeignKeyFields(Object pInstance, String pAttributeName): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.setForeignKeyFields(Object pInstance, String pAttributeName)" + e.toString(),e);
        }
    }





    public boolean isKeyNotNull(Object pInstance) throws ApplicationServiceException{
        try{
            String[] pKNames = getPkNames(getEntityClass(pInstance),"");
            return Utils.areAllAttributesValuesNotNull(pInstance,pKNames);

        } catch (ApplicationServiceException e) {
            log.error("ApplicationServiceException caught in BaseApplicationService. isKeyNotNull(Object pInstance)): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.isKeyNotNull(Object pInstance)" + e.toString(),e);
        } catch (Exception e) {
            log.error("Exception caught in BaseApplicationService. isKeyNotNull(Object pInstance)): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.isKeyNotNull(Object pInstance)" + e.toString(),e);
        }
    }

    public boolean isKeyNotNull(Collection valueObjectsCollection) throws ApplicationServiceException{
        try{

            if (valueObjectsCollection==null)throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.isKeyNotNull(Collection valueObjectsCollection):valueObjectsCollection can't be null");
            Iterator iterator = valueObjectsCollection.iterator();
            while (iterator.hasNext()){
                if (!isKeyNotNull(iterator.next())) return false;
            }

            return true;
        }  catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.isKeyNotNull(Collection valueObjectsCollection): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.isKeyNotNull(Collection valueObjectsCollection)" + e.toString(),e);
        }
    }





    public void addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, String valueObjectValueAttributeName, String mapValueClassAttributeToSetName, Class mapValueClass) throws ApplicationServiceException{
        try{
            if (ValueObjectsAttributeMapBO.class.isInstance(map)){
                ((ValueObjectsAttributeMapBO)map).addNoOverwrite(valueObjectsCollection, valueObjectKeyAttributeName, valueObjectValueAttributeName, mapValueClassAttributeToSetName, mapValueClass);
            }else{
                ValueObjectsAttributeMapBO.addNoOverwrite(valueObjectsCollection, map , valueObjectKeyAttributeName, valueObjectValueAttributeName, mapValueClassAttributeToSetName, mapValueClass);
            }
        } catch (BusinessObjectException e) {
            log.error("BusinessObjectException caught in BaseApplicationService.addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, String valueObjectValueAttributeName, String mapValueClassAttributeToSetName, Class mapValueClass): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, String valueObjectValueAttributeName, String mapValueClassAttributeToSetName, Class mapValueClass): " + e.toString(),e);
        } catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, String valueObjectValueAttributeName, String mapValueClassAttributeToSetName, Class mapValueClass): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, String valueObjectValueAttributeName, String mapValueClassAttributeToSetName, Class mapValueClass): " + e.toString(),e);
        }
    }


    public  void  addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, String valueObjectValueAttributeName,Class mapValueClass) throws ApplicationServiceException{
        try{
            if (ValueObjectsAttributeMapBO.class.isInstance(map)){
                ((ValueObjectsAttributeMapBO)map).addNoOverwrite(valueObjectsCollection, valueObjectKeyAttributeName, valueObjectValueAttributeName,  mapValueClass);
            }else{
                ValueObjectsAttributeMapBO.addNoOverwrite(valueObjectsCollection, map , valueObjectKeyAttributeName, valueObjectValueAttributeName,  mapValueClass);
            }
        } catch (BusinessObjectException e) {
            log.error("BusinessObjectException caught in BaseApplicationService.addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, String valueObjectValueAttributeName,Class mapValueClass): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, String valueObjectValueAttributeName,Class mapValueClass): " + e.toString(),e);
        } catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, String valueObjectValueAttributeName,Class mapValueClass): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, String valueObjectValueAttributeName,Class mapValueClass): " + e.toString(),e);
        }
    }



    public void  addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, Class mapValueClass) throws ApplicationServiceException{
        try{
            if (ValueObjectsAttributeMapBO.class.isInstance(map)){
                ((ValueObjectsAttributeMapBO)map).addNoOverwrite(valueObjectsCollection, valueObjectKeyAttributeName, mapValueClass);
            }else{
                ValueObjectsAttributeMapBO.addNoOverwrite(valueObjectsCollection, map , valueObjectKeyAttributeName, mapValueClass);
            }
        } catch (BusinessObjectException e) {
            log.error("BusinessObjectException caught in BaseApplicationService.addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, Class mapValueClass): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, Class mapValueClass): " + e.toString(),e);
        } catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, Class mapValueClass): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, Class mapValueClass): " + e.toString(),e);
        }
    }



    public void  addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, String valueObjectValueAttributeName) throws ApplicationServiceException{
         try{
            if (ValueObjectsAttributeMapBO.class.isInstance(map)){
                ((ValueObjectsAttributeMapBO)map).addNoOverwrite(valueObjectsCollection,  valueObjectKeyAttributeName,  valueObjectValueAttributeName);
            }else{
                ValueObjectsAttributeMapBO.addNoOverwrite( valueObjectsCollection,  map,  valueObjectKeyAttributeName,  valueObjectValueAttributeName);
            }
        } catch (BusinessObjectException e) {
            log.error("BusinessObjectException caught in BaseApplicationService.addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, String valueObjectValueAttributeName): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, String valueObjectValueAttributeName): " + e.toString(),e);
        } catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, String valueObjectValueAttributeName): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, String valueObjectValueAttributeName): " + e.toString(),e);
        }
    }



    public void  addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName) throws ApplicationServiceException{
        try{
            if (ValueObjectsAttributeMapBO.class.isInstance(map)){
                ((ValueObjectsAttributeMapBO)map).addNoOverwrite(valueObjectsCollection,  valueObjectKeyAttributeName);
            }else{
                ValueObjectsAttributeMapBO.addNoOverwrite( valueObjectsCollection,  map,  valueObjectKeyAttributeName);
            }
        } catch (BusinessObjectException e) {
            log.error("BusinessObjectException caught in BaseApplicationService.addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName): " + e.toString(),e);
        } catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName): " + e.toString(),e);
        }
    }

    public void  updateCollectionWithMap(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, String valueObjectValueAttributeName) throws ApplicationServiceException{
        try{
            if (ValueObjectsAttributeMapBO.class.isInstance(map)){
                ((ValueObjectsAttributeMapBO)map).updateCollection(valueObjectsCollection,  valueObjectKeyAttributeName, valueObjectValueAttributeName);
            }else{
                ValueObjectsAttributeMapBO.updateCollection( valueObjectsCollection,  map,  valueObjectKeyAttributeName, valueObjectValueAttributeName);
            }
        } catch (BusinessObjectException e) {
            log.error("BusinessObjectException caught in BaseApplicationService.updateCollectionWithMap(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, String valueObjectValueAttributeName): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.updateCollectionWithMap(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, String valueObjectValueAttributeName): " + e.toString(),e);
        } catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.updateCollectionWithMap(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, String valueObjectValueAttributeName): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.updateCollectionWithMap(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, String valueObjectValueAttributeName): " + e.toString(),e);
        }
    }

    public void  updateCollectionWithMap(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName) throws ApplicationServiceException{
        try{
            if (ValueObjectsAttributeMapBO.class.isInstance(map)){
                ((ValueObjectsAttributeMapBO)map).updateCollection(valueObjectsCollection,  valueObjectKeyAttributeName);
            }else{
                ValueObjectsAttributeMapBO.updateCollection( valueObjectsCollection,  map,  valueObjectKeyAttributeName);
            }
        } catch (BusinessObjectException e) {
            log.error("BusinessObjectException caught in BaseApplicationService.updateCollectionWithMap(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.updateCollectionWithMap(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName): " + e.toString(),e);
        } catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.updateCollectionWithMap(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.updateCollectionWithMap(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName): " + e.toString(),e);
        }
    }



    public boolean addToCollection(Collection valueObjectsCollection, Object pInstance, String[] pAttributeNames) throws ApplicationServiceException{
        try{
            if(valueObjectsCollection == null)  throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.addToCollection(Collection valueObjectsCollection, Object pInstance,String[] pAttributeNames) :valueObjectsCollection can't be null" );
            if(pInstance == null)  throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.addToCollection(Collection valueObjectsCollection, Object pInstance,String[] pAttributeNames) :pInstance can't be null" );
            if (!isInCollection(valueObjectsCollection, pInstance, pAttributeNames)){
                valueObjectsCollection.add(pInstance);
                return true;
            }else{
                return false;
            }
        }catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.addToCollection(Collection valueObjectsCollection, Object pInstance, String[] pAttributeNames): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addToCollection(Collection valueObjectsCollection, Object pInstance, String[] pAttributeNames)" + e.toString(),e);
        }
    }



    public boolean addAllToCollection(Collection valueObjectsCollection, Collection  valueObjectsCollectionToAdd, String[] pAttributeNames) throws ApplicationServiceException{
        try{
            boolean added=false;
            if(valueObjectsCollection == null)  throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.addAllToCollection(Collection valueObjectsCollection, Collection  valueObjectsCollectionToAdd, String[] pAttributeNames) :valueObjectsCollection can't be null" );
            if(valueObjectsCollectionToAdd == null)  return false;
            Iterator iterator = valueObjectsCollectionToAdd.iterator();
            while (iterator.hasNext()){
                if (addToCollection(valueObjectsCollection,iterator.next(),pAttributeNames)) added=true;
            }
            return added;
        }catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.addAllToCollection(Collection valueObjectsCollection, Collection  valueObjectsCollectionToAdd, Comparator comparator): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addAllToCollection(Collection valueObjectsCollection, Collection  valueObjectsCollectionToAdd, String[] pAttributeNames)" + e.toString(),e);
        }
    }

    public boolean addAllToCollection(Collection valueObjectsCollection, Map map, Collection  valueObjectsCollectionToAdd, String pAttributeNameMapKey) throws ApplicationServiceException{
        try{
            if(valueObjectsCollection == null) throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addAllToCollection(Collection valueObjectsCollection, Map map, Collection  valueObjectsCollectionToAdd, String pAttributeNameMapKey) : valueObjectsCollection can't be null");

            Collection toAdd = Utils.selectWhereFieldIn(valueObjectsCollectionToAdd, pAttributeNameMapKey,  map);
            return addAllToCollection(valueObjectsCollection,toAdd,new String[]{pAttributeNameMapKey});
        }catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.addAllToCollection(Collection valueObjectsCollection, Map map, Collection  valueObjectsCollectionToAdd, String pAttributeNameMapKey): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addAllToCollection(Collection valueObjectsCollection, Map map, Collection  valueObjectsCollectionToAdd, String pAttributeNameMapKey)" + e.toString(),e);
        }
    }



    //TODO use BeanCollectionUtils
    public boolean removeFromCollection(Collection valueObjectsCollection, Object toRemovePInstance, String[] pAttributeNames) throws ApplicationServiceException{

        try{
            boolean removed = false;
            if (valueObjectsCollection==null) return false;
            if(pAttributeNames==null){
                pAttributeNames=getPkNames(getEntityClass(toRemovePInstance),null);
            }
            Comparator comparator = new FieldComparator(pAttributeNames);
            Object element;
            Iterator iterator = valueObjectsCollection.iterator();
            while (iterator.hasNext()){
                element = iterator.next();
                //if (comparator.compare(toRemovePInstance,element)!=0) { //deleted by Alessandro on 9-dec-2008
                if (comparator.compare(toRemovePInstance,element)==0) {  //added by Alessandro on 9-dec-2008
                    iterator.remove();
                    removed=true;
                }
            }
            return removed;
            /*
            TreeSet  collectionTS=new TreeSet(new FieldComparator(dao.getPkNames(element.getClass())));
            collectionTS.addAll(collection);
            if (collectionTS.remove(element)) {
                collection.clear();
                collection.addAll(collectionTS);
                return true;
            } else return false;
            */

        }catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.removeFromCollection(Collection valueObjectsCollection, Object toRemovePInstance, String[] pAttributeNames): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.removeFromCollection(Collection valueObjectsCollection, Object toRemovePInstance, String[] pAttributeNames)" + e.toString(),e);
        }

    }


    //TODO use beanutilscollection
    public boolean removeAllFromCollection(Collection valueObjectsCollection, Collection  valueObjectsCollectionToRemove, String[] pAttributeNames) throws ApplicationServiceException{
        try{
            boolean removed = false;
            if(valueObjectsCollection == null)  throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.addAllToCollection(Collection valueObjectsCollection, Collection  valueObjectsCollectionToAdd, String[] pAttributeNames) :valueObjectsCollection can't be null" );
            if(valueObjectsCollectionToRemove == null)  return false;
            Iterator iterator = valueObjectsCollectionToRemove.iterator();
            while (iterator.hasNext()){
                if (removeFromCollection(valueObjectsCollection,iterator.next(),pAttributeNames)) removed=true;
            }
            return removed;
        }catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.removeAllFromCollection(Collection valueObjectsCollection, Collection  valueObjectsCollectionToRemove, String[] pAttributeNames) : " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.removeAllFromCollection(Collection valueObjectsCollection, Collection  valueObjectsCollectionToRemove, String[] pAttributeNames) " + e.toString(),e);
        }
    }



    // todo put in BeanUtils Collection
    public boolean retainAllInCollection(Collection valueObjectsCollection, Collection toRetainValueObjectsCollection, String[] pAttributeNames) throws ApplicationServiceException{
        boolean removed = false;
        try{
            if (valueObjectsCollection==null) return false;
            if (toRetainValueObjectsCollection == null || toRetainValueObjectsCollection.isEmpty()){
                if(valueObjectsCollection.isEmpty()){
                    return false;
                }else{
                    valueObjectsCollection.clear();
                    return true;
                }

            }
            //Comparator comparator = new BeanFieldComparator(pAttributeNames) ;
            Comparator comparator = new FieldComparator(pAttributeNames) ;
            ArrayList arrayList = Collections.list(Collections.enumeration(toRetainValueObjectsCollection));
            Collections.sort(arrayList,comparator);

            Object element;
            Iterator iterator = valueObjectsCollection.iterator();
            while (iterator.hasNext()){
                element = iterator.next();
                if(Collections.binarySearch(arrayList,element,comparator)<0){
                    iterator.remove();
                    removed=true; // added by Alessandro on 8-dec-2008
                }
            }

        }catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.retainAllInCollection(Collection valueObjectsCollection, Collection toRetainValueObjectsCollection,String[] pAttributeNames): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.retainAllInCollection(Collection valueObjectsCollection, Collection toRetainValueObjectsCollection, String[] pAttributeNames)" + e.toString(),e);
        }
        return removed;
    }


    public boolean retainAllInCollection(Collection valueObjectsCollection, Map map, String pAttributeName) throws ApplicationServiceException{
        boolean removed = false;
        try{
            if (valueObjectsCollection==null || valueObjectsCollection.isEmpty()) return false;
            if(map == null || map.entrySet().isEmpty()){
                valueObjectsCollection.clear();
                return true;
            }
            PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();
            Iterator  iterator=valueObjectsCollection.iterator();
            while (iterator.hasNext()){
                Object item = iterator.next();
                if (map.get(propertyUtilsBean.getProperty(item,pAttributeName))==null){
                    iterator.remove();
                    removed=true;
                }
            }
            return removed;
        }catch (IllegalAccessException e) {
            log.error("IllegalAccessException caught in BaseApplicationService.retainAllInCollection(Collection valueObjectsCollection, Map map, String pAttributeName): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.retainAllInCollection(Collection valueObjectsCollection, Map map, String pAttributeName)" + e.toString(),e);
        }catch (InvocationTargetException e) {
            log.error("InvocationTargetException caught in BaseApplicationService.retainAllInCollection(Collection valueObjectsCollection, Map map, String pAttributeName): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.retainAllInCollection(Collection valueObjectsCollection, Map map, String pAttributeName)" + e.toString(),e);
        }catch (NoSuchMethodException e) {
            log.error("NoSuchMethodException caught in BaseApplicationService.retainAllInCollection(Collection valueObjectsCollection, Map map, String pAttributeName): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.retainAllInCollection(Collection valueObjectsCollection, Map map, String pAttributeName)" + e.toString(),e);
        }catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.retainAllInCollection(Collection valueObjectsCollection, Map map, String pAttributeName): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.retainAllInCollection(Collection valueObjectsCollection, Map map, String pAttributeName)" + e.toString(),e);
        }
    }

    /**
     * @deprecated use {@link it.aco.mandragora.common.utils.BeanCollectionUtils#getTreeLeaves(Object valueObjectOrCollection, String path)}
     * @param valueObjectOrCollection
     * @param path
     * @return
     * @throws it.aco.mandragora.exception.ApplicationServiceException
     */
    public Collection getTreeLeaves(Object valueObjectOrCollection, String path) throws ApplicationServiceException {
        Collection result=null;

        try{
            if (path==null||path.trim().equals("")||valueObjectOrCollection==null) return result ;

            String[] firstAttributeNameAndRemainingPath = Utils.getFirstAttributeNameAndRemainingPath( path);
            String firstAttributeName = firstAttributeNameAndRemainingPath[0];
            String remainingPath = firstAttributeNameAndRemainingPath[1];
            log.debug("BaseApplicationService.getTreeLeaves:firstAttributeName="+firstAttributeName);
            log.debug("BaseApplicationService.getTreeLeaves:remainingPath="+remainingPath);

            PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();

            if (Collection.class.isInstance(valueObjectOrCollection)){ //is a collection
                log.debug("BaseApplicationService.getTreeLeaves: valueobjectOrCollection is a collection");
                result = new ArrayList();
                Iterator iterator= ((Collection) valueObjectOrCollection).iterator();
                if(!remainingPath.equals("")){
                    while (iterator.hasNext()){
                        Collection collection = getTreeLeaves(propertyUtilsBean.getProperty(iterator.next(),firstAttributeName),remainingPath);
                        if(collection!=null){
                            result.addAll(collection);
                        }
                    }
                }else{
                    while (iterator.hasNext()){
                        Object beanOrCollection = propertyUtilsBean.getProperty(iterator.next(),firstAttributeName);
                        if (beanOrCollection!=null){
                            if (Collection.class.isInstance(beanOrCollection)){
                                result.addAll((Collection) beanOrCollection);
                            }else{
                                result.add(beanOrCollection);
                            }

                        }
                    }
                }
            }else {//is a valueobject
                log.debug("BaseApplicationService.getTreeLeaves: valueobjectOrCollection is a valueobject");
                if(!remainingPath.equals("")){
                    result = getTreeLeaves(propertyUtilsBean.getProperty(valueObjectOrCollection,firstAttributeName),remainingPath);
                }else {
                    result = new ArrayList();
                    Object beanOrCollection = propertyUtilsBean.getProperty(valueObjectOrCollection,firstAttributeName);
                    if (beanOrCollection!=null){
                        if (Collection.class.isInstance(beanOrCollection)){
                            result.addAll((Collection) beanOrCollection);
                        }else{
                            result.add(beanOrCollection);
                        }
                    }
                }
            }
        } catch (NoSuchMethodException e) {
            log.error("NoSuchMethodException caught in BaseApplicationService.getTreeLeaves(Object valueObjectOrCollection, String path): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.getTreeLeaves(Object valueobjectOrCollection, String path)" + e.toString(),e);
        } catch (IllegalAccessException e) {
            log.error("IllegalAccessException caught in BaseApplicationService.getTreeLeaves(Object valueObjectOrCollection, String path): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.getTreeLeaves(Object valueobjectOrCollection, String path)" + e.toString(),e);
        } catch (InvocationTargetException e) {
            log.error("InvocationTargetException caught in BaseApplicationService.getTreeLeaves(Object valueObjectOrCollection, String path): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.getTreeLeaves(Object valueobjectOrCollection, String path)" + e.toString(),e);
        } catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.getTreeLeaves(Object valueObjectOrCollection, String path): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.getTreeLeaves(Object valueobjectOrCollection, String path)" + e.toString(),e);
        }
        return result;
    }

    // todo to put in beanUtilsColelction
    public boolean isInCollection(Collection valueObjectsCollection, Object pInstance, String[] pAttributeNames) throws ApplicationServiceException{
        try{

            if (pInstance==null ) throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseApplicationService.isInCollection(Collection valueObjectsCollection, Object pInstance, String[] pAttributeNames) :pInstance can't be null" );
            if (pAttributeNames == null) {
                pAttributeNames = getPkNames(getEntityClass(pInstance),"");
            }
            if (valueObjectsCollection==null || valueObjectsCollection.isEmpty()) return false;
            //Comparator comparator = new BeanFieldComparator(pAttributeNames);
            Comparator comparator = new FieldComparator(pAttributeNames);
            ArrayList arrayList = Collections.list(Collections.enumeration(valueObjectsCollection));
            Collections.sort(arrayList,comparator);
            if(Collections.binarySearch(arrayList,pInstance,comparator)<0){
                return false;
            }else{
                return true;
            }
        } catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.isInCollection(Collection valueObjectsCollection, Object pInstance,  String[] pAttributeNames): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.isInCollection(Collection valueObjectsCollection, Object pInstance,  String[] pAttributeNames)" + e.toString(),e);
        }
    }

    public boolean isInCollection(Collection valueObjectsCollection, Object pInstance) throws ApplicationServiceException{
        try{
            return isInCollection( valueObjectsCollection,  pInstance,null);
        } catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.isInCollection(Collection valueObjectsCollection, Object pInstance,  String[] pAttributeNames): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.isInCollection(Collection valueObjectsCollection, Object pInstance,  String[] pAttributeNames)" + e.toString(),e);
        }
    }






    public Collection createCollectionWithTreeNodes( Class collectionImplClass, Class realClass, String[] pkNames, Object pInstance,  String path, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames,  String[] pAttributeNames,Object[] valuesArray) throws ApplicationServiceException{
        try{

            if (collectionImplClass == null || realClass == null ) throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.createCollectionWithTreeNodes(Class collectionImplClass, Class realClass, String[] pkNames, Object pInstance, String pAttributeName, String path, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, String[] pAttributeNames,Object[] valuesArray): collectionImplClass or realClass can't be null" );
            //if (pAttributeName == null || pAttributeName.trim().equals("")) throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.createCollectionWithTreeNodes(Class collectionImplClass, Class realClass, String[] pkNames, Object pInstance, String pAttributeName, String path, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, String[] pAttributeNames,Object[] valuesArray): pAttributeName can't be null nor empty string nor blank characters string" );
            if ((pAttributeNames==null && valuesArray!=null)||(pAttributeNames!=null && valuesArray==null)){
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.createCollectionWithTreeNodes(Class collectionImplClass, Class realClass, String[] pkNames, Object pInstance, String pAttributeName, String path, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, String[] pAttributeNames,Object[] valuesArray): parameters pAttributeNames and valuesArray must be both null or both not null" );
            }
            if (pAttributeNames!=null /*valuesArray != null surely*/ && pAttributeNames.length!=valuesArray.length){
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.createCollectionWithTreeNodes(Class collectionImplClass, Class realClass, String[] pkNames, Object pInstance, String pAttributeName, String path,String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, String[] pAttributeNames,Object[] valuesArray): parameters pAttributeNames and valuesArray must be both null or have the same length" );
            }

            if ((nodeSourcePAttributeNames==null && nodeTargetPAttributeNames!=null)||(nodeSourcePAttributeNames!=null && nodeTargetPAttributeNames==null)){
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.createCollectionWithTreeNodes(Class collectionImplClass, Class realClass, String[] pkNames, Object pInstance, String pAttributeName, String path, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, String[] pAttributeNames,Object[] valuesArray): parameters nodeSourcePAttributeNames and nodeTargetPAttributeNames must be both null or both not null" );
            }
            if (nodeSourcePAttributeNames!=null /*nodeTargetPAttributeNames != null surely*/ && nodeSourcePAttributeNames.length!=nodeTargetPAttributeNames.length){
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.createCollectionWithTreeNodes(Class collectionImplClass, Class realClass, String[] pkNames, Object pInstance, String pAttributeName, String path,String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, String[] pAttributeNames,Object[] valuesArray): parameters nodeSourcePAttributeNames and nodeTargetPAttributeNames must be both null or have the same length" );
            }

            if (pInstance == null) return null;

            if (path == null ) {
                path="";
            }
            if (pkNames==null) {
                pkNames = getPkNames(realClass,"");
            }

            Collection  collectionWithTreeNodes = (Collection) ConstructorUtils.invokeConstructor(collectionImplClass,null,null) ;
            addToCollectionTreePath(collectionWithTreeNodes,  realClass, pkNames, pInstance, null,  path,  null, null, null, nodeSourcePAttributeNames, nodeTargetPAttributeNames, new Integer(0), pAttributeNames, valuesArray);


            return collectionWithTreeNodes;
        } catch (NoSuchMethodException e) {
            log.error("NoSuchMethodException caught in BaseApplicationService.createCollectionWithTreeNodes(Class collectionImplClass, Class realClass, String[] pkNames, Object pInstance, String pAttributeName, String path, Collection nodeSourcePAttributeNames,Collection nodeTargetPAttributeNames, String[] pAttributeNames,Object[] valuesArray) : " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.createCollectionWithTreeNodes(Class collectionImplClass, Class realClass, String[] pkNames, Object pInstance, String pAttributeName, String path, Collection nodeSourcePAttributeNames,Collection nodeTargetPAttributeNames, String[] pAttributeNames,Object[] valuesArray) " + e.toString(),e);
        } catch (IllegalAccessException e) {
            log.error("IllegalAccessException caught in BaseApplicationService.createCollectionWithTreeNodes(Class collectionImplClass, Class realClass, String[] pkNames, Object pInstance, String pAttributeName, String path, Collection nodeSourcePAttributeNames,Collection nodeTargetPAttributeNames, String[] pAttributeNames,Object[] valuesArray) : " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.createCollectionWithTreeNodes(Class collectionImplClass, Class realClass, String[] pkNames, Object pInstance, String pAttributeName, String path, Collection nodeSourcePAttributeNames,Collection nodeTargetPAttributeNames, String[] pAttributeNames,Object[] valuesArray) " + e.toString(),e);
        } catch (InvocationTargetException e) {
            log.error("InvocationTargetException caught in BaseApplicationService.createCollectionWithTreeNodes(Class collectionImplClass, Class realClass, String[] pkNames, Object pInstance, String pAttributeName, String path, Collection nodeSourcePAttributeNames,Collection nodeTargetPAttributeNames, String[] pAttributeNames,Object[] valuesArray) : " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.createCollectionWithTreeNodes(Class collectionImplClass, Class realClass, String[] pkNames, Object pInstance, String pAttributeName, String path, Collection nodeSourcePAttributeNames,Collection nodeTargetPAttributeNames, String[] pAttributeNames,Object[] valuesArray) " + e.toString(),e);
        } catch (InstantiationException e) {
            log.error("InstantiationException caught in BaseApplicationService.createCollectionWithTreeNodes(Class collectionImplClass, Class realClass, String[] pkNames, Object pInstance, String pAttributeName, String path, Collection nodeSourcePAttributeNames,Collection nodeTargetPAttributeNames, String[] pAttributeNames,Object[] valuesArray) : " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.createCollectionWithTreeNodes(Class collectionImplClass, Class realClass, String[] pkNames, Object pInstance, String pAttributeName, String path, Collection nodeSourcePAttributeNames,Collection nodeTargetPAttributeNames, String[] pAttributeNames,Object[] valuesArray) " + e.toString(),e);
        }
    }





    /**
     * This is a recursive method that creates a new instance of <code>collectionItemRealClass</code> for each path of the tree from his root to each leaf, and add it to <code>collection</code>.</br>
     * This method do a depth left visit of the tree, the generic node is <code>treeNode</code>, and the first attribute of <code>path</code> (<code>path</code> is a dot separated
     * list of attributes) is an attribute of <code>treeNode</code> that can be a value object (in such case <code>treeNode</code> has just this child) or a collection of value objects, that are all his children.</br>
     * For each path from the root to the leaves, during the recursion, this method builds arrays that represent name of attributes of <code>collectionItemRealClass</code> and  the correspondent values
     * that will be used to set such attributes of the created instance of <code>collectionItemRealClass</code>.</br>
     * The arrays are built in this way: at each recursion (each node) is created a new array that holds all the elements of the correspondent array of his parent , more the specific elements of the node.
     * Three arrays will be built: one holding the primary key values of the instance of <code>collectionItemRealClass</code> to create,
     * one holding the attribute names we want to set of the instance of  <code>collectionItemRealClass</code>, and the last holding the values to use to set such attributes.</br>
     * As we saw, each node on the walk from the root to a leaf add elements to such arrays. When the leaf is reached a new instance of <code>collectionItemRealClass</code> is created,
     * his attributes whose names are in the input parameter <code>pkNames</code> are set with the elements of the built array of primary key values,
     * and the attributes names specified by the elements of the built array of the attributes names will be set
     * with the correspondent elements of the built arrays of values. Moreover the attributes of the created instance of <code>collectionItemRealClass</code> specified by the input parameter
     * <code>pAttributeNames</code> will be set with the correspondent index values of the input parameter <code>valuesArray</code>.</br>
     * Let's see now how the three arrays we talked above are built.</br>
     * </br>
     * The array of the primary key values is built adding to it the primary key values of the current node discarding the inverse foreign keys to his parent, if the current node belongs to a collection
     * of the parent (the first attribute of <code>path</code> of the parent is a collection), and discarding the foreign key to his child, if the link to his child (the first attribute of <code>path</code>) is an attribute holding a value object and not a collection.</br>
     * The array of attributes names is built using the input parameter  <code>nodeTargetPAttributeNames</code>, that is an array of arrays. For a node of depth <code>i</code> (considering the root of depth 0) the elements of the
     * array  <code>nodeTargetPAttributeNames[depth]</code> will be added to the array of the attributes names, if <code>nodeTargetPAttributeNames[depth]</code> is not null. </br>
     * The array of the values to use to set the attributes whose names are specified by the above array of attributes names, is built using the input parameter  <code>nodeSourcePAttributeNames</code>.</br>
     * For a node of depth <code>i</code> (considering the root of depth 0) will be built an array with the values of the attributes of the current node whose names are specified in <code>nodeSourcePAttributeNames[depth]</code>
     * if <code>nodeSourcePAttributeNames[depth]</code> is not null. Than the elements of such built array will be added to the array of values (note that we are talking about the recursively built array and not about the
     * input parameter <code>valuesArray</code>).</br>
     * If a path from a root do not reach the last attribute of <code>path</code>, won't be created the correspondent instance of <code>collectionItemRealClass</code>.</br>
     * </br>
     * The input parameter <code>nodeSourcePAttributeNames</code> and <code>nodeTargetPAttributeNames</code> are both null or both not null otherwise an ApplicationServiceException is thrown.</br>
     * If they are not null must have the same length, that must be the number of token of <code>path</code> more 1 otherwise an ApplicationServiceException is thrown.</br>
     * For each level (depth) of the tree, <code>nodeSourcePAttributeNames[depth]</code> and <code>nodeTargetPAttributeNames[depth]</code> must be bot null or both not null, and
     * if not null must have the same length otherwise an ApplicationServiceException is thrown.</br>
     * When the method reaches a leaf, the built array of primary key values must have reached the same length of <code>pkNames</code> otherwise an ApplicationServiceException is thrown.</br>
     * <code>pAttributeNames</code> and <code>valuesArray</code> have to be both null or both not null, and if they are not null must have the same length otherwise an ApplicationServiceException will be thrown..</br>
     * If one of <code>path</code>, <code>collection</code>, <code>collectionItemRealClass</code>, <code>pkNames</code>  is null, an ApplicationServiceException is thrown.</br>
     *
     * @param collection Collection where the new instances of <code>collectionItemRealClass</code> have to be added to. It can't be null.
     * @param collectionItemRealClass Class of the instances to create and add to <code>collection</code> .It can't be null.
     * @param pkNames arrays holding the attribute names of <code>collectionItemRealClass</code> that will be set with the built array of primary key values. It should be the array of primary key fields of <code>collectionItemRealClass</code>. It can't be null.
     * @param treeNode current node. If null the method return.
     * @param inverseForeignKeyFields attributes names of the current node that are inverse foreign key to his parent, if the current node (<code>treeNode</code>) belong to a collection of the parent, null otherwise.
     * @param path dot separated list of attributes that specify a sub tree from <code>treeNode</code>  .It can't be null.
     * @param partialPkValues array of primary key values from the root of the tree to the current node (<code>treeNode</code>)
     * @param partialSourcePAttributeValues partial array of values built from the root of the tree to the current node (<code>treeNode</code>)
     * @param partialTargetPAttributeNames partial array of attributes names from the root of the tree to the current node (<code>treeNode</code>)
     * @param nodeSourcePAttributeNames array of arrays of attributes names. For a node of a depth, <code>nodeSourcePAttributeNames[depth]</code> is an array holding the attributes names of the node
     *                                  which values have to be added to <code>partialSourcePAttributeValues</code>
     * @param nodeTargetPAttributeNames array of arrays of attributes names. For a node of a depth, <code>nodeTargetPAttributeNames[depth]</code> elements
     *                                   have to be added to <code>partialTargetPAttributeNames</code>
     * @param depth  depth  of  he current node (<code>treeNode</code>) in the tree.
     * @param pAttributeNames names of <code>collectionItemRealClass</code> attributes to populate with values in <code>valuesArray</code>
     * @param valuesArray values to use to populate <code>collectionItemRealClass</code> attributes in <code>pAttributeNames</code>.
     * @throws it.aco.mandragora.exception.ApplicationServiceException-
     *  If <code>path</code> is null.</br>
     *  If <code>collection</code> is null.</br>
     *  If <code>collectionItemRealClass</code> is null.</br>
     *  If <code>pkNames</code> is null.</br>
     *  If <code>depth</code> is null.</br>
     *  If <code>pAttributeNames</code>  and <code>valuesArray</code> are not both  null or both not null.</br>
     *  If <code>pAttributeNames</code> and <code>valuesArray</code> are not null and don't have the same length.</br>
     *  If <code>nodeSourcePAttributeNames</code>  and <code>nodeTargetPAttributeNames</code> are not both  null or both not null.</br>
     *  If <code>nodeSourcePAttributeNames</code>  and <code>nodeTargetPAttributeNames</code> are not  null and <code>nodeSourcePAttributeNames[depth]</code>  and <code>nodeTargetPAttributeNames</code>[depth] are not both  null or both not null.</br>
     *  If <code>nodeSourcePAttributeNames[depth]<code> and <code>nodeTargetPAttributeNames[depth]<code> don't have the same length.</br>
     */
    private void addToCollectionTreePath(Collection collection, Class collectionItemRealClass, String[] pkNames, Object treeNode, String[] inverseForeignKeyFields,String path, Object[] partialPkValues, Object[] partialSourcePAttributeValues, String[] partialTargetPAttributeNames, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[] pAttributeNames,Object[] valuesArray)throws ApplicationServiceException{
        try{
            if (path == null) throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addToCollectionTreePath(Collection collection, Class collectionItemRealClass, String[] pkNames,Object treeNode, String[] inverseForeignKeyFields,String path, Object[] partialPkValues, Object[] partialSourcePAttributeValues, String[] partialTargetPAttributeNames, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[] pAttributeNames,Object[] valuesArray) : path can't be null");
            if (collection == null) throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addToCollectionTreePath(Collection collection, Class collectionItemRealClass, String[] pkNames,Object treeNode, String[] inverseForeignKeyFields,String path, Object[] partialPkValues, Object[] partialSourcePAttributeValues, String[] partialTargetPAttributeNames,String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[] pAttributeNames,Object[] valuesArray) : collection can't be null");
            if (collectionItemRealClass == null) throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addToCollectionTreePath(Collection collection, Class collectionItemRealClass, String[] pkNames,Object treeNode, String[] inverseForeignKeyFields,String path, Object[] partialPkValues, Object[] partialSourcePAttributeValues, String[] partialTargetPAttributeNames, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[] pAttributeNames,Object[] valuesArray) : collectionItemRealClass can't be null");
            if (pkNames == null) throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addToCollectionTreePath(Collection collection, Class collectionItemRealClass, String[] pkNames,Object treeNode, String[] inverseForeignKeyFields,String path, Object[] partialPkValues, Object[] partialSourcePAttributeValues, String[] partialTargetPAttributeNames, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[] pAttributeNames,Object[] valuesArray) : pkNames can't be null");
            if (depth == null) throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addToCollectionTreePath(Collection collection, Class collectionItemRealClass, String[] pkNames,Object treeNode, String[] inverseForeignKeyFields,String path, Object[] partialPkValues, Object[] partialSourcePAttributeValues, String[] partialTargetPAttributeNames, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[] pAttributeNames,Object[] valuesArray) : depth can't be null");

            if ((pAttributeNames==null && valuesArray!=null)||(pAttributeNames!=null && valuesArray==null)){
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addToCollectionTreePath(Collection collection, Class collectionItemRealClass, String[] pkNames,Object treeNode, String[] inverseForeignKeyFields,String path, Object[] partialPkValues, Object[] partialSourcePAttributeValues, String[] partialTargetPAttributeNames, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[] pAttributeNames,Object[] valuesArray): parameters pAttributeNames and valuesArray must be both null or both not null" );
            }
            if (pAttributeNames!=null /*valuesArray != null surely*/ && pAttributeNames.length!=valuesArray.length){
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addToCollectionTreePath(Collection collection, Class collectionItemRealClass, String[] pkNames,Object treeNode, String[] inverseForeignKeyFields,String path, Object[] partialPkValues, Object[] partialSourcePAttributeValues, String[] partialTargetPAttributeNames, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[] pAttributeNames,Object[] valuesArray): parameters pAttributeNames and valuesArray must be both null or have the same length" );
            }

            if ((nodeSourcePAttributeNames==null && nodeTargetPAttributeNames!=null)||(nodeSourcePAttributeNames!=null && nodeTargetPAttributeNames==null)){
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addToCollectionTreePath(Collection collection, Class collectionItemRealClass, String[] pkNames,Object treeNode, String[] inverseForeignKeyFields,String path, Object[] partialPkValues, Object[] partialSourcePAttributeValues, String[] partialTargetPAttributeNames, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[] pAttributeNames,Object[] valuesArray): parameters nodeSourcePAttributeNames and nodeTargetPAttributeNames must be both null or both not null" );
            }

            if(nodeSourcePAttributeNames!=null){ /*nodeTargetPAttributeNames != null surely*/
                if((nodeSourcePAttributeNames[depth.intValue()]==null && nodeTargetPAttributeNames[depth.intValue()]!=null)||(nodeSourcePAttributeNames[depth.intValue()]!=null && nodeTargetPAttributeNames[depth.intValue()]==null)){
                    throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addToCollectionTreePath(Collection collection, Class collectionItemRealClass, String[] pkNames,Object treeNode, String[] inverseForeignKeyFields,String path, Object[] partialPkValues, Object[] partialSourcePAttributeValues, String[] partialTargetPAttributeNames, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[] pAttributeNames,Object[] valuesArray): parameters nodeSourcePAttributeNames["+depth.intValue()+"] and nodeTargetPAttributeNames["+depth.intValue()+"] must be both null or both not null" );
                }
                if(nodeSourcePAttributeNames[depth.intValue()]!=null){ /*nodeTargetPAttributeNames[depth.intValue()] != null surely*/
                    if (nodeSourcePAttributeNames[depth.intValue()].length!=nodeTargetPAttributeNames[depth.intValue()].length){
                        throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addToCollectionTreePath(Collection collection, Class collectionItemRealClass, String[] pkNames,Object treeNode, String[] inverseForeignKeyFields,String path, Object[] partialPkValues, Object[] partialSourcePAttributeValues, String[] partialTargetPAttributeNames, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[] pAttributeNames,Object[] valuesArray): if nodeSourcePAttributeNames["+depth.intValue()+"] and nodeTargetPAttributeNames["+depth.intValue()+"] are not null, must have the same length" );
                    }
                }
            }

            if (treeNode!=null) { // if we get a null node path didn't get the bottom, so no item is added to the collection
                                        // this condition should be always true, as it is checked before calling the recursion

                if (nodeSourcePAttributeNames!=null && nodeSourcePAttributeNames[depth.intValue()]!=null) { /*nodeTargetPAttributeNames != null and nodeTargetPAttributeNames[depth.intValue()]!=null surely*/
                    partialSourcePAttributeValues = Utils.arrayUnion(partialSourcePAttributeValues,BeanCollectionUtils.getAttributes(treeNode,nodeSourcePAttributeNames[depth.intValue()]));
                    partialTargetPAttributeNames = (String[]) Utils.arrayUnion(partialTargetPAttributeNames,nodeTargetPAttributeNames[depth.intValue()]);
                }

                DAO dao = getDAO();
                if(path.trim().equals("")){// treeNode is a leaf

                    Object collectionElement = ConstructorUtils.invokeConstructor(collectionItemRealClass,null,null);
                    if (partialTargetPAttributeNames!=null) BeanCollectionUtils.setAttributes(collectionElement, partialTargetPAttributeNames, partialSourcePAttributeValues);
                    if (pAttributeNames!=null) BeanCollectionUtils.setAttributes(collectionElement, pAttributeNames, valuesArray);

                    //String[] treeNodePkNotInverseForeignKeyFields =(String[]) Utils.arraySubtract(dao.getPkNames(treeNode.getClass()),inverseForeignKeyFields);// deleted by Alessandro on 03-dec-2008
                    String[] treeNodePkNotInverseForeignKeyFields =(String[]) Utils.arraySubtract(dao.getPkNames(getEntityClass(treeNode)),inverseForeignKeyFields,String.class); // added by Alessandro on 03-dec-2008
                    Object[] treeNodePkNotInverseForeignKeyValues = BeanCollectionUtils.getAttributes(treeNode,treeNodePkNotInverseForeignKeyFields);
                    partialPkValues = Utils.arrayUnion(partialPkValues,treeNodePkNotInverseForeignKeyValues);

                    BeanCollectionUtils.setAttributes(collectionElement, pkNames, partialPkValues);
                    collection.add(collectionElement);

                }else{ // treeNode is not a leaf
                    PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();
                    String[] firstAttributeNameAndRemainingPath = Utils.getFirstAttributeNameAndRemainingPath(path);
                    Object referenceValue = propertyUtilsBean.getProperty(treeNode, firstAttributeNameAndRemainingPath[0]);
                    //if (referenceValue == null) return;
                    if (referenceValue != null) {
                        log.debug("addToCollectionTreePath : referenceValue = "+referenceValue);
                        if (Collection.class.isInstance(referenceValue)){
                            log.debug("addToCollectionTreePath : referenceValue is a collection ");
                            //String[] treeNodePkNotInverseForeignKeyFields = (String[]) Utils.arraySubtract(dao.getPkNames(treeNode.getClass()),inverseForeignKeyFields);// deleted by Alessandro on 03-dec-2008
                            String[] treeNodePkNotInverseForeignKeyFields = (String[]) Utils.arraySubtract(dao.getPkNames(getEntityClass(treeNode)),inverseForeignKeyFields,String.class);// added by Alessandro on 03-dec-2008
                            Object[] treeNodePkNotInverseForeignKeyValues = BeanCollectionUtils.getAttributes(treeNode,treeNodePkNotInverseForeignKeyFields);
                            partialPkValues = Utils.arrayUnion(partialPkValues,treeNodePkNotInverseForeignKeyValues);

                            // start added by Alessandro on 3-dec-2008
                            String[]  nextInverseForeignKeyFields = null;
                            Collection newInverseForeignKeyFields = dao.getInverseForeignKeyFields(getEntityClass(treeNode),firstAttributeNameAndRemainingPath[0]);
                            if(newInverseForeignKeyFields!=null) {
                                nextInverseForeignKeyFields = (String[]) newInverseForeignKeyFields.toArray(new String[newInverseForeignKeyFields.size()]);
                            }
                            // end added by Alessandro on 3-dec-2008


                            //String[]  nextInverseForeignKeyFields = (String[]) dao.getInverseForeignKeyFields(treeNode.getClass(),firstAttributeNameAndRemainingPath[0]).toArray(inverseForeignKeyFields);// deleted by Alessandro on 3-dec-2008
                            Iterator referenceValueIterator  = ((Collection)referenceValue).iterator();
                            while (referenceValueIterator.hasNext()){
                                addToCollectionTreePath(collection, collectionItemRealClass, pkNames,referenceValueIterator.next(), nextInverseForeignKeyFields,firstAttributeNameAndRemainingPath[1], partialPkValues, partialSourcePAttributeValues, partialTargetPAttributeNames,  nodeSourcePAttributeNames,  nodeTargetPAttributeNames, new Integer(depth.intValue()+1),pAttributeNames, valuesArray);
                            }
                        } else{
                            String[] treeNodeAttributesNamesToAddToPartialPkValues =  getPkNotForeignKeyFields(getEntityClass(treeNode), firstAttributeNameAndRemainingPath[0]);
                            if (inverseForeignKeyFields!=null && inverseForeignKeyFields.length!=0){
                                //treeNodeAttributesNamesToAddToPartialPkValues = (String[]) Utils.arraySubtract(treeNodeAttributesNamesToAddToPartialPkValues,inverseForeignKeyFields); // deleted by Alessandro on 03-dec-2008
                                treeNodeAttributesNamesToAddToPartialPkValues = (String[]) Utils.arraySubtract(treeNodeAttributesNamesToAddToPartialPkValues,inverseForeignKeyFields,String.class); // added by Alessandro on 03-dec-2008
                            }
                            partialPkValues = Utils.arrayUnion(partialPkValues,BeanCollectionUtils.getAttributes(treeNode,treeNodeAttributesNamesToAddToPartialPkValues));
                            addToCollectionTreePath(collection, collectionItemRealClass,  pkNames,referenceValue, null,firstAttributeNameAndRemainingPath[1], partialPkValues, partialSourcePAttributeValues, partialTargetPAttributeNames,  nodeSourcePAttributeNames,  nodeTargetPAttributeNames, new Integer(depth.intValue()+1),pAttributeNames, valuesArray);
                        }
                    }
                }
            }
        } catch (DataAccessException e) {
            log.error("DataAccessException caught in BaseApplicationService.addToCollectionTreePath(Collection collection, Class realClas, String[] pkNamess,Object treeNode, String[] inverseForeignKeyFields,String path, Object[] partialPkValues, Object[] partialSourcePAttributeValues, String[] partialTargetPAttributeNames,String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[] pAttributeNames,Object[] valuesArray) " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addToCollectionTreePath(Collection collection, Class collectionItemRealClass, String[] pkNames,Object treeNode, String[] inverseForeignKeyFields,String path, Object[] partialPkValues, Object[] partialSourcePAttributeValues, String[] partialTargetPAttributeNames,String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[] pAttributeNames,Object[] valuesArray)" + e.toString(),e);
        } catch (NoSuchMethodException e) {
            log.error("NoSuchMethodException caught in BaseApplicationService.addToCollectionTreePath(Collection collection, Class collectionItemRealClass, String[] pkNames,Object treeNode, String[] inverseForeignKeyFields,String path, Object[] partialPkValues, Object[] partialSourcePAttributeValues, String[] partialTargetPAttributeNames, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, int depth, String[] pAttributeNames,Object[] valuesArray) " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addToCollectionTreePath(Collection collection, Class collectionItemRealClass, String[] pkNames,Object treeNode, String[] inverseForeignKeyFields,String path, Object[] partialPkValues, Object[] partialSourcePAttributeValues, String[] partialTargetPAttributeNames, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[] pAttributeNames,Object[] valuesArray)" + e.toString(),e);
        } catch (IllegalAccessException e) {
            log.error("IllegalAccessException caught in BaseApplicationService.addToCollectionTreePath(Collection collection, Class collectionItemRealClass, String[] pkNames,Object treeNode, String[] inverseForeignKeyFields,String path, Object[] partialPkValues, Object[] partialSourcePAttributeValues, String[] partialTargetPAttributeNames, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[] pAttributeNames,Object[] valuesArray) " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addToCollectionTreePath(Collection collection, Class collectionItemRealClass, String[] pkNames,Object treeNode, String[] inverseForeignKeyFields,String path, Object[] partialPkValues, Object[] partialSourcePAttributeValues, String[] partialTargetPAttributeNames,String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[] pAttributeNames,Object[] valuesArray)" + e.toString(),e);
        } catch (InvocationTargetException e) {
            log.error("InvocationTargetException caught in BaseApplicationService.addToCollectionTreePath(Collection collection, Class collectionItemRealClass, String[] pkNames,Object treeNode, String[] inverseForeignKeyFields,String path, Object[] partialPkValues, Object[] partialSourcePAttributeValues, String[] partialTargetPAttributeNames, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[] pAttributeNames,Object[] valuesArray) " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addToCollectionTreePath(Collection collection, Class collectionItemRealClass, String[] pkNames,Object treeNode, String[] inverseForeignKeyFields,String path, Object[] partialPkValues, Object[] partialSourcePAttributeValues, String[] partialTargetPAttributeNames, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[] pAttributeNames,Object[] valuesArray)" + e.toString(),e);
        } catch (InstantiationException e) {
            log.error("InstantiationException caught in BaseApplicationService.addToCollectionTreePath(Collection collection, Class collectionItemRealClass, String[] pkNames,Object treeNode, String[] inverseForeignKeyFields,String path, Object[] partialPkValues, Object[] partialSourcePAttributeValues, String[] partialTargetPAttributeNames,String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[] pAttributeNames,Object[] valuesArray) " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addToCollectionTreePath(Collection collection, Class collectionItemRealClass, String[] pkNames,Object treeNode, String[] inverseForeignKeyFields,String path, Object[] partialPkValues, Object[] partialSourcePAttributeValues, String[] partialTargetPAttributeNames,String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[] pAttributeNames,Object[] valuesArray)" + e.toString(),e);
        } catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.addToCollectionTreePath(Collection collection, Class collectionItemRealClass, String[] pkNames,Object treeNode, String[] inverseForeignKeyFields,String path, Object[] partialPkValues, Object[] partialSourcePAttributeValues, String[] partialTargetPAttributeNames, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[] pAttributeNames,Object[] valuesArray) " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addToCollectionTreePath(Collection collection, Class collectionItemRealClass, String[] pkNames,Object treeNode, String[] inverseForeignKeyFields,String path, Object[] partialPkValues, Object[] partialSourcePAttributeValues, String[] partialTargetPAttributeNames, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[] pAttributeNames,Object[] valuesArray)" + e.toString(),e);
        }
    }



    public void createValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray) throws ApplicationServiceException{
        try{
            createValueObjectsTreeWithCollection( valueObjectsCollection, pInstance, path, groupedPkNames, nodePAttributeNames, nodeValuesArray, new Integer(0));
        }catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.createValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.createValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray)" + e.toString(),e);
        }
    }





    /**
     * This is a recursive method that at each recursion creates a value object that is a node of a tree of value objects , populating the primary key attributes of the created node
     * with attributes values of items of the collection input parameter <code>valueObjectsCollection</code>.</br>
     * The tree is built with a depth left visit, where the generic node is <code>pInstance</code>, and the first attribute of <code>path</code> (<code>path</code> is a dot separated
     * list of attributes) is an attribute of <code>pInstance</code> that can be a value object (in this case <code>pInstance</code> has just such child) or a collection of value objects,
     * that are all the children of <code>pInstance</code>.</br>
     * In each recursion will be created a child of <code>pInstance</code>.</br>
     * The children of <code>pInstance</code> will be as many as are the distinct sets of values of the attributes, whose names are in <code>groupedPkNames[depth]</code>, of the items of <code>valueObjectsCollection</code>.</br>
     * For each one of such distinct sets will be created a new instance of the  class of the children of <code>pInstance</code> (class that must be specified in the mapping file, i.e repository.xml in Ojb)
     * and its primary key fields will be set with the set of the values that is being processed; moreover the attributes of the new instance named as in <code>nodePAttributeNames[depth]</code> will be set
     * with the corresponding values of  <code>nodeValuesArray[depth]</code>.</br>
     * The length of <code>groupedPkNames[depth]</code> must be the same of the number of the key fields of the node class of the level  <code>depth+1</code> where the root is considered to be
     * of level 0, otherwise an ApplicationServiceException is thrown </br>
     * </br>.
     * If the first attribute of path of <code>pInstance</code>, let's call it <code>firstAttribute</code>, is specified to be a collection in the mapping file (i.e repository.xml in Ojb),
     * such collection will be created,  all the created instances children of <code>pInstance</code> will be added to it and the first attribute of <code>pInstance</code> will be set with this collection, while,
     * if the first attribute of path of <code>pInstance</code>, firstAttribute, is specified to be a value object in the mapping file, there must be only one distinct set of values of the attributes
     * <code>groupedPkNames[depth]</code> in  <code>valueObjectsCollection</code>, otherwise an ApplicationServiceException is thrown, so only one instance of the class of level <code>depth+1</code>
     * will be created, and the first attribute of <code>pInstance</code> will be set with this instance  .</br>
     * If the first attribute of path of <code>pInstance</code> is a collection all the inverse foreign key of the elements of  the collection referring to <code>pInstance</code>
     * will be set with the key values of  <code>pInstance</code>, while if the first attribute of path of <code>pInstance</code> is a value object,
     * the foreign keys of  <code>pInstance</code> referring to such value objects will set with the key values of the value object.</br>
     * In both case this method will be recursively called for each one of the created children of <code>pInstance</code>, passing the child as <code>pInstance</code>, the <code>path</code> with
     * the first attribute excluded, and <code>depth+1</code>; as <code>valueObjectsCollection</code> will be passed the same <code>valueObjectsCollection</code> filtered
     * so to have just the elements that have the attributes groupedPkNames[depth] equals to the key values of the child being passed as <code>pInstance</code> .
     * The recursion will end at the end of <code>path</code> .</br>
     * </br>
     * If <code>valueObjectsCollection</code> is null or empty the method return.</br>
     * If <code>path</code> is empty string or blank characters string the method return.</br>
     * If <code>groupedPkNames</code> is null, as <code>groupedPkNames[depth]</code> will be considered the primary key fields of the class of nodes of level  <code>depth+1</code>
     * where the root is considered to be of level 0; even if groupedPkNames is not null, some <code>groupedPkNames[depth]</code> can be null, and in such case, the  same rule is applied.</br>
     * If <code>groupedPkNames</code> is not null, his length must be greater or equal than the number of tokens of <code>path</code>, otherwise an ApplicationServiceException is thrown;
     * if strictly greater, the ones left over, will be ignored.</br>
     * For each depth <code>groupedPkNames[depth]</code> must be greater or equals than the number of the key fields of the node class of the level  <code>depth+1</code> (the over ones will be ignored)
     * otherwise an ApplicationServiceException is thrown.</br>
     *
     *
     * @param valueObjectsCollection Collection of value objects used to create the tree of value objects. If null or empty the method returns.
     * @param pInstance root of the tree. It can't be null.
     * @param path dot separated list of attributes, defining the tree with <code>pInstance</code>
     * @param groupedPkNames array of arrays of attributes names that specifies how to group the <code>valueObjectsCollection</code> item attributes to constitute the primary keys of the nodes of the tree to create.</br>
     * @param nodePAttributeNames  array of arrays of attributes names of the children of <code>pInstance</code> to create, attributes to populate with values in <code>nodeValuesArray</code>
     * @param nodeValuesArray  array of arrays of values to use to populate the children of <code>pInstance</code> to create attributes in <code>nodePAttributeNames</code>.
     * @param depth depth of <code>pInstance</code>
     * @throws it.aco.mandragora.exception.ApplicationServiceException if <code>pInstance</code> or <code>path</code> are null.</br>
     *      If <code>groupedPkNames</code> is not null, and his length is less than the number of tokens of <code>path</code>.</br>
     *      If <code>groupedPkNames</code> is not null and for some depth <code>groupedPkNames[depth]</code> has length less than the number of the key fields of the node class of the level  <code>depth+1</code> where the root is considered to be of level 0.</br>
     *      If <code>nodePAttributeNames</code> and <code>nodeValuesArray</code> are not both null or both not null.</br>
     *      If <code>nodePAttributeNames</code> and <code>nodeValuesArray</code> are both not null and they don't have the same length.</br>
     *      If <code>nodePAttributeNames</code> and <code>nodeValuesArray</code> are both not null, have the same length, but the length is less than the number of tokens of <code>path</code> .</br>
     *      If <code>nodePAttributeNames</code> and <code>nodeValuesArray</code> are both not null, have the same length, that is greater or equals  than the number of tokens of <code>path</code>,
     *      but for some depth, <code>nodePAttributeNames[depth]</code> <code>nodePAttributeNames[depth]</code> are not both null and  not both not null, or if both not null, they don't have  the same length   .</br>
     */
    private void createValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, Integer depth) throws ApplicationServiceException{
        try{

            if (pInstance==null||path==null) throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.createValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, Integer depth) :pInstance can't be null " );
            //if (groupedPkNames==null) throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.createValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, int depth) :pkNames can't be null " );
            //start added by Alessandro on 04-dec-2008
            if ((nodePAttributeNames==null && nodeValuesArray!=null)||(nodePAttributeNames!=null && nodeValuesArray==null)){
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.createValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, Integer depth): parameters nodePAttributeNames and nodeValuesArray must be both null or both not null" );
            }
            if (nodePAttributeNames!=null /*nodeValuesArray != null surely*/ && nodePAttributeNames.length!=nodeValuesArray.length){
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.createValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, Integer depth): parameters nodePAttributeNames and nodeValuesArray must be both null or have the same length" );
            }
            //end added by Alessandro on 04-dec-2008
            if (valueObjectsCollection==null || valueObjectsCollection.isEmpty()) return;
            if(path.trim().equals(""))return;

            DAO dao = getDAO();
            PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();



            String[] firstAttributeNameAndRemainingPath = Utils.getFirstAttributeNameAndRemainingPath(path);

            Class nextCollectionImplClass;
            Class nextNodeClass;
            String[] nextNodePkNames;


            nextCollectionImplClass = dao.getCollectionClassFromPath(getEntityClass(pInstance),firstAttributeNameAndRemainingPath[0]);
            nextNodeClass = dao.getClassFromPath(getEntityClass(pInstance),firstAttributeNameAndRemainingPath[0]);
            nextNodePkNames=dao.getPkNames(nextNodeClass);



            String[] pkNamesToMakeDistinctCollection;
            if(groupedPkNames==null || groupedPkNames[depth.intValue()]==null){
                pkNamesToMakeDistinctCollection = nextNodePkNames;
            }else{
                pkNamesToMakeDistinctCollection = groupedPkNames[depth.intValue()];
                if(pkNamesToMakeDistinctCollection.length!=nextNodePkNames.length){
                    throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.createValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, Integer depth): in the depth ="+depth.intValue()+"the pknames[depth] has not the same lenght of the number of key fields of the value objects of depth" );
                }
            }

            Collection distinctValueObjectsCollection = Utils.selectDistinct(valueObjectsCollection,pkNamesToMakeDistinctCollection);
            if (distinctValueObjectsCollection == null || distinctValueObjectsCollection.isEmpty()) return;

            boolean firstAttributeIsCollection=false;
            if(nextCollectionImplClass!=null)firstAttributeIsCollection=true;
            if(!firstAttributeIsCollection && distinctValueObjectsCollection.size()>1)throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.createValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, Integer depth): next node is a value object but in the value objects collection there is more than one correspondig element" );
            Collection nextCollection = null;
            if(firstAttributeIsCollection) nextCollection = (Collection) ConstructorUtils.invokeConstructor(nextCollectionImplClass,null,null);
            Iterator distinctValueObjectsCollectionIterator = distinctValueObjectsCollection.iterator();

            Object pAttributeName = null;

            while (distinctValueObjectsCollectionIterator.hasNext()){//if pInstance.firstAttributeNameAndRemainingPath[0] is a
                                                                     // value object, surely there will be just one iteration
                                                                     // as distinctValueObjectsCollection.size()=1
                Object distinctValueObjectsCollectionItem = distinctValueObjectsCollectionIterator.next();

                Object[] distinctValueObjectsCollectionItemPkValues = BeanCollectionUtils.getAttributes(distinctValueObjectsCollectionItem,pkNamesToMakeDistinctCollection);

                Object pInstanceChild = ConstructorUtils.invokeConstructor(nextNodeClass,null,null);
                BeanCollectionUtils.setAttributes(pInstanceChild,nextNodePkNames,distinctValueObjectsCollectionItemPkValues);
                // start added by Alessandro on 04-dec-2008
                if (nodePAttributeNames!=null /*nodeValuesArray != null surely*/ ){
                     BeanCollectionUtils.setAttributes(pInstanceChild,nodePAttributeNames[depth.intValue()],nodeValuesArray[depth.intValue()]);
                }
                // end added by Alessandro on 04-dec-2008
                //BeanCollectionUtils.setAttributes(pInstanceChild,nodePAttributeNames[depth.intValue()],nodeValuesArray[depth.intValue()]);   // deleted by Alessandro on 04-dec-2008

                // forSubTreeValueObjectsCollection is impossible that is null or empty beacuse distinctValueObjectsCollection is not null and not empty
                if (firstAttributeIsCollection){
                    nextCollection.add(pInstanceChild);

                }else { // there is the only one iteration
                    //if (forSubTreeValueObjectsCollection.size()>1) throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.createValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, int depth): next node is a value object but in the value objects collection there is more than one correspondig element" );
                    propertyUtilsBean.setProperty(pInstance,firstAttributeNameAndRemainingPath[0],pInstanceChild);

                    setForeignKeyFields(pInstance,firstAttributeNameAndRemainingPath[0]);

                }
                Collection forSubTreeValueObjectsCollection = Utils.selectWhereFieldsEqualsTo(valueObjectsCollection,pkNamesToMakeDistinctCollection,distinctValueObjectsCollectionItemPkValues);

                createValueObjectsTreeWithCollection( forSubTreeValueObjectsCollection, pInstanceChild,firstAttributeNameAndRemainingPath[1],  groupedPkNames,  nodePAttributeNames, nodeValuesArray,  new Integer (depth.intValue()+1));
            }

            if (firstAttributeIsCollection){
                propertyUtilsBean.setProperty(pInstance,firstAttributeNameAndRemainingPath[0],nextCollection);

                //setInverseForeignKeyFields(pInstance,firstAttributeNameAndRemainingPath[0]);
                dao.setInverseForeignKeyFields(pInstance,firstAttributeNameAndRemainingPath[0]);
            }

        }catch (ServiceLocatorException e) {
            log.error("ServiceLocatorException caught in BaseApplicationService.createValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, Integer depth)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.createValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, Integer depth)" + e.toString(),e);
        }catch (DataAccessException e) {
            log.error("DataAccessException caught in BaseApplicationService.createValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, Integer depth)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.createValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, Integer depth)" + e.toString(),e);
        }catch (IllegalAccessException e) {
            log.error("IllegalAccessException caught in BaseApplicationService.createValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, Integer depth)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.createValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, Integer depth)" + e.toString(),e);
        }catch (NoSuchMethodException e) {
            log.error("NoSuchMethodException caught in BaseApplicationService.createValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, Integer depth)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.createValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, Integer depth)" + e.toString(),e);
        }catch (InstantiationException e) {
            log.error("InstantiationException caught in BaseApplicationService.createValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, Integer depth)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.createValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, Integer depth)" + e.toString(),e);
        }catch (InvocationTargetException e) {
            log.error("InvocationTargetException caught in BaseApplicationService.createValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, Integer depth)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.createValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, Integer depth)" + e.toString(),e);
        }catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.createValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, Integer depth)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.createValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, Integer depth)" + e.toString(),e);
        }
    }

    public void addToValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray) throws ApplicationServiceException{
        try{
            //addToValueObjectsTreeWithCollection( valueObjectsCollection, pInstance, path, groupedPkNames, nodePAttributeNames, nodeValuesArray, 0);
            addToValueObjectsTreeWithCollection( valueObjectsCollection, pInstance, path, groupedPkNames, nodePAttributeNames, nodeValuesArray, new Integer(0));
        }catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.addToValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addToValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray)" + e.toString(),e);
        }
    }





    /**
     *
     * This is a recursive method that at each recursion creates a value object node and add it to a tree of value objects if not yet existing in it, populating the primary key attributes of the created node
     * with attributes values of items of the collection input parameter <code>valueObjectsCollection</code>.</br>
     * The new nodes are added to the tree visiting it with a depth-first left search, where the generic node is <code>pInstance</code>, and the first attribute of <code>path</code> (<code>path</code> is a dot separated
     * list of attributes) is an attribute of <code>pInstance</code> that can be a value object (in this case <code>pInstance</code> has just such child) or a collection of value objects,
     * that are all the children of <code>pInstance</code>.</br>
     * The depth of the node <code>pInstance</code> is specified by the input parameter <code>depth</code>.</br>
     * In a recursion for a node <code>pInstance</code> of a <code>depth</code>, this method gets all the distinct sets of values of the attributes, whose names are in <code>groupedPkNames[depth]</code>, of the items of <code>valueObjectsCollection</code>.</br>
     * If the first attribute of <code>path</code> specifies the name of an attribute of  <code>pInstance</code> that is a value objects, there must be just
     * one distinct set of values, otherwise an ApplicationServiceException is thrown; if such attribute of <code>pInstance</code> is null or the primary keys values
     * of the value object represented by such attribute are not equals to the distinct set of values, the attribute of  <code>pInstance</code> is replaced
     * by a new instance of the class of the attribute that have as primary key values the set of distinct values. Moreover for such new instance the attributes named as in <code>nodePAttributeNames[depth]</code> will be set
     * with the corresponding values of  <code>nodeValuesArray[depth]</code> (of course if they are not null); in both cases the foreign key fields
     * of <code>pInstance</code> referring to the value object child, are set with the primary key values of the same child. (It could be that even if the right
     * child was already existing, the foreign key fields to it were not properly set). </br>
     * If the first attribute of <code>path</code> specifies the name of an attribute of  <code>pInstance</code> that is a collection, if such collection is null
     * a new empty one is created (using the implementation specified in the mapping file, i.e repository.xml for Ojb), and the attribute of  <code>pInstance</code>
     * will be set to it.</br>
     * For each one of the distinct sets of values of the attributes, whose names are in <code>groupedPkNames[depth]</code>, of the items of <code>valueObjectsCollection</code>
     * if in the collection of the children of <code>pInstance</code> is not yet present  a value object which primary key values are  equals to the distinct set of values
     * being processed, such value object will be created (a new instance of the class of the children of <code>pInstance</code>, class that should be mapped
     * in the mapping file, i.e repository.xml for Ojb) with key primary values set to the values of the distinct set of values being processed. Moreover for such new instance the attributes named as in <code>nodePAttributeNames[depth]</code> will be set
     * with the corresponding values of  <code>nodeValuesArray[depth]</code> (of course if they are not null); then the new created instances will be added
     * to the collection of the children of <code>pInstance</code>.</br>
     * For all the children of <code>pInstance</code>, the inverse foreign key field referring to the parent <code>pInstance</code> will be set with the key values
     * of <code>pInstance</code>, this is done for the new added ones and for the already existing children, as it could be that such fields, for the already existing children,
     * were not properly set.</br>
     * For all the the children of <code>pInstance</code>, in both cases that the first attribute of <code>path</code> specifies a value object or a collection,
     * this method will be recursively called passing the child as <code>pInstance</code>, the <code>path</code> with
     * the first attribute excluded, and <code>depth+1</code>; as <code>valueObjectsCollection</code> will be passed the same <code>valueObjectsCollection</code> filtered
     * so to have just the elements that have the attributes groupedPkNames[depth] equals to the key values of the child being passed as <code>pInstance</code> .
     * The recursion will end at the end of <code>path</code>.</br>
     * </br>
     * If <code>valueObjectsCollection</code> is null or empty the method return.</br>
     * If <code>path</code> is empty string or blank characters string the method return.</br>
     * If <code>groupedPkNames</code> is null, as <code>groupedPkNames[depth]</code> will be considered the primary key fields of the class of nodes of level  <code>depth+1</code>
     * where the root is considered to be of level 0; even if groupedPkNames is not null, some <code>groupedPkNames[depth]</code> can be null, and in such case, the  same rule is applied.</br>
     * If <code>groupedPkNames</code> is not null, his length must be greater or equal than the number of tokens of <code>path</code>, otherwise an ApplicationServiceException is thrown;
     * if strictly greater, the ones left over, will be ignored.</br>
     * For each depth <code>groupedPkNames[depth]</code> must be greater or equals than the number of the key fields of the node class of the level  <code>depth+1</code> (the over ones will be ignored)
     * otherwise an ApplicationServiceException is thrown.</br>
     *
     *
     *
     * @param valueObjectsCollection  Collection of value objects used to create the value objects nodes to add to the tree. If null or empty the method returns.
     * @param pInstance root of the tree. It can't be null.
     * @param path dot separated list of attributes, defining the tree with <code>pInstance</code>
     * @param groupedPkNames array of arrays of attributes names that specifies how to group the <code>valueObjectsCollection</code> item attributes to constitute the primary keys of the nodes to add to the the tree if not yet present.</br>
     * @param nodePAttributeNames  array of arrays of attributes names of the children of <code>pInstance</code> to create and add to the tree, attributes to populate with values in <code>nodeValuesArray</code>
     * @param nodeValuesArray  array of arrays of values to use to populate the children of <code>pInstance</code> attributes in <code>nodePAttributeNames</code>.
     * @param depth depth of <code>pInstance</code>
     * @throws it.aco.mandragora.exception.ApplicationServiceException - if <code>pInstance</code> or <code>path</code> are null.</br>
     *      If <code>groupedPkNames</code> is not null, and his length is less than the number of tokens of <code>path</code>.</br>
     *      If <code>groupedPkNames</code> is not null and for some depth <code>groupedPkNames[depth]</code> has length less than the number of the key fields of the node class of the level  <code>depth+1</code> where the root is considered to be of level 0.</br>
     *      If <code>nodePAttributeNames</code> and <code>nodeValuesArray</code> are not both null or both not null.</br>
     *      If <code>nodePAttributeNames</code> and <code>nodeValuesArray</code> are both not null and they don't have the same length.</br>
     *      If <code>nodePAttributeNames</code> and <code>nodeValuesArray</code> are both not null, have the same length, but the length is less than the number of tokens of <code>path</code> .</br>
     *      If <code>nodePAttributeNames</code> and <code>nodeValuesArray</code> are both not null, have the same length, that is greater or equals  than the number of tokens of <code>path</code>,
     *      but for some depth, <code>nodePAttributeNames[depth]</code> <code>nodePAttributeNames[depth]</code> are not both null and  not both not null, or if both not null, they don't have  the same length   .</br>
     */
    private void addToValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, Integer depth) throws ApplicationServiceException{
        log.info("************Entering the BaseApplicationService.addToValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, Integer depth) ***************");
        try{

            if (pInstance==null||path==null) throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addToValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, Integer depth) :pInstance can't be null " );
            log.debug("addToValueObjectsTreeWithCollection:  valueObjectsCollection = "+valueObjectsCollection);
            log.debug("addToValueObjectsTreeWithCollection: pInstance = "+pInstance);
            if (valueObjectsCollection==null || valueObjectsCollection.isEmpty()) return;
            //start added by Alessandro on 04-dec-2008
            if ((nodePAttributeNames==null && nodeValuesArray!=null)||(nodePAttributeNames!=null && nodeValuesArray==null)){
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addToValueObjectsTreeWithCollectionRecursive(Context  context): parameters nodePAttributeNames and nodeValuesArray must be both null or both not null" );
            }
            if (nodePAttributeNames!=null /*nodeValuesArray != null surely*/ && nodePAttributeNames.length!=nodeValuesArray.length){
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addToValueObjectsTreeWithCollectionRecursive(Context  context): parameters nodePAttributeNames and nodeValuesArray must be both null or have the same length" );
            }
            //end added by Alessandro on 04-dec-2008
            if(path.trim().equals(""))return;

            DAO dao = getDAO();
            PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();

            String[] firstAttributeNameAndRemainingPath = Utils.getFirstAttributeNameAndRemainingPath(path);

            Class nextCollectionImplClass;
            Class nextNodeClass;
            String[] nextNodePkNames;

            nextCollectionImplClass = dao.getCollectionClassFromPath(getEntityClass(pInstance),firstAttributeNameAndRemainingPath[0]);
            nextNodeClass = dao.getClassFromPath(getEntityClass(pInstance),firstAttributeNameAndRemainingPath[0]);
            nextNodePkNames=dao.getPkNames(nextNodeClass);





            String[] pkNamesToMakeDistinctCollection;
            if(groupedPkNames==null || groupedPkNames[depth.intValue()]==null){
                pkNamesToMakeDistinctCollection = nextNodePkNames;
            }else{
                pkNamesToMakeDistinctCollection = groupedPkNames[depth.intValue()];
                if(pkNamesToMakeDistinctCollection.length!=nextNodePkNames.length){
                    throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addToValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, Integer depth): in the depth ="+depth.intValue()+"the pknames[depth] has not the same lenght of the number of key fields of the value objects of depth" );
                }
            }

            Collection distinctValueObjectsCollection = Utils.selectDistinct(valueObjectsCollection,pkNamesToMakeDistinctCollection);
            if (distinctValueObjectsCollection == null || distinctValueObjectsCollection.isEmpty()) return;

            boolean firstAttributeIsCollection=false;
            if(nextCollectionImplClass!=null)firstAttributeIsCollection=true;
            if(!firstAttributeIsCollection && distinctValueObjectsCollection.size()>1)throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addToValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, Integer depth): next node is a value object but in the value objects collection there is more than one correspondig element" );
            Collection nextCollection = null;
            String[] inverseForeignKeyFields = null;
            Object[] pInstancePkValues = null;

            Object pAttributeName = null;

            if(firstAttributeIsCollection) {
                nextCollection =(Collection) propertyUtilsBean.getProperty(pInstance,firstAttributeNameAndRemainingPath[0]);
                if (nextCollection == null){
                    nextCollection = (Collection) ConstructorUtils.invokeConstructor(nextCollectionImplClass,null,null);
                    propertyUtilsBean.setProperty(pInstance,firstAttributeNameAndRemainingPath[0],nextCollection);
                }
                // start added by Alessandro on 04-dec-2008
                Collection inverseForeignKeyFieldsCollection = dao.getInverseForeignKeyFields(getEntityClass(pInstance),firstAttributeNameAndRemainingPath[0]);
                if(inverseForeignKeyFieldsCollection!=null) inverseForeignKeyFields=  (String[])inverseForeignKeyFieldsCollection.toArray(new String[]{});
                // end added by Alessandro on 04-dec-2008
                //inverseForeignKeyFields=(String[]) dao.getInverseForeignKeyFields(pInstance.getClass(),firstAttributeNameAndRemainingPath[0]).toArray(new String[]{}); //deleted y Alessandro on 04-dec-2008
                pInstancePkValues=getKeyValues(pInstance,"");

            }
            Iterator distinctValueObjectsCollectionIterator = distinctValueObjectsCollection.iterator();
            while (distinctValueObjectsCollectionIterator.hasNext()){//if pInstance.firstAttributeNameAndRemainingPath[0] is a
                                                                     // value object, surely there will be just one iteration
                                                                     // as distinctValueObjectsCollection.size()=1
                Object distinctValueObjectsCollectionItem = distinctValueObjectsCollectionIterator.next();

                Object[] distinctValueObjectsCollectionItemPkValues = BeanCollectionUtils.getAttributes(distinctValueObjectsCollectionItem,pkNamesToMakeDistinctCollection);
                Object pInstanceChild;
                boolean isNewElement = false; //    added by Alessandro on 04-dec-2008
                if (firstAttributeIsCollection){
                    Collection existingPInstanceChildCollection = Utils.selectWhereFieldsEqualsTo(nextCollection,nextNodePkNames,distinctValueObjectsCollectionItemPkValues);
                    //if (!isInCollection(nextCollection,pInstanceChild,new BeanFieldComparator(nextNodePkNames)))
                    if(existingPInstanceChildCollection==null || existingPInstanceChildCollection.isEmpty()){
                        isNewElement = true;   //    added by Alessandro on 04-dec-2008
                        pInstanceChild = ConstructorUtils.invokeConstructor(nextNodeClass,null,null);
                        BeanCollectionUtils.setAttributes(pInstanceChild,nextNodePkNames,distinctValueObjectsCollectionItemPkValues);
                        // start added by Alessandro on 04-dec-2008
                        if (nodePAttributeNames!=null /*nodeValuesArray != null surely*/ ){
                             BeanCollectionUtils.setAttributes(pInstanceChild,nodePAttributeNames[depth.intValue()],nodeValuesArray[depth.intValue()]);
                        }
                        // end added by Alessandro on 04-dec-2008
                        //BeanCollectionUtils.setAttributes(pInstanceChild,nodePAttributeNames[depth.intValue()],nodeValuesArray[depth.intValue()]); // deleted by Alessandro on 04-dec-2008
                        nextCollection.add(pInstanceChild);
                    }else{
                        isNewElement = false;//    added by Alessandro on 04-dec-2008
                        pInstanceChild = existingPInstanceChildCollection.iterator().next();// if it exist more than such element in the children of pInstance, just the first one in
                    }                                                                       // the iteration will be considered.
                    if(inverseForeignKeyFields!=null && inverseForeignKeyFields.length!=0)  { // condition  by Alessandro on 04-dec-2008
                        BeanCollectionUtils.setAttributes(pInstanceChild,inverseForeignKeyFields,pInstancePkValues);//Inverse Foreign key fields are set even if pIstanceChild was already existing, preventig the case that the value object
                                                                                              // was existing in the collection, but with the Inverse Foreign key fields not set.
                    }
                }else { // there is the only one iteration
                    Object existingPInstanceChild = propertyUtilsBean.getProperty(pInstance,firstAttributeNameAndRemainingPath[0]);
                    //if (existingPInstanceChild==null){
                    if (existingPInstanceChild==null || (new BeanFieldComparator(nextNodePkNames,existingPInstanceChild.getClass())).compare(existingPInstanceChild,distinctValueObjectsCollectionItemPkValues)!=0){
                        isNewElement = true;   //    added by Alessandro on 04-dec-2008
                        pInstanceChild = ConstructorUtils.invokeConstructor(nextNodeClass,null,null);
                        BeanCollectionUtils.setAttributes(pInstanceChild,nextNodePkNames,distinctValueObjectsCollectionItemPkValues);
                        // start added by Alessandro on 04-dec-2008
                        if (nodePAttributeNames!=null /*nodeValuesArray != null surely*/ ){
                             BeanCollectionUtils.setAttributes(pInstanceChild,nodePAttributeNames[depth.intValue()],nodeValuesArray[depth.intValue()]);
                        }
                        // end added by Alessandro on 04-dec-2008
                        //BeanCollectionUtils.setAttributes(pInstanceChild,nodePAttributeNames[depth.intValue()],nodeValuesArray[depth.intValue()]);  // deleted by Alessandro on 04-dec-2008
                        propertyUtilsBean.setProperty(pInstance,firstAttributeNameAndRemainingPath[0],pInstanceChild);
                    } else {
                        isNewElement = false;//    added by Alessandro on 04-dec-2008
                        pInstanceChild = existingPInstanceChild ;
                    }

                    setForeignKeyFields(pInstance,firstAttributeNameAndRemainingPath[0]); //Foreign key fields are set even if pIstanceChild was already existing, preventig the case that the value object
                                                                                          // was existing , but not the Foreign key fields.
                }
                Collection forSubTreeValueObjectsCollection = Utils.selectWhereFieldsEqualsTo(valueObjectsCollection,pkNamesToMakeDistinctCollection,distinctValueObjectsCollectionItemPkValues);
                //start added by Alessandro on 04-dec-2008
                if(isNewElement)    {
                    createValueObjectsTreeWithCollection(forSubTreeValueObjectsCollection, pInstanceChild,firstAttributeNameAndRemainingPath[1],  groupedPkNames,  nodePAttributeNames, nodeValuesArray,  new Integer(depth.intValue()+1));
                }else {
                    addToValueObjectsTreeWithCollection(forSubTreeValueObjectsCollection, pInstanceChild,firstAttributeNameAndRemainingPath[1],  groupedPkNames,  nodePAttributeNames, nodeValuesArray,  new Integer(depth.intValue()+1));
                }
                //end added by Alessandro on 04-dec-2008
                //createValueObjectsTreeWithCollection(forSubTreeValueObjectsCollection, pInstanceChild,firstAttributeNameAndRemainingPath[1],  groupedPkNames,  nodePAttributeNames, nodeValuesArray,  new Integer(depth.intValue()+1)); //deleted by Alessandro on 04-dec-2008
            }

        }catch (ServiceLocatorException e) {
            log.error("ServiceLocatorException caught in BaseApplicationService.addToValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray,Integer depth)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addToValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray,Integer depth)" + e.toString(),e);
        } catch (DataAccessException e) {
            log.error("DataAccessException caught in BaseApplicationService.addToValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, Integer depth)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addToValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, Integer depth)" + e.toString(),e);
        }catch (NoSuchMethodException e) {
            log.error("NoSuchMethodException caught in BaseApplicationService.addToValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, int depth)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addToValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, Integer depth)" + e.toString(),e);
        } catch (IllegalAccessException e) {
            log.error("IllegalAccessException caught in BaseApplicationService.addToValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, int depth)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addToValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, Integer depth)" + e.toString(),e);
        }catch (InvocationTargetException e) {
            log.error("InvocationTargetException caught in BaseApplicationService.addToValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, int depth)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addToValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, Integer depth)" + e.toString(),e);
        }catch (InstantiationException e) {
            log.error("InstantiationException caught in BaseApplicationService.addToValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, int depth)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addToValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, Integer depth)" + e.toString(),e);
        }catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.addToValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, int depth)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addToValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, Integer depth)" + e.toString(),e);
        }
        log.info("************Done with the BaseApplicationService.addToValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, Integer depth) ***************");
    }




    public void retrieveAllNullReferencesInCollection(Collection valueObjectsCollection) throws ApplicationServiceException{
        try{

            if (valueObjectsCollection == null) return;
            DAO dao = getDAO();
            Iterator iterator = valueObjectsCollection.iterator();
            while (iterator.hasNext()){
                dao.retrieveAllNullReferences(iterator.next());
            }

        }catch (DataAccessException e) {
            log.error("DataAccessException caught in BaseApplicationService.retrieveAllNullReferencesInCollection(Collection valueObjectsCollection): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.retrieveAllNullReferencesInCollection(Collection valueObjectsCollection)" + e.toString(),e);
        }catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.retrieveAllNullReferencesInCollection(Collection valueObjectsCollection): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.retrieveAllNullReferencesInCollection(Collection valueObjectsCollection)" + e.toString(),e);
        }
    }




    public Collection  createRelationshipCollection(Class realClass, Object[] keyValues, String collectionName, String pAttributeName, Collection valueObjectsCollection,  String[] pAttributeNames,Object[] valuesArray)throws ApplicationServiceException{
        try{
            DAO dao = getDAO();

            Class relatedObjectClass = dao.getClassFromPath(realClass,collectionName+"."+pAttributeName);
            if (valueObjectsCollection==null) valueObjectsCollection = dao.findCollectionByTemplate(ConstructorUtils.invokeConstructor(relatedObjectClass,null,null));

            Class relationShipClass = dao.getCollectionClassFromPath(realClass,collectionName);
            Class relationShipItemClass =dao.getClassFromPath(realClass,collectionName);
            
            
//            String[] fksToItemClassInDecomposedRelationship = (String[]) dao.getFksToItemClassInDecomposedRelationship(realClass,collectionName,pAttributeName).toArray(new String[]{});
//            String[] relatedObjectClassPkNames = getPkNames(relatedObjectClass,"");
            
            String[] fksToItemClassInDecomposedRelationship = null;
            String[] relatedObjectClassPkNames = null;
            
            Collection fksToItemClassInDecomposedRelationshipCollection=dao.getFksToItemClassInDecomposedRelationship(realClass,collectionName,pAttributeName);
            if(fksToItemClassInDecomposedRelationshipCollection!=null && !fksToItemClassInDecomposedRelationshipCollection.isEmpty()){
            	fksToItemClassInDecomposedRelationship = (String[])fksToItemClassInDecomposedRelationshipCollection.toArray(new String[]{});
            	relatedObjectClassPkNames = getPkNames(relatedObjectClass,"");
            }
            
            
            Collection relationShipCollection = BeanCollectionUtils.createCollectionWithCollectionElements(relationShipClass,valueObjectsCollection,relationShipItemClass,relatedObjectClassPkNames,fksToItemClassInDecomposedRelationship,pAttributeNames,valuesArray);
            BeanCollectionUtils.setAttributes(relationShipCollection, pAttributeName, valueObjectsCollection);

            // start added by Alessandro on 06-dec-2008
            String[] inverseForeignKeyFields = null;
            Collection  inverseForeignKeyFieldsCollection = dao.getInverseForeignKeyFields(realClass,collectionName);
            if(inverseForeignKeyFieldsCollection!=null && !inverseForeignKeyFieldsCollection.isEmpty()) {
                inverseForeignKeyFields =(String[]) inverseForeignKeyFieldsCollection.toArray(new String[]{});
                BeanCollectionUtils.setAttributes(relationShipCollection,inverseForeignKeyFields, keyValues);
            }
            // end added by Alessandro on 06-dec-2008
            /* deleted by Alessandro on 06-dec-2008
            String[] inverseForeignKeyFields =(String[]) dao.getInverseForeignKeyFields(realClass,collectionName).toArray(new String[]{});
            BeanCollectionUtils.setAttributes(relationShipCollection,inverseForeignKeyFields, keyValues);
            */

            return relationShipCollection;

        }catch (DataAccessException e) {
            log.error("DataAccessException caught in BaseApplicationService.createRelationshipCollection(Class realClass, Object[] inverseForeignKeyValues, String collectionName, String pAttributeName, Collection valueObjectsCollection,  String[] pAttributeNames,Object[] valuesArray): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.createRelationshipCollection(Class realClass, Object[] inverseForeignKeyValues, String collectionName, String pAttributeName, Collection valueObjectsCollection,  String[] pAttributeNames,Object[] valuesArray)" + e.toString(),e);
        }catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.createRelationshipCollection(Class realClass, Object[] inverseForeignKeyValues, String collectionName, String pAttributeName, Collection valueObjectsCollection,  String[] pAttributeNames,Object[] valuesArray): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.createRelationshipCollection(Class realClass, Object[] inverseForeignKeyValues, String collectionName, String pAttributeName, Collection valueObjectsCollection,  String[] pAttributeNames,Object[] valuesArray)" + e.toString(),e);
        }
    }



    public boolean addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, Collection nodeSourcePAttributeNamesCollection, Collection nodeTargetPAttributeNamesCollection, Collection nodePAttributeNamesCollection, Collection nodeValuesArrayCollection)throws ApplicationServiceException{
        try{

            //return addTreeToTree( sourceRootVO,  targetRootVO,  sourceTreePath,  targetTreePath,  nodeSourcePAttributeNamesCollection,  nodeTargetPAttributeNamesCollection,  nodePAttributeNamesCollection,  nodeValuesArrayCollection, null);

            if (nodeSourcePAttributeNamesCollection==null) nodeSourcePAttributeNamesCollection = nodeTargetPAttributeNamesCollection;
            if (nodeTargetPAttributeNamesCollection==null) nodeTargetPAttributeNamesCollection = nodeSourcePAttributeNamesCollection;

            String[][] nodeSourcePAttributeNames = null;
            String[][] nodeTargetPAttributeNames = null;
            if (nodeSourcePAttributeNamesCollection!=null){//nodeTargetPAttributeNamesCollection!=null too
                /* deleted by Alessandro  on 15-dec-2008
                nodeSourcePAttributeNames = (String[][]) nodeSourcePAttributeNamesCollection.toArray(new String[]{});
                nodeTargetPAttributeNames = (String[][]) nodeTargetPAttributeNamesCollection.toArray(new String[]{});
                */
                // start added by Alessandro on 15-dec-2008
                nodeSourcePAttributeNames = new String[nodeSourcePAttributeNamesCollection.size()][];
                Iterator nodeSourcePAttributeNamesCollectionIterator = nodeSourcePAttributeNamesCollection.iterator();
                int k=0;
                while(nodeSourcePAttributeNamesCollectionIterator.hasNext()) {
                    nodeSourcePAttributeNames[k] = (String[])nodeSourcePAttributeNamesCollectionIterator.next();
                    k++;
                }
                nodeTargetPAttributeNames = new String[nodeTargetPAttributeNamesCollection.size()][];
                Iterator nodeTargetPAttributeNamesCollectionIterator = nodeTargetPAttributeNamesCollection.iterator();
                k=0;
                while(nodeTargetPAttributeNamesCollectionIterator.hasNext()) {
                    nodeTargetPAttributeNames[k] = (String[])nodeTargetPAttributeNamesCollectionIterator.next();
                    k++;
                }
                // end added by Alessandro on 15-dec-2008
            }

            String[][] nodePAttributeNames = null;
            //if (nodePAttributeNamesCollection!=null) nodePAttributeNames =  (String[][]) nodePAttributeNamesCollection.toArray(new String[]{});  // deleted    by Alessandro on 15-dec-2008
            // start added by Alessandro on 15-dec-2008
            if (nodePAttributeNamesCollection!=null) {
                nodePAttributeNames = new String[nodePAttributeNamesCollection.size()][];
                Iterator nodePAttributeNamesCollectionIterator = nodePAttributeNamesCollection.iterator();
                int k=0;
                while(nodePAttributeNamesCollectionIterator.hasNext()) {
                    nodePAttributeNames[k] = (String[])nodePAttributeNamesCollectionIterator.next();
                    k++;
                }
            }
            // end added by Alessandro on 15-dec-2008


            Object[][] nodeValuesArray = null;
            //if (nodeValuesArray!=null) nodeValuesArray = (Object[][]) nodeValuesArrayCollection.toArray();// deleted    by Alessandro on 15-dec-2008
            // start added by Alessandro on 15-dec-2008
            if (nodeValuesArrayCollection!=null) {
                nodeValuesArray = new Object[nodeValuesArrayCollection.size()][];
                Iterator nodeValuesArrayCollectionIterator = nodeValuesArrayCollection.iterator();
                int k=0;
                while(nodeValuesArrayCollectionIterator.hasNext()) {
                    nodeValuesArray[k] = (Object[])nodeValuesArrayCollectionIterator.next();
                    k++;
                }
            }
            // end added by Alessandro on 15-dec-2008

            return addTreeToTree( sourceRootVO,  targetRootVO,  sourceTreePath,  targetTreePath, nodeSourcePAttributeNames,  nodeTargetPAttributeNames,  nodePAttributeNames, nodeValuesArray);

        }catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, Collection nodeSourcePAttributeNamesCollection, Collection nodeTargetPAttributeNamesCollection, Collection nodePAttributeNamesCollection, Collection nodeValuesArrayCollection): " + e.toString());
            throw new ApplicationServiceException("NoSuchMethodException thrown in BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, Collection nodeSourcePAttributeNamesCollection, Collection nodeTargetPAttributeNamesCollection, Collection nodePAttributeNamesCollection, Collection nodeValuesArrayCollection)" + e.toString(),e);
        }
    }



    public boolean addTreeToTree( Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, String[][] nodePAttributeNames, Object[][] nodeValuesArray) throws ApplicationServiceException{
        try{
            DAO dao = getDAO();
            return addTreeToTree( sourceRootVO,  targetRootVO,  sourceTreePath,  targetTreePath,  nodeSourcePAttributeNames,  nodeTargetPAttributeNames, new Integer(0),  nodePAttributeNames,  nodeValuesArray,dao);
        }catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, String[][] nodePAttributeNames, Object[][] nodeValuesArray): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, String[][] nodePAttributeNames, Object[][] nodeValuesArray)" + e.toString(),e);
        }
    }


    public boolean  addTreeToTree(Object sourceRootVO, Object targetRootVO,Collection sourceTreePaths,Collection targetTreePaths, Collection treeNodeSourcePAttributeNames, Collection treeNodeTargetPAttributeNames, Collection treeNodePAttributeNames, Collection treeNodeValuesArray ) throws ApplicationServiceException{
        try{

            //return addTreeToTree( sourceRootVO,  targetRootVO, sourceTreePaths, targetTreePaths,  treeNodeSourcePAttributeNames,  treeNodeTargetPAttributeNames,  treeNodePAttributeNames,  treeNodeValuesArray,null ) ;

            boolean added = false;
            if (treeNodeSourcePAttributeNames==null) treeNodeSourcePAttributeNames = treeNodeTargetPAttributeNames;
            if (treeNodeTargetPAttributeNames==null) treeNodeTargetPAttributeNames = treeNodeSourcePAttributeNames;


            //sourceTreePath and targetTreePaths can't be null
            if(sourceTreePaths==null || targetTreePaths==null) {
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO,Collection sourceTreePaths,Collection targetTreePaths, Collection treeNodeSourcePAttributeNames,Collection treeNodeTargetPAttributeNames, Collection treeNodePAttributeNames, Collection treeNodeValuesArray ) : sourceTreePath and targetTreePaths can't be null" );
            }

            //if not null sourceTreePath and targetTreePaths must have the same size
            if(sourceTreePaths.size()!=targetTreePaths.size()) throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO,Collection sourceTreePaths,Collection targetTreePaths, Collection treeNodeSourcePAttributeNames,Collection treeNodeTargetPAttributeNames, Collection treeNodePAttributeNames, Collection treeNodeValuesArray ) :if not null sourceTreePath and targetTreePaths must have the same size" );

            //if not null treeNodeSourcePAttributeNames and treeNodeTargetPAttributeNames must have the same size
            if(treeNodeSourcePAttributeNames!=null && treeNodeSourcePAttributeNames.size()!=treeNodeTargetPAttributeNames.size()){ // && treeNodeTargetPAttributeNames!=null
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO,Collection sourceTreePaths,Collection targetTreePaths, Collection treeNodeSourcePAttributeNames,Collection treeNodeTargetPAttributeNames, Collection treeNodePAttributeNames, Collection treeNodeValuesArray ) :if not null treeNodeSourcePAttributeNames and treeNodeTargetPAttributeNames must the same have size" );
            }

            //if not null treeNodeSourcePAttributeNames and treeNodeTargetPAttributeNames must have  the same size of sourceTreePath and targetTreePaths
            if (treeNodeSourcePAttributeNames!=null  && treeNodeSourcePAttributeNames.size()!=sourceTreePaths.size()){ // && treeNodeTargetPAttributeNames!=null
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO,Collection sourceTreePaths,Collection targetTreePaths, Collection treeNodeSourcePAttributeNames,Collection treeNodeTargetPAttributeNames, Collection treeNodePAttributeNames, Collection treeNodeValuesArray ) :if not null treeNodeSourcePAttributeNames and treeNodeTargetPAttributeNames must have the same size of sourceTreePath and targetTreePaths" );
            }

            //treeNodePAttributeNames and treeNodeValuesArray must be both null or both not null
            if ((treeNodePAttributeNames==null && treeNodeValuesArray!=null )||(treeNodePAttributeNames!=null &&treeNodeValuesArray==null)  ){
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO,Collection sourceTreePaths,Collection targetTreePaths, Collection treeNodeSourcePAttributeNames,Collection treeNodeTargetPAttributeNames, Collection treeNodePAttributeNames, Collection treeNodeValuesArray ) :treeNodePAttributeNames and  treeNodeValuesArray must be both null or both not null" );
            }

            //if not null treeNodePAttributeNames and  treeNodeValuesArray must have  the same size
            if (treeNodePAttributeNames!=null  && treeNodePAttributeNames.size()!=treeNodeValuesArray.size()){//&& treeNodeValuesArray!=null
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO,Collection sourceTreePaths,Collection targetTreePaths, Collection treeNodeSourcePAttributeNames,Collection treeNodeTargetPAttributeNames, Collection treeNodePAttributeNames, Collection treeNodeValuesArray ) : if not null treeNodePAttributeNames and  treeNodeValuesArray must have the same size" );
            }

            //f not null treeNodePAttributeNames and  treeNodeValuesArray must have the same size of sourceTreePath and targetTreePaths
            if (treeNodePAttributeNames!=null && treeNodePAttributeNames.size()!=sourceTreePaths.size()){      //&& treeNodeValuesArray!=null
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO,Collection sourceTreePaths,Collection targetTreePaths, Collection treeNodeSourcePAttributeNames,Collection treeNodeTargetPAttributeNames, Collection treeNodePAttributeNames, Collection treeNodeValuesArray ) : if not null treeNodePAttributeNames and  treeNodeValuesArray must have the same size of sourceTreePath and targetTreePaths" );
            }

            Iterator sourceTreePathsIterator = sourceTreePaths.iterator();
            Iterator targetTreesPathsIterator= targetTreePaths.iterator();

            Iterator treeNodeSourcePAttributeNamesIterator = null;
            Iterator treeNodeTargetPAttributeNamesIterator = null;
            if(treeNodeSourcePAttributeNames!=null ){ // treeNodeTargetPAttributeNames!=null too
                treeNodeSourcePAttributeNamesIterator = treeNodeSourcePAttributeNames.iterator();
                treeNodeTargetPAttributeNamesIterator = treeNodeTargetPAttributeNames.iterator();
            }

            Iterator treeNodePAttributeNamesIterator=null;
            Iterator treeNodeValuesArrayIterator=null;
            if(treeNodePAttributeNames!=null){// treeNodeValuesArray!=null too
                treeNodePAttributeNamesIterator = treeNodePAttributeNames.iterator();
                treeNodeValuesArrayIterator =  treeNodeValuesArray.iterator();
            }

            while (sourceTreePathsIterator.hasNext()){ //targetTreesPathsIterator must have next too.

                Object  nodeSourcePAttributeNames = null;
                Object  nodeTargetPAttributeNames = null;

                if (treeNodeSourcePAttributeNamesIterator != null){  //treeNodeTargetPAttributeNamesIterator !=null too and both  must have a next
                    nodeSourcePAttributeNames =  treeNodeSourcePAttributeNamesIterator.next();
                    nodeTargetPAttributeNames =  treeNodeTargetPAttributeNamesIterator.next();
                }

                Object  nodePAttributeNames = null;
                Object nodeValuesArray=null;
                if (treeNodePAttributeNamesIterator!=null){ //treeNodeValuesArrayIterator!=null too and both  must have a next
                    nodePAttributeNames= treeNodePAttributeNamesIterator.next();
                    nodeValuesArray=  treeNodeValuesArrayIterator.next();
                }
                boolean localAdded = false;

                if (nodeSourcePAttributeNames==null) nodeSourcePAttributeNames = nodeTargetPAttributeNames;
                if (nodeTargetPAttributeNames==null) nodeTargetPAttributeNames = nodeSourcePAttributeNames;

                if ((nodePAttributeNames!=null && nodeValuesArray==null) ||(nodePAttributeNames==null && nodeValuesArray!=null)){
                    throw new ApplicationServiceException("BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO,Collection sourceTreePaths,Collection targetTreePaths, Collection treeNodeSourcePAttributeNames, Collection treeNodeTargetPAttributeNames, Collection treeNodePAttributeNames, Collection treeNodeValuesArray ) :  elements of the same position of the two colletions treeNodePAttributeNames and treeNodeValuesArray must be both null or both not null");
                }


                if (nodeSourcePAttributeNames!=null){//nodeSourcePAttributeNames!=null && nodeTargetPAttributeNames!=null
                    if (Collection.class.isInstance(nodeSourcePAttributeNames) && Collection.class.isInstance(nodeTargetPAttributeNames)){
                        if (nodePAttributeNames!=null){//nodeSourcePAttributeNames!=null && nodeTargetPAttributeNames!=null && nodePAttributeNames!=null && nodeValuesArray!=null
                            if (Collection.class.isInstance(nodePAttributeNames) && Collection.class.isInstance(nodeValuesArray)){
                                localAdded = addTreeToTree(sourceRootVO,  targetRootVO,(String) sourceTreePathsIterator.next(),(String) targetTreesPathsIterator.next(), (Collection)nodeSourcePAttributeNames, (Collection)nodeTargetPAttributeNames, (Collection)nodePAttributeNames, (Collection)nodeValuesArray);
                            }else{
                                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO,Collection sourceTreePaths,Collection targetTreePaths, Collection treeNodeSourcePAttributeNames,Collection treeNodeTargetPAttributeNames, Collection treeNodePAttributeNames, Collection treeNodeValuesArray ) : the not null elements of the same position of the for colletions treeNodeSourcePAttributeNames, treeNodeTargetPAttributeNames, treeNodePAttributeNames and treeNodeValuesArray must be all Collection or all String[][]" );
                            }
                        }else{//nodeSourcePAttributeNames!=null && nodeTargetPAttributeNames!=null && nodePAttributeNames==null && nodeValuesArray!==null
                            localAdded = addTreeToTree(sourceRootVO,  targetRootVO,(String) sourceTreePathsIterator.next(),(String) targetTreesPathsIterator.next(), (Collection)nodeSourcePAttributeNames, (Collection)nodeTargetPAttributeNames, null, null);
                        }
                    //}else if (String[][].class.isInstance(nodeSourcePAttributeNames) && String[][].class.isInstance(nodeTargetPAttributeNames)){ //  deleted by Alessandro on 15-dec-2008
                    }else if (nodeSourcePAttributeNames.getClass().toString().equals("class [[Ljava.lang.String;") && nodeTargetPAttributeNames.getClass().toString().equals("class [[Ljava.lang.String;")){  //  added by Alessandro on 15-dec-2008
                        if (nodePAttributeNames!=null){//nodeSourcePAttributeNames!=null && nodeTargetPAttributeNames!=null && nodePAttributeNames!=null && nodeValuesArray!=null
                            //if (String[][].class.isInstance(nodePAttributeNames) && String[][].class.isInstance(nodeValuesArray)){   //  deleted by Alessandro on 15-dec-2008
                            if (nodePAttributeNames.getClass().toString().equals("class [[Ljava.lang.String;") && nodeValuesArray.getClass().toString().equals("class [[Ljava.lang.Object;")){  //  added by Alessandro on 15-dec-2008
                                //localAdded = addTreeToTree(sourceRootVO,  targetRootVO,(String) sourceTreePathsIterator.next(),(String) targetTreesPathsIterator.next(), (String[][])nodeSourcePAttributeNames, (String[][])nodeTargetPAttributeNames, (String[][])nodePAttributeNames, (String[][])nodeValuesArray); //  deleted by Alessandro on 15-dec-2008
                                localAdded = addTreeToTree(sourceRootVO,  targetRootVO,(String) sourceTreePathsIterator.next(),(String) targetTreesPathsIterator.next(), (String[][])nodeSourcePAttributeNames, (String[][])nodeTargetPAttributeNames, (String[][])nodePAttributeNames, (Object[][])nodeValuesArray); //  added by Alessandro on 15dec-2008
                            }else{
                                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO,Collection sourceTreePaths,Collection targetTreePaths, Collection treeNodeSourcePAttributeNames,Collection treeNodeTargetPAttributeNames, Collection treeNodePAttributeNames, Collection treeNodeValuesArray ) : the not null elements of the same position of the for colletions treeNodeSourcePAttributeNames, treeNodeTargetPAttributeNames, treeNodePAttributeNames and treeNodeValuesArray must be all Collection or all String[][]" );
                            }
                        }else{//nodeSourcePAttributeNames!=null && nodeTargetPAttributeNames!=null && nodePAttributeNames==null && nodeValuesArray!==null
                            //localAdded = addTreeToTree(sourceRootVO,  targetRootVO,(String) sourceTreePathsIterator.next(),(String) targetTreesPathsIterator.next(), (String[][])nodeSourcePAttributeNames, (String[][])nodeTargetPAttributeNames, null, null);//  deleted by Alessandro on 15-dec-2008
                            localAdded = addTreeToTree(sourceRootVO,  targetRootVO,(String) sourceTreePathsIterator.next(),(String) targetTreesPathsIterator.next(), (String[][])nodeSourcePAttributeNames, (String[][])nodeTargetPAttributeNames, null, null); //added  by Alessandro on 15-dec-2008
                        }
                    } else{
                        throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO,Collection sourceTreePaths,Collection targetTreePaths, Collection treeNodeSourcePAttributeNames,Collection treeNodeTargetPAttributeNames, Collection treeNodePAttributeNames, Collection treeNodeValuesArray ) : the not null elements of the same position of the for colletions treeNodeSourcePAttributeNames, treeNodeTargetPAttributeNames, treeNodePAttributeNames and treeNodeValuesArray must be all Collection or all String[][]" );
                    }
                }else{//nodeSourcePAttributeNames==null && nodeTargetPAttributeNames==null
                    if (nodePAttributeNames!=null){//nodeSourcePAttributeNames==null && nodeTargetPAttributeNames==null && nodePAttributeNames!=null && nodeValuesArray!=null
                        if (Collection.class.isInstance(nodePAttributeNames) && Collection.class.isInstance(nodeValuesArray)){
                            localAdded = addTreeToTree(sourceRootVO,  targetRootVO,(String) sourceTreePathsIterator.next(),(String) targetTreesPathsIterator.next(), null, null, (Collection)nodePAttributeNames, (Collection)nodeValuesArray);
                        //}else if (String[][].class.isInstance(nodePAttributeNames) && String[][].class.isInstance(nodeValuesArray)){  //  deleted by Alessandro on 15-dec-2008
                        }else if (nodePAttributeNames.getClass().toString().equals("class [[Ljava.lang.String;") && nodeValuesArray.getClass().toString().equals("class [[Ljava.lang.Object;")){ //  added by Alessandro on 15-dec-2008
                            //localAdded = addTreeToTree(sourceRootVO,  targetRootVO,(String) sourceTreePathsIterator.next(),(String) targetTreesPathsIterator.next(), null, null, (String[][])nodePAttributeNames, (String[][])nodeValuesArray); //deleted by Alessandro on 15-dec-2008
                            localAdded = addTreeToTree(sourceRootVO,  targetRootVO,(String) sourceTreePathsIterator.next(),(String) targetTreesPathsIterator.next(), null, null, (String[][])nodePAttributeNames, (Object[][])nodeValuesArray); //  added by Alessandro on 15-dec-2008
                        }else{
                            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO,Collection sourceTreePaths,Collection targetTreePaths, Collection treeNodeSourcePAttributeNames,Collection treeNodeTargetPAttributeNames, Collection treeNodePAttributeNames, Collection treeNodeValuesArray ) : the not null elements of the same position of the for colletions treeNodeSourcePAttributeNames, treeNodeTargetPAttributeNames, treeNodePAttributeNames and treeNodeValuesArray must be all Collection or all String[][]" );
                        }
                    }else{//nodeSourcePAttributeNames==null && nodeTargetPAttributeNames==null && nodePAttributeNames==null && nodeValuesArray==null
                        //localAdded = addTreeToTree(sourceRootVO,  targetRootVO,(String) sourceTreePathsIterator.next(),(String) targetTreesPathsIterator.next(), (String[][])null, (String[][])null, (String[][])null, (String[][])null); //deleted by Alessandro on 15-dec-2008
                        localAdded = addTreeToTree(sourceRootVO,  targetRootVO,(String) sourceTreePathsIterator.next(),(String) targetTreesPathsIterator.next(), (String[][])null, (String[][])null, (String[][])null, (Object[][])null);//  added by Alessandro on 15-dec-2008
                    }
                }

                added=added||localAdded;

            }

            return added;


        }catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO,Collection sourceTreePaths,Collection targetTreePaths, Collection treeNodeSourcePAttributeNames,Collection treeNodeTargetPAttributeNames, Collection treeNodePAttributeNames, Collection treeNodeValuesArray ): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO,Collection sourceTreePaths,Collection targetTreePaths, Collection treeNodeSourcePAttributeNames,Collection treeNodeTargetPAttributeNames, Collection treeNodePAttributeNames, Collection treeNodeValuesArray )" + e.toString(),e);
        }
    }







    /**
     * If the first attribute of the dot separated list of attributes <code>sourceTreePath</code>, and the first attribute of the dot separated list of attributes <code>targetTreePath</code>
     * are respectively collections of  <code>sourceRootVO</code> and <code>targetRootVO</code>,  for each element of the collection held by <code>sourceRootVO</code>
     * this method will create a new instance of the class of the elements of the collection held by  <code>targetRootVO</code> (if such collection is not existing will be created an empty one, using the
     * collection implementation class specified in the mapping file for it), and for such created instance its attributes <code>nodeTargetPAttributeNames[depth]</code>
     * will be populated with the attributes <code>nodeSourcePAttributeNames[depth]</code> of the element being processed,  its  attributes <code>nodePAttributeNames[depth]</code>
     * will be populateed with <code>nodeValuesArray[depth]</code>, and its foreign fields to  <code>targetRootVO</code> will be populated with the key values of <code>targetRootVO</code>.</br>
     * The new created instance will be compared with the elements of the collection held by <code>targetRootVO</code> by its key values, and if no matching element is found it will be added to it,
     * and this method will be recursively called, where the new  <code>sourceRootVO</code> and <code>targetRootVO</code> will be the element being processed of the collection held by by <code>sourceRootVO</code> and the
     * new created instance; the new <code>sourceTreePath</code> and <code>targetTreePath</code> will be the same input parameter, but from the second attribute; the new <code>depth</code> will be
     * the same increased by 1, and the remaining parameters are unchanged. If in the comparison between the new created instance and the elements of the collection held by <code>targetRootVO</code> a matching element is found,
     * the method will be recursively called in the same above way, with the difference that the new <code>targetRootVO</code> won't be the created instance, but the found matching element.</br>
     * It will be returned true if the new instance is added or the recursive call returns true, false otherwise.</br>
     * </br>
     * If the first attribute of the dot separated list of attributes <code>sourceTreePath</code> and the first attribute of the dot separated list of attributes <code>targetTreePath</code>
     * are respectively value objects of  <code>sourceRootVO</code> and <code>targetRootVO</code>, if the value object held by <code>sourceRootVO</code> is not null and
     * the value object held by <code>targetRootVO</code> is null, this method will create a new instance of the class of the value object held by <code>targetRootVO</code> ,
     * and for such created instance its attributes <code>nodeTargetPAttributeNames[depth]</code>
     * will be populated with the attributes <code>nodeSourcePAttributeNames[depth]</code> of the value object held by <code>sourceRootVO</code>,  its  attributes <code>nodePAttributeNames[depth]</code>
     * will be populatee with <code>nodeValuesArray[depth]</code>, and this new instance will be used to set the first attribute of the dot separated list of attributes <code>targetTreePath</code>
     * of <code>targetRootVO</code>, and the foreign keys fields of <code>targetRootVO</code> to such value object will be set with the key values of the new instance.</br>
     * If the value object held by <code>sourceRootVO</code> is not null, this method will be recursively called, in the same way described above, but where the new <code>sourceRootVO</code> and <code>targetRootVO</code>
     * will be the two value objects respectively held by them (for the value object held by targetRootVO it could be the new instanced one).</br>
     * It will be returned true if the value object held by <code>targetRootVO</code> has been set with the new instance or if the recursion returns true, false otherwise.
     * </br>
     * The recursion ends when <code>sourceTreePath</code> and  <code>targetTreePath</code> are empty strings.</br>
     * </br>
     * If <code>nodeSourcePAttributeNames</code> and  <code>nodeTargetPAttributeNames</code> are both null, the relative operations are not performed; if just one of them is null, it will assume the value of the other one.
     * For example if <code>nodeSourcePAttributeNames</code> is null and <code>nodeTargetPAttributeNames</code> is not null, <code>nodeSourcePAttributeNames</code> will have the value of <code>nodeTargetPAttributeNames</code> (and viceversa).</br>
     * If <code>nodeSourcePAttributeNames</code> and  <code>nodeTargetPAttributeNames</code> are not null, for each <code>depth</code>
     * if <code>nodeSourcePAttributeNames[depth]</code> and  <code>nodeTargetPAttributeNames[depth]</code> are both null, the relative operations are not performed; if just one of them is null, it will assume the value of the other one.
     * If <code>nodePAttributeNames</code> and  <code>nodeValuesArray</code> are both null, the relative operations are not performed; if they are not null for each <code>depth</code>
     * if <code>nodePAttributeNames[depth]</code> and  <code>nodeValuesArray[depth]</code> are both null, the relative operations are not performed;
     * </br>
     *
     *
     * @param sourceRootVO Root of the source tree. It can't be null.
     * @param targetRootVO Root of the target tree. It can't be null.
     * @param sourceTreePath dot separated list of attributes defining the source tree. It can't be null.
     * @param targetTreePath dot separated list of attributes defining the target tree. It can't be null.
     * @param nodeSourcePAttributeNames    <code>nodeSourcePAttributeNames[depth]</code> are the attributes names of the children of <code>sourceRootVO</code> used to populate
     *              the <code>nodeTargetPAttributeNames[depth]</code> attributes of the relative instances to add to the children of <code>targetRootVO</code>.
     * @param nodeTargetPAttributeNames  <code>nodeTargetPAttributeNames[depth]</code> are the attributes names of the created instances to add to the children <code>targetRootVO</code>
     *              to be populated with attributes <code>nodeSourcePAttributeNames[depth]</code> of the children of <code>sourceRootVO</code>.
     * @param depth depth of the tree being processed
     * @param nodePAttributeNames <code>nodePAttributeNames[depth]</code> are the attributes of the created instance to add to the target tree, to be populated with <code>nodeValuesArray[depth]</code>.
     * @param nodeValuesArray <code>nodeValuesArray[depth]</code> are used to populate the attributes <code>nodePAttributeNames[depth]</code> of the created instances.
     * @param dao DAO instance to access the media store
     * @return true is something is added to the tree rapresented by the two input parameter <code>targetRootVO</code> and <code>targetTreePath</code>, false otherwise.
     * @throws it.aco.mandragora.exception.ApplicationServiceException  -
     *      If  <code>sourceRootVO</code> or <code>targetRootVO</code> or <code>sourceTreePath</code> or <code>targetTreePath</code> are null.</br>
     *      If  <code>sourceTreePath</code> and <code>targetTreePath</code> are not both empty strings or not both not empty strings.</br>
     *      If  <code>nodeSourcePAttributeNames</code> and  <code>nodeTargetPAttributeNames</code> are not null, and don't have the same length.</br>
     *      If  <code>nodeSourcePAttributeNames</code> and  <code>nodeTargetPAttributeNames</code> are not null, and <code>nodeSourcePAttributeNames[depth]</code> and <code>nodeTargetPAttributeNames[depth]</code> are not null but don't have the same length.</br>
     *      If  <code>nodePAttributeNames</code> and  <code>nodeValuesArray</code> are not both null or both both not null.</br>
     *      If  <code>nodePAttributeNames</code> and <code>nodeValuesArray</code> are not null, and don't have the same length.</br>
     *      If  <code>nodePAttributeNames</code> and  <code>nodeValuesArray</code> are not null, and <code>nodePAttributeNames[depth]</code> and <code>nodeValuesArray[depth]</code> are not null but don't have the same length.</br>
     *      If  <code>nodePAttributeNames</code>,   <code>nodeValuesArray</code>,  <code>nodeSourcePAttributeNames</code> and  <code>nodeTargetPAttributeNames</code> are not null, and don't have all the same length.</br>
     *      If the first attribute of the dot separated list of attributes <code>sourceTreePath</code>, and the first attribute of the dot separated list of attributes <code>targetTreePath</code> are not both collection or both value objects.</br>
     */
    private boolean addTreeToTree( Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[][] nodePAttributeNames, Object[][] nodeValuesArray, DAO dao)throws ApplicationServiceException{
        try{


            log.debug("addTreeToTree( Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[][] nodePAttributeNames, Object[][] nodeValuesArray, DAO dao) : sourceTreePath = "+sourceTreePath);
            log.debug("addTreeToTree( Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[][] nodePAttributeNames, Object[][] nodeValuesArray, DAO dao) : targetTreePath = "+targetTreePath);

            log.debug("addTreeToTreeRecursive(Context context) : sourceRootVO = "+sourceRootVO);
            log.debug("addTreeToTreeRecursive(Context context) : targetRootVO = "+targetRootVO);
            log.debug("addTreeToTreeRecursive(Context context) : depth = "+depth);

            if(sourceTreePath.equals("")&&targetTreePath.equals("")) return false;

            boolean added = false;

            if (nodeSourcePAttributeNames==null) {
                nodeSourcePAttributeNames = nodeTargetPAttributeNames;
            }
            if (nodeTargetPAttributeNames==null) {
                nodeTargetPAttributeNames = nodeSourcePAttributeNames;
            }

            /**************************** begin parameters integrity control**************************************************************/
            /* sourceRootVO, targetRootVO, sourceTreePath, targetTreePath can't be null */
            if (sourceRootVO==null || targetRootVO==null ||sourceTreePath==null || targetTreePath==null ){
                throw new ApplicationServiceException("BaseApplicationService.addTreeToTree( Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[][] nodePAttributeNames, Object[][] nodeValuesArray, DAO dao): sourceRootVO, targetRootVO, sourceTreePath, targetTreePath can't be null ");
            }

            /*sourceTree and targetTree must be both empty or both not empty*/
            if((!sourceTreePath.equals("")&&targetTreePath.equals(""))||(sourceTreePath.equals("")&&!targetTreePath.equals(""))){
                throw new ApplicationServiceException("BaseApplicationService.addTreeToTree( Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[][] nodePAttributeNames, Object[][] nodeValuesArray, DAO dao):  sourceTreePath and targetTreePath must be both empty or both not empty");
            }

            /*if nodeSourcePAttributeNames and  nodeTargetPAttributeNames are not null, must have the same length*/
            if (nodeSourcePAttributeNames!=null /*&& nodeTargetPAttributeNames!=null*/ && nodeSourcePAttributeNames.length != nodeTargetPAttributeNames.length){
                throw new ApplicationServiceException("BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[][] nodePAttributeNames, Object[][] nodeValuesArray, DAO dao): if nodeSourcePAttributeNames and  nodeTargetPAttributeNames are not null, must have the same length");
            }

            /*if nodeSourcePAttributeNames and  nodeTargetPAttributeNames are not null, and nodeSourcePAttributeNames[depth] and nodeTargetPAttributeNames[depth] are not null must have the same length");*/
            if (nodeSourcePAttributeNames!=null /*&& nodeTargetPAttributeNames!=null*/ && nodeSourcePAttributeNames[depth.intValue()]!=null && nodeTargetPAttributeNames[depth.intValue()]!=null && nodeSourcePAttributeNames[depth.intValue()].length!=nodeTargetPAttributeNames[depth.intValue()].length){
                throw new ApplicationServiceException("BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[][] nodePAttributeNames, Object[][] nodeValuesArray, DAO dao): if nodeSourcePAttributeNames and  nodeTargetPAttributeNames are not null, and nodeSourcePAttributeNames["+depth.intValue()+"] and nodeTargetPAttributeNames["+depth.intValue()+"] are not null must have the same length");
            }

            /*nodePAttributeNames and nodeValuesArray must be both null or both not null*/
            if ((nodePAttributeNames!=null && nodeValuesArray==null) ||(nodePAttributeNames==null && nodeValuesArray!=null)){
                throw new ApplicationServiceException("BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[][] nodePAttributeNames, Object[][] nodeValuesArray, DAO dao):  nodePAttributeNames and nodeValuesArray must be both null or both not null");
            }

            /*if nodePAttributeNames and nodeValuesArray are not null, they must have the same length */
            if (nodePAttributeNames!=null /*&& nodeValuesArray!=null*/ && nodePAttributeNames.length != nodeValuesArray.length){
                throw new ApplicationServiceException("BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[][] nodePAttributeNames, Object[][] nodeValuesArray, DAO dao): if nodePAttributeNames and nodeValuesArray are not null, they must have the same length");
            }

            /* if nodePAttributeNames,  nodeValuesArray, nodeSourcePAttributeNames and nodeTargetPAttributeNames are not null, the must have all the same length*/
            if (nodePAttributeNames!=null /*&& nodeValuesArray!=null*/ && nodeSourcePAttributeNames!=null /*&& nodeTargetPAttributeNames!=null*/ && nodePAttributeNames.length!=nodeSourcePAttributeNames.length){
                throw new ApplicationServiceException("BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[][] nodePAttributeNames, Object[][] nodeValuesArray, DAO dao): if nodePAttributeNames,  nodeValuesArray, nodeSourcePAttributeNames and nodeTargetPAttributeNames are not null, the must have all the same length");
            }


            /**************************** end parameters integrity control**************************************************************/


            //DAO dao = ServiceLocator.getInstance().getContextDAO(DAOFactoryClass,DAOClass);
            PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();

            String[] sourceTreeFirstAttributeNameAndRemainingPath =  Utils.getFirstAttributeNameAndRemainingPath(sourceTreePath);
            String[] targetTreeFirstAttributeNameAndRemainingPath =  Utils.getFirstAttributeNameAndRemainingPath(targetTreePath);


            Class sourceCollectionClass;
            Class targetCollectionClass;
            Class targetCollectionElementClass;

            sourceCollectionClass = dao.getCollectionClassFromPath(getEntityClass(sourceRootVO),sourceTreeFirstAttributeNameAndRemainingPath[0]);
            targetCollectionClass = dao.getCollectionClassFromPath(getEntityClass(targetRootVO),targetTreeFirstAttributeNameAndRemainingPath[0]);
            targetCollectionElementClass=dao.getClassFromPath(getEntityClass(targetRootVO),targetTreeFirstAttributeNameAndRemainingPath[0]);



            /*sourceRootVO and targetRootVO must have first attribute both as collection or both valueobject*/
            if ((sourceCollectionClass == null && targetCollectionClass!=null)||(sourceCollectionClass != null && targetCollectionClass==null)){
                throw new ApplicationServiceException("BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath,String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[][] nodePAttributeNames, Object[][] nodeValuesArray, DAO dao): sourceRootVO and targetRootVO must have first attribute both as collection or both valueobject");
            }





            if (sourceCollectionClass != null){// targetCollectionClass!= null too
                                               // sourceRootVO.firstAttributeNameSourceTree and targetRootVO.firstAttributeNameTargetTree are collection
                log.debug("addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[][] nodePAttributeNames, Object[][] nodeValuesArray, DAO dao): sourceRootVO.firstAttribute  and targetRootVO.firstAttribute are collection");
                Collection sourceCollection=(Collection) propertyUtilsBean.getProperty(sourceRootVO,sourceTreeFirstAttributeNameAndRemainingPath[0]);

                /* deleted by Alessandro on 12-dec-2008
                String[] inverseForeignKeyFields;
                inverseForeignKeyFields =(String[])  dao.getInverseForeignKeyFields(sourceRootVO.getClass(),sourceTreeFirstAttributeNameAndRemainingPath[0]).toArray(new String[]{});
                */

                // start added by Alessandro on 12-dec-2008
                String[] inverseForeignKeyFields = null;
                //Collection  inverseForeignKeyFieldsCollection = dao.getInverseForeignKeyFields(sourceRootVO.getClass(),sourceTreeFirstAttributeNameAndRemainingPath[0]);
                Collection  inverseForeignKeyFieldsCollection = dao.getInverseForeignKeyFields(getEntityClass(targetRootVO),targetTreeFirstAttributeNameAndRemainingPath[0]);
                if(inverseForeignKeyFieldsCollection!=null && !inverseForeignKeyFieldsCollection.isEmpty()) {
                    inverseForeignKeyFields =(String[]) inverseForeignKeyFieldsCollection.toArray(new String[]{});
                }
                // end added by Alessandro on 12-dec-2008

                //Object[] sourceRootVOKeyValues = getKeyValues(sourceRootVO,null); //deleted by Alessandro  on 15-dec-2008
                Object[] targetRootVOKeyValues = getKeyValues(targetRootVO,null); //added by Alessandro  on 15-dec-2008

                if (sourceCollection!=null){

                    Collection targetCollection = getReferenceCollectionOrEmptyIfNull(targetRootVO,targetTreeFirstAttributeNameAndRemainingPath[0],null ); // I don't mind which is the collectionImplClass

                    Object valueObjectsCollection = null;
                    Object pAttributeNames = null;


                    Iterator sourceCollectionIterator =  sourceCollection.iterator();
                    while (sourceCollectionIterator.hasNext()){
                        Object sourceCollectionElement = sourceCollectionIterator.next();
                        Object targetCollectionElement = targetCollectionElementClass.newInstance();
                        /* //deleted by Alessandro  on 15-dec-2008
                        BeanCollectionUtils.setAttributes(sourceCollectionElement,nodeSourcePAttributeNames[depth.intValue()],targetCollectionElement,nodeTargetPAttributeNames[depth.intValue()]);
                        BeanCollectionUtils.setAttributes(targetCollectionElement,nodePAttributeNames[depth.intValue()],nodeValuesArray[depth.intValue()]);
                        */
                        //   start added by Alessandro on 15-dec-2008
                        if(nodeSourcePAttributeNames!=null){  // surely  nodeTargetPAttributeNames!=null too
                            log.debug("setting nodeTargetPAttributeNames["+depth+"] with nodeSourcePAttributeNames["+depth+"]");
                            BeanCollectionUtils.setAttributes(sourceCollectionElement,nodeSourcePAttributeNames[depth.intValue()],targetCollectionElement,nodeTargetPAttributeNames[depth.intValue()]);
                        }
                        if(nodePAttributeNames!=null){   // surely  nodeValuesArray!=null too
                            log.debug("setting nodePAttributeNames["+depth+"] with nodeValuesArray["+depth+"]");
                            BeanCollectionUtils.setAttributes(targetCollectionElement,nodePAttributeNames[depth.intValue()],nodeValuesArray[depth.intValue()]);
                        }
                        //   end added by Alessandro on 15-dec-2008
                        //BeanCollectionUtils.setAttributes(targetCollectionElement,inverseForeignKeyFields,sourceRootVOKeyValues); deleted by alessandro on 12-dec-2008
                        //if(inverseForeignKeyFields!=null)BeanCollectionUtils.setAttributes(targetCollectionElement,inverseForeignKeyFields,sourceRootVOKeyValues);  //added by alessandro on 12-dec-2008   deleted  on 15-dec-2008
                        if(inverseForeignKeyFields!=null)BeanCollectionUtils.setAttributes(targetCollectionElement,inverseForeignKeyFields,targetRootVOKeyValues);//added by Alessandro on 15-dec-2008

                        log.debug("addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[][] nodePAttributeNames, Object[][] nodeValuesArray, DAO dao):sourceCollectionElement : "+sourceCollectionElement);
                        log.debug("addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[][] nodePAttributeNames, Object[][] nodeValuesArray, DAO dao):targetFormatSourceCollectionElement : "+targetCollectionElement);
                        boolean localAdded;
                        localAdded=addToCollection(targetCollection,targetCollectionElement,null);
                        //if (addToCollection(targetCollection,targetCollectionElement,null)){
                        if (localAdded){

                            added = true;
                            addTreeToTree(sourceCollectionElement,targetCollectionElement,sourceTreeFirstAttributeNameAndRemainingPath[1],targetTreeFirstAttributeNameAndRemainingPath[1], nodeSourcePAttributeNames,  nodeTargetPAttributeNames,new Integer(depth.intValue()+1),  nodePAttributeNames, nodeValuesArray,dao);
                        }else{
                            String[] targetCollectionElementPkNames;
                            Object[] targetCollectionElementKeyValues;
                            targetCollectionElementPkNames = dao.getPkNames(targetCollectionElementClass);
                            targetCollectionElementKeyValues = dao.getKeyValues(targetCollectionElement);
                            Object newTargetRootVO = Utils.selectWhereFieldsEqualsTo((Collection) propertyUtilsBean.getProperty(targetRootVO,targetTreeFirstAttributeNameAndRemainingPath[0]),targetCollectionElementPkNames,targetCollectionElementKeyValues).iterator().next();

                            //added = addTreeToTree(sourceCollectionElement,newTargetRootVO,sourceTreeFirstAttributeNameAndRemainingPath[1],targetTreeFirstAttributeNameAndRemainingPath[1], nodeSourcePAttributeNames,  nodeTargetPAttributeNames, new Integer(depth.intValue()+1), nodePAttributeNames, nodeValuesArray,dao);  //deleted by Alessandro on 15-dec-2008
                            added = addTreeToTree(sourceCollectionElement,newTargetRootVO,sourceTreeFirstAttributeNameAndRemainingPath[1],targetTreeFirstAttributeNameAndRemainingPath[1], nodeSourcePAttributeNames,  nodeTargetPAttributeNames, new Integer(depth.intValue()+1), nodePAttributeNames, nodeValuesArray,dao) || added;//added by Alessandro on 15-dec-2008
                        }
                    }

                }
            }else{ //sourceRootVO.firstAttributeNameSourceTree and targetRootVO.firstAttributeNameTargetTree are NOT collection
                log.debug("addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[][] nodePAttributeNames, Object[][] nodeValuesArray, DAO dao): sourceRootVO.firstAttributeNameSourceTree and targetRootVO.firstAttributeNameTargetTree are NOT collection");

                Object sourceCollectionElement = propertyUtilsBean.getProperty(sourceRootVO,sourceTreeFirstAttributeNameAndRemainingPath[0]);
                if(sourceCollectionElement!=null){

                    Object targetCollectionElement = propertyUtilsBean.getProperty(targetRootVO,targetTreeFirstAttributeNameAndRemainingPath[0]);
                    if (targetCollectionElement==null){
                        targetCollectionElement = targetCollectionElementClass.newInstance();
                        propertyUtilsBean.setProperty(targetRootVO,targetTreeFirstAttributeNameAndRemainingPath[0],targetCollectionElement);
                        //   start added by Alessandro on 15-dec-2008
                        if(nodeSourcePAttributeNames!=null){  // surely  nodeTargetPAttributeNames!=null too
                            BeanCollectionUtils.setAttributes(sourceCollectionElement,nodeSourcePAttributeNames[depth.intValue()],targetCollectionElement,nodeTargetPAttributeNames[depth.intValue()]);
                        }
                        if(nodePAttributeNames!=null){   // surely  nodeValuesArray!=null too
                            BeanCollectionUtils.setAttributes(targetCollectionElement,nodePAttributeNames[depth.intValue()],nodeValuesArray[depth.intValue()]);
                        }
                        //   end added by Alessandro on 15-dec-2008
                        /* deleted by Alessandro on 15-dec-2008
                        BeanCollectionUtils.setAttributes(sourceCollectionElement,nodeSourcePAttributeNames[depth.intValue()],targetCollectionElement,nodeTargetPAttributeNames[depth.intValue()]);
                        BeanCollectionUtils.setAttributes(targetCollectionElement,nodePAttributeNames[depth.intValue()],nodeValuesArray[depth.intValue()]);
                        */

                        setForeignKeyFields(targetRootVO,targetTreeFirstAttributeNameAndRemainingPath[0]);
                        added=true;
                    }

                    //added = added || addTreeToTree(sourceCollectionElement,targetCollectionElement,sourceTreeFirstAttributeNameAndRemainingPath[1],targetTreeFirstAttributeNameAndRemainingPath[1], nodeSourcePAttributeNames,  nodeTargetPAttributeNames,new Integer(depth.intValue()+1),  nodePAttributeNames,nodeValuesArray,dao); //deleted by Alessandro on 15-dec-2008
                    added = addTreeToTree(sourceCollectionElement,targetCollectionElement,sourceTreeFirstAttributeNameAndRemainingPath[1],targetTreeFirstAttributeNameAndRemainingPath[1], nodeSourcePAttributeNames,  nodeTargetPAttributeNames,new Integer(depth.intValue()+1),  nodePAttributeNames,nodeValuesArray,dao) ||added;//added by Alessandro on 15-dec-2008
                }
            }

            return added;
        } catch (ServiceLocatorException e) {
            log.error("ServiceLocatorException caught in BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[][] nodePAttributeNames, Object[][] nodeValuesArray, DAO dao): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[][] nodePAttributeNames, Object[][] nodeValuesArray, DAO dao)" + e.toString(),e);
        }catch (DataAccessException e) {
            log.error("DataAccessrException caught in BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[][] nodePAttributeNames, Object[][] nodeValuesArray, DAO dao): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[][] nodePAttributeNames, Object[][] nodeValuesArray, DAO dao)" + e.toString(),e);
        } catch (IllegalAccessException e) {
            log.error("IllegalAccessException caught in BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[][] nodePAttributeNames, Object[][] nodeValuesArray, DAO dao): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[][] nodePAttributeNames, Object[][] nodeValuesArray, DAO dao)" + e.toString(),e);
        }catch (InvocationTargetException e) {
            log.error("InvocationTargetException caught in BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[][] nodePAttributeNames, Object[][] nodeValuesArray, DAO dao): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[][] nodePAttributeNames, Object[][] nodeValuesArray, DAO dao)" + e.toString(),e);
        }catch (NoSuchMethodException e) {
            log.error("NoSuchMethodException caught in BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[][] nodePAttributeNames, Object[][] nodeValuesArray, DAO dao): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[][] nodePAttributeNames, Object[][] nodeValuesArray, DAO dao)" + e.toString(),e);
        }catch (InstantiationException e) {
            log.error("InstantiationException caught in BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[][] nodePAttributeNames, Object[][] nodeValuesArray, DAO dao): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[][] nodePAttributeNames, Object[][] nodeValuesArray, DAO dao)" + e.toString(),e);
        } catch (Exception e) {
            log.error("Exception caught in BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[][] nodePAttributeNames, Object[][] nodeValuesArray, DAO dao): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseApplicationService.addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[][] nodePAttributeNames, Object[][] nodeValuesArray, DAO dao)" + e.toString(),e);
        }
    }

    protected  Class getEntityClass(Object entity) throws ApplicationServiceException{
		try {
			return PersistenceUtil.getEntityClass(entity);
		} catch (Exception e) {
            log.error("InvocationTargetException caught in   BaseApplicationService.getEntityClass(Object entity): " + e.toString());
            throw new ApplicationServiceException("Error in   BaseApplicationService.getEntityClass(Object entity): " + e.toString(),e);
		}
	}




}