/* ====================================================================
 *		      GNU GENERAL PUBLIC LICENSE
 *		         Version 2, June 1991
 *
 *    Copyright (C) 1989, 1991 Free Software Foundation, Inc.
 *                        51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *    Everyone is permitted to copy and distribute verbatim copies
 *  of this license document, but changing it is not allowed.
 *
 *  			    Preamble
 *
 *    The licenses for most software are designed to take away your
 *  freedom to share and change it.  By contrast, the GNU General Public
 *  License is intended to guarantee your freedom to share and change free
 *  software--to make sure the software is free for all its users.  This
 *  General Public License applies to most of the Free Software
 *  Foundation's software and to any other program whose authors commit to
 *  using it.  (Some other Free Software Foundation software is covered by
 *  the GNU Library General Public License instead.)  You can apply it to
 *  your programs, too.
 *
 *    When we speak of free software, we are referring to freedom, not
 *  price.  Our General Public Licenses are designed to make sure that you
 *  have the freedom to distribute copies of free software (and charge for
 *  this service if you wish), that you receive source code or can get it
 *  if you want it, that you can change the software or use pieces of it
 *  in new free programs; and that you know you can do these things.
 *
 *     To protect your rights, we need to make restrictions that forbid
 *  anyone to deny you these rights or to ask you to surrender the rights.
 *  These restrictions translate to certain responsibilities for you if you
 *  distribute copies of the software, or if you modify it.
 *
 *     For example, if you distribute copies of such a program, whether
 *  gratis or for a fee, you must give the recipients all the rights that
 *  you have.  You must make sure that they, too, receive or can get the
 *  source code.  And you must show them these terms so they know their
 *  rights.
 *
 *     We protect your rights with two steps: (1) copyright the software, and
 *  (2) offer you this license which gives you legal permission to copy,
 *  distribute and/or modify the software.
 *
 *     Also, for each author's protection and ours, we want to make certain
 *  that everyone understands that there is no warranty for this free
 *  software.  If the software is modified by someone else and passed on, we
 *  want its recipients to know that what they have is not the original, so
 *  that any problems introduced by others will not reflect on the original
 *  authors' reputations.
 *
 *     Finally, any free program is threatened constantly by software
 *  patents.  We wish to avoid the danger that redistributors of a free
 *  program will individually obtain patent licenses, in effect making the
 *  program proprietary.  To prevent this, we have made it clear that any
 *  patent must be licensed for everyone's free use or not licensed at all.
 *
 *     The precise terms and conditions for copying, distribution and
 *  modification follow.
 *  
 *	                	    GNU GENERAL PUBLIC LICENSE
 *       TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
 *
 *     0. This License applies to any program or other work which contains
 *  a notice placed by the copyright holder saying it may be distributed
 *  under the terms of this General Public License.  The "Program", below,
 *  refers to any such program or work, and a "work based on the Program"
 *  means either the Program or any derivative work under copyright law:
 *  that is to say, a work containing the Program or a portion of it,
 *  either verbatim or with modifications and/or translated into another
 *  language.  (Hereinafter, translation is included without limitation in
 *  the term "modification".)  Each licensee is addressed as "you".
 *
 *     Activities other than copying, distribution and modification are not
 *  covered by this License; they are outside its scope.  The act of
 *  running the Program is not restricted, and the output from the Program
 *  is covered only if its contents constitute a work based on the
 *  Program (independent of having been made by running the Program).
 *  Whether that is true depends on what the Program does.
 *
 *     1. You may copy and distribute verbatim copies of the Program's
 *  source code as you receive it, in any medium, provided that you
 *  conspicuously and appropriately publish on each copy an appropriate
 *  copyright notice and disclaimer of warranty; keep intact all the
 *  notices that refer to this License and to the absence of any warranty;
 *  and give any other recipients of the Program a copy of this License
 *  along with the Program.
 *
 *  You may charge a fee for the physical act of transferring a copy, and
 *  you may at your option offer warranty protection in exchange for a fee.
 *
 *     2. You may modify your copy or copies of the Program or any portion
 *  of it, thus forming a work based on the Program, and copy and
 *  distribute such modifications or work under the terms of Section 1
 *  above, provided that you also meet all of these conditions:
 *
 *        a) You must cause the modified files to carry prominent notices
 *     stating that you changed the files and the date of any change.
 *
 *        b) You must cause any work that you distribute or publish, that in
 *     whole or in part contains or is derived from the Program or any
 *     part thereof, to be licensed as a whole at no charge to all third
 *     parties under the terms of this License.
 *
 *        c) If the modified program normally reads commands interactively
 *     when run, you must cause it, when started running for such
 *     interactive use in the most ordinary way, to print or display an
 *     announcement including an appropriate copyright notice and a
 *     notice that there is no warranty (or else, saying that you provide
 *     a warranty) and that users may redistribute the program under
 *     these conditions, and telling the user how to view a copy of this
 *     License.  (Exception: if the Program itself is interactive but
 *     does not normally print such an announcement, your work based on
 *     the Program is not required to print an announcement.)
 *     
 *     These requirements apply to the modified work as a whole.  If
 *  identifiable sections of that work are not derived from the Program,
 *  and can be reasonably considered independent and separate works in
 *  themselves, then this License, and its terms, do not apply to those
 *  sections when you distribute them as separate works.  But when you
 *  distribute the same sections as part of a whole which is a work based
 *  on the Program, the distribution of the whole must be on the terms of
 *  this License, whose permissions for other licensees extend to the
 *  entire whole, and thus to each and every part regardless of who wrote it.
 *
 *     Thus, it is not the intent of this section to claim rights or contest
 *  your rights to work written entirely by you; rather, the intent is to
 *  exercise the right to control the distribution of derivative or
 *  collective works based on the Program.
 *
 *     In addition, mere aggregation of another work not based on the Program
 *  with the Program (or with a work based on the Program) on a volume of
 *  a storage or distribution medium does not bring the other work under
 *  the scope of this License.
 *
 *      3. You may copy and distribute the Program (or a work based on it,
 *  under Section 2) in object code or executable form under the terms of
 *  Sections 1 and 2 above provided that you also do one of the following:
 *
 *        a) Accompany it with the complete corresponding machine-readable
 *     source code, which must be distributed under the terms of Sections
 *     1 and 2 above on a medium customarily used for software interchange; or,
 *
 *        b) Accompany it with a written offer, valid for at least three
 *     years, to give any third party, for a charge no more than your
 *     cost of physically performing source distribution, a complete
 *     machine-readable copy of the corresponding source code, to be
 *     distributed under the terms of Sections 1 and 2 above on a medium
 *     customarily used for software interchange; or,
 *
 *        c) Accompany it with the information you received as to the offer
 *     to distribute corresponding source code.  (This alternative is
 *     allowed only for noncommercial distribution and only if you
 *     received the program in object code or executable form with such
 *     an offer, in accord with Subsection b above.)
 *
 *  The source code for a work means the preferred form of the work for
 *  making modifications to it.  For an executable work, complete source
 *  code means all the source code for all modules it contains, plus any
 *  associated interface definition files, plus the scripts used to
 *  control compilation and installation of the executable.  However, as a
 *  special exception, the source code distributed need not include
 *  anything that is normally distributed (in either source or binary
 *  form) with the major components (compiler, kernel, and so on) of the
 *  operating system on which the executable runs, unless that component
 *  itself accompanies the executable.
 *
 *  If distribution of executable or object code is made by offering
 *  access to copy from a designated place, then offering equivalent
 *  access to copy the source code from the same place counts as
 *  distribution of the source code, even though third parties are not
 *  compelled to copy the source along with the object code.
 *  
 *     4. You may not copy, modify, sublicense, or distribute the Program
 *  except as expressly provided under this License.  Any attempt
 *  otherwise to copy, modify, sublicense or distribute the Program is
 *  void, and will automatically terminate your rights under this License.
 *  However, parties who have received copies, or rights, from you under
 *  this License will not have their licenses terminated so long as such
 *  parties remain in full compliance.
 *
 *    5. You are not required to accept this License, since you have not
 *  signed it.  However, nothing else grants you permission to modify or
 *  distribute the Program or its derivative works.  These actions are
 *  prohibited by law if you do not accept this License.  Therefore, by
 *  modifying or distributing the Program (or any work based on the
 *  Program), you indicate your acceptance of this License to do so, and
 *  all its terms and conditions for copying, distributing or modifying
 *  the Program or works based on it.
 *
 *    6. Each time you redistribute the Program (or any work based on the
 *  Program), the recipient automatically receives a license from the
 *  original licensor to copy, distribute or modify the Program subject to
 *  these terms and conditions.  You may not impose any further
 *  restrictions on the recipients' exercise of the rights granted herein.
 *  You are not responsible for enforcing compliance by third parties to
 *  this License.
 *
 *    7. If, as a consequence of a court judgment or allegation of patent
 *  infringement or for any other reason (not limited to patent issues),
 *  conditions are imposed on you (whether by court order, agreement or
 *  otherwise) that contradict the conditions of this License, they do not
 *  excuse you from the conditions of this License.  If you cannot
 *  distribute so as to satisfy simultaneously your obligations under this
 *  License and any other pertinent obligations, then as a consequence you
 *  may not distribute the Program at all.  For example, if a patent
 *  license would not permit royalty-free redistribution of the Program by
 *  all those who receive copies directly or indirectly through you, then
 *  the only way you could satisfy both it and this License would be to
 *  refrain entirely from distribution of the Program.

 *  If any portion of this section is held invalid or unenforceable under
 *  any particular circumstance, the balance of the section is intended to
 *  apply and the section as a whole is intended to apply in other
 *  circumstances.

 *  It is not the purpose of this section to induce you to infringe any
 *  patents or other property right claims or to contest validity of any
 *  such claims; this section has the sole purpose of protecting the
 *  integrity of the free software distribution system, which is
 *  implemented by public license practices.  Many people have made
 *  generous contributions to the wide range of software distributed
 *  through that system in reliance on consistent application of that
 *  system; it is up to the author/donor to decide if he or she is willing
 *  to distribute software through any other system and a licensee cannot
 *  impose that choice.

 *  This section is intended to make thoroughly clear what is believed to
 *  be a consequence of the rest of this License.
 *  
 *    8. If the distribution and/or use of the Program is restricted in
 *  certain countries either by patents or by copyrighted interfaces, the
 *  original copyright holder who places the Program under this License
 *  may add an explicit geographical distribution limitation excluding
 *  those countries, so that distribution is permitted only in or among
 *  countries not thus excluded.  In such case, this License incorporates
 *  the limitation as if written in the body of this License.
 *
 *    9. The Free Software Foundation may publish revised and/or new versions
 *  of the General Public License from time to time.  Such new versions will
 *  be similar in spirit to the present version, but may differ in detail to
 *  address new problems or concerns.
 *
 *  Each version is given a distinguishing version number.  If the Program
 *  specifies a version number of this License which applies to it and "any
 *  later version", you have the option of following the terms and conditions
 *  either of that version or of any later version published by the Free
 *  Software Foundation.  If the Program does not specify a version number of
 *  this License, you may choose any version ever published by the Free Software
 *  Foundation.

 *    10. If you wish to incorporate parts of the Program into other free
 *  programs whose distribution conditions are different, write to the author
 *  to ask for permission.  For software which is copyrighted by the Free
 *  Software Foundation, write to the Free Software Foundation; we sometimes
 *  make exceptions for this.  Our decision will be guided by the two goals
 *  vof preserving the free status of all derivatives of our free software and
 *  of promoting the sharing and reuse of software generally.
 *
 *  			    NO WARRANTY
 *
 *    11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
 *  FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
 *  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
 *  PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
 *  OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
 *  TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
 *  PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
 *  REPAIR OR CORRECTION.
 *
 *    12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
 *  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
 *  REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
 *  INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
 *  OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
 *  TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
 *  YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
 *  PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGES.
 *
 *  		     END OF TERMS AND CONDITIONS
 *  
 *  	    How to Apply These Terms to Your New Programs
 *    If you develop a new program, and you want it to be of the greatest
 *  possible use to the public, the best way to achieve this is to make it
 *  free software which everyone can redistribute and change under these terms.
 *
 *    To do so, attach the following notices to the program.  It is safest
 *  to attach them to the start of each source file to most effectively
 *  convey the exclusion of warranty; and each file should have at least
 *  the "copyright" line and a pointer to where the full notice is found.
 *
 *      <one line to give the program's name and a brief idea of what it does.>
 *      Copyright (C) <year>  <name of author>
 *
 *      This program is free software; you can redistribute it and/or modify
 *      it under the terms of the GNU General Public License as published by
 *      the Free Software Foundation; either version 2 of the License, or
 *      (at your option) any later version.
 *
 *      This program is distributed in the hope that it will be useful,
 *      but WITHOUT ANY WARRANTY; without even the implied warranty of
 *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *      GNU General Public License for more details.
 *
 *      You should have received a copy of the GNU General Public License
 *      along with this program; if not, write to the Free Software
 *      Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *
 *
 *  Also add information on how to contact you by electronic and paper mail.
 *
 *  If the program is interactive, make it output a short notice like this
 *  when it starts in an interactive mode:
 *
 *      Gnomovision version 69, Copyright (C) year name of author
 *      Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
 *      This is free software, and you are welcome to redistribute it
 *      under certain conditions; type `show c' for details.
 *
 *  The hypothetical commands `show w' and `show c' should show the appropriate
 *  parts of the General Public License.  Of course, the commands you use may
 *  be called something other than `show w' and `show c'; they could even be
 *  mouse-clicks or menu items--whatever suits your program.
 *
 *  You should also get your employer (if you work as a programmer) or your
 *  school, if any, to sign a "copyright disclaimer" for the program, if
 *  necessary.  Here is a sample; alter the names:
 *
 *    Yoyodyne, Inc., hereby disclaims all copyright interest in the program
 *    `Gnomovision' (which makes passes at compilers) written by James Hacker.
 *
 *    <signature of Ty Coon>, 1 April 1989
 *    Ty Coon, President of Vice

 *  This General Public License does not permit incorporating your program into
 *  proprietary programs.  If your program is a subroutine library, you may
 *  consider it more useful to permit linking proprietary applications with the
 *  library.  If this is what you want to do, use the GNU Library General
 *  Public License instead of this License.

*/
package it.aco.mandragora.as;

import it.aco.mandragora.exception.ApplicationServiceException;

import java.util.Collection;
import java.util.Map;
import it.aco.mandragora.common.utils.BeanCollectionUtils;


public interface ApplicationService {

    /**
     * This method returns the collection specified by the attribute named <code>pAttributeName</code> of the value object <code>pInstance</code>.</br>
     * <code>pAttributeName</code> can be directly the name of an attribute of  <code>pInstance</code>, or can be a dot separated list of attributes, that
     * establish a path through value objects from <code>pInstance</code> to the collection we want to return. The path have to be a walk through only value objects,
     * with no collection on his walk, except for  the last attribute that must be a collection (note that if <code>pAttributeName</code> is a single token it must be a reference to a collection). If not an ApplicationServiceException is thrown.</br>
     * If such collection is null it will be retrieved from the underlying media store and returned.</br>
     * Note that if <code>pAttributeName</code> is not the name of a direct attribute of <code>pInstance</code>, if some of the value objects on the path represented by  <code>pAttributeName</code>
     * is null, it will be retrieved.</br>
     * </br>
     * <code>pInstance</code> can't be null, <code>pAttributeName</code> can't be null, nor empty string nor blank characters string, otherwise  an ApplicationServiceException is thrown.
     *
     * @param pInstance value object holding the collection to return, or starting point of the path represented by <code>pAttributeName</code> that leads to such collection</br>
     *                  If null an ApplicationServiceException is thrown.
     * @param pAttributeName attribute of <code>pInstance</code> holding the collection to return, or dot separated list of token that leaves to the collection from <code>pInstance</code>
     *                        If null or empty string or blank characters string an ApplicationServiceException is thrown.
     * @return the collection of elements associated to the attribute represented by the input parameter <code>pAttributeName</code> in the  value object <code>pInstance</code>
     * @throws ApplicationServiceException -
     *      If <code>pInstance</code> is null or <code>pAttributeName</code> is null or empty string or blank characters string.</br>
     *      If <code>pAttributeName</code> don't represent a path from <code>pInstance</code> through only value objects, except the last token that must represent a collection.</br>  
     */
    public Collection getReferenceCollectionOrRetrieveIfNull(Object pInstance, String pAttributeName) throws ApplicationServiceException;


    /**
     * This method has the same behavior of {@link #getReferenceCollectionOrEmptyIfNull(Object pInstance, String pAttributeName, Class collectionImplClass)}
     * where  <code>collectionImplClass</code> is null
     * @param pInstance value object holding the collection to return, or starting point of the path represented by <code>pAttributeName</code> that leaves to such collection</br>
     *                  If null an ApplicationServiceException is thrown.
     * @param pAttributeName attribute of <code>pInstance</code> holding the collection to return, or dot separated list of token that leaves to the collection from <code>pInstance</code>
     *                        If null or empty string or blank characters string an ApplicationServiceException is thrown.
     * @return The collection reachable from <code>pInstance</code> through the path <code>pAttributeName</code>
     * @throws ApplicationServiceException -
     *      If <code>pInstance</code> is null or
     *      <code>pAttributeName</code> is null or empty string or blank characters string.</br>
     *      If <code>pAttributeName</code> don't represent a path from <code>pInstance</code> through only value objects, except the last token that must represent a collection.</br>
     */
    public Collection getReferenceCollectionOrEmptyIfNull(Object pInstance, String pAttributeName) throws ApplicationServiceException;

    /**
     * This method returns the collection specified by the attribute named <code>pAttributeName</code> of the value object <code>pInstance</code>.</br>
     * <code>pAttributeName</code> can be directly the name of an attribute of  <code>pInstance</code>, or can be a dot separated list of attributes, that
     * establish a path through value objects from <code>pInstance</code> to the collection we want to return. The path have to be a walk through only value objects,
     * with no collection on its walk, except for  the last attribute that must be a collection (note that if <code>pAttributeName</code> is a single token it must be a reference to a collection). If not an ApplicationServiceException is thrown.</br>
     * All the null references to value objects on the path  <code>pAttributeName</code> (so not the reference to the last collection) will be retrieved from the underlying media store.
     * If the collection of the last reference on the path <code>pAttributeName</code> is null, and empty collection will be created (the final collection is never retrieved), and the last reference to the collection
     * will be populated with the created collection.</br>
     * If some one of the value objects on the path between <code>pInstance</code> (excluded) and the last collection is still null after retrieving from the underlying media store,
     * a null is returned.</br>
     * The collection implementation class is specified by the input parameter <code>collectionImplClass</code>. If such parameter is null, the collection implementation class
     * will be the one specified in the mapping file (i.e. repository.xml for Ojb).</br>
     * Note the size effects if some value objects on the path <code>pAttributeName</code> or the final collection, if there is some null reference on the path.</br>
     * </br>
     * <code>pInstance</code> can't be null, <code>pAttributeName</code> can't be null, nor empty string nor blank characters string, otherwise  an ApplicationServiceException is thrown.
     * @param pInstance value object holding the collection to return, or starting point of the path represented by <code>pAttributeName</code> that leaves to such collection</br>
     *                  If null an ApplicationServiceException is thrown.
     * @param pAttributeName attribute of <code>pInstance</code> holding the collection to return, or dot separated list of token that leaves to the collection from <code>pInstance</code>
     *                        If null or empty string or blank characters string an ApplicationServiceException is thrown.
     * @param collectionImplClass collection o implementation class needed if the collection has to be created.</br>
     *                           If null will be used the collection implementation class specified by the mapping file (i.e. repository.xml for Ojb).
     * @return The collection reachable from <code>pInstance</code> through the path <code>pAttributeName</code>
     * @throws ApplicationServiceException -
     *      If <code>pInstance</code> is null or
     *      <code>pAttributeName</code> is null or empty string or blank characters string.</br>
     *      If <code>pAttributeName</code> don't represent a path from <code>pInstance</code> through only value objects, except the last token that must represent a collection.</br>
     */
    public Collection getReferenceCollectionOrEmptyIfNull(Object pInstance, String pAttributeName, Class collectionImplClass) throws ApplicationServiceException;




    /**
     * This method returns the inverse foreign key fields that are not primary keys too.
     * So first of all will be got all attribute names of the class of the items of the collection represented by <code>pAttributeName</code>, attributes that
     * represents the inverse foreign keys to the main class holding the same collection.</br>
     * Then will be got the primary key field names of the generic element of such collection, and that fields will be removed from the inverse foreign fields collection. </br>
     * <code>pAttributeName</code> can be a direct attribute of the class <code>realClass</code> or a dot separated list of attributes that leads from the class <code>realClass</code>
     * to the collection we are interested in .</br>
     * The parameter <code>pAttributeName</code> can be a direct attribute of <code>realClass</code> or a dot separated list of attributes.</br>
     * If <code>pAttributeName</code> is a direct attribute, the main class holding the collection is the same <code>realClass</code>. </br>
     * <code>pAttributeName</code> must always represent a collection, otherwise a ApplicationServiceException is thrown.
     *
     * @param realClass  class holding the collection  whose foreign key fields with the exception of the primary keys, have to be returned, or starting point of the path represented by <code>pAttributeName</code>, that leaves to such collection.
     * @param pAttributeName  name of the attribute holding the collection  whose foreign key fields with the exception of the primary keys have to be returned, or path leading to such collection from <code>realClass</code>
     * @return  The inverse foreign key fields that are not primary keys too.
     * @throws ApplicationServiceException  -
     *      If <code>realClass</code> is null or
     *      <code>pAttributeName</code> is null or empty string or blank characters string.</br>
     *
     */
    public Collection getInverseForeignKeyNotPKFields(Class realClass, String pAttributeName)throws ApplicationServiceException;


    /**
     * This method returns the primary keys fields of <code>realClass#pAttributeName</code> that are not inverse foreign keys  too.
     * So first of all will be got all attribute names of the class of the items of the collection represented by <code>pAttributeName</code>, attributes that
     * represents the primary keys of the generic element of such collection.</br>
     * Then will be got the inverse foreign key fields  to the main class holding the same collection  , and that fields will be removed from the primary key fields to return. </br>
     * <code>pAttributeName</code> can be a direct attribute of the class <code>realClass</code> or a dot separated list of attributes that leaves from the class <code>realClass</code>
     * to the collection we are interested in .</br>
     * If <code>pAttributeName</code> is a direct attribute, the main class holding the collection is the same <code>realClass</code>. </br>
     * <code>pAttributeName</code> must always represent a collection, otherwise a ApplicationServiceException is thrown
     * @param realClass class holding the collection  whose  elements primary keys fields with the exception of the inverse foreign keys, have to be returned, or starting point of the path represented by <code>pAttributeName</code>, that leaves to such collection.
     * @param pAttributeName name of the attribute holding the collection  whose primary keys fields with the exception of the inverse foreign keys have to be returned, or path leading to such collection from <code>realClass</code>
     * @return  The primary keys that are not inverse foreign key fields too.
     * @throws ApplicationServiceException  -
     *      If <code>realClass</code> is null or
     *      <code>pAttributeName</code> is null or empty string or blank characters string.</br>
     *      <code>pAttributeName</code> don't lead to a collection.</br>
     *      <code>pAttributeName</code> don't represent to a collection.</br>
     */
    public String[] getPkNotInverseForeignKeyFields(Class realClass, String pAttributeName) throws ApplicationServiceException;


    /**
     * This method returns all the primary key fields names of the class that directly reference the value object that is reached following <code>pAttributeName</code> from <code>realClass</code>
     * except the foreign key attribute names of the same class to the same value object reference.</br>
     * The input parameter <code>pAttributeName</code> can be a direct attribute of the class <code>realClass</code> or a dot separated list of attributes that leaves from the class <code>realClass</code>
     * to the value object reference. </br>
     * If <code>pAttributeName</code> is a direct attribute of <code>realClass</code> the attribute names to return are the one that reference the value object represented by <code>pAttributeName</code>.</br>
     * If <code>pAttributeName</code> is a dot separated list of attributes, starting from <code>realClass</code> these attributes must lead to a value object, and the primary key fields names except the foreign key attribute names of the last element class on the path, that directly
     * references to such value object, are the ones to be returned.</br>
     * <code>pAttributeName</code> must always (directly or indirectly in the case of dot separated list of attributes) reference a value object and never a collection otherwise a ApplicationServiceException is thrown
     * If <code>realClass</code> is null a ApplicationServiceException is thrown.</br>
     * if  <code>pAttributeName</code> is null or empty string or blank characters string a null, the primary key fields names of  <code>realClass</code> are returned.</br>
     * @param realClass  class holding the reference <code>pAttributeName</code>. It can't be null
     * @param pAttributeName  attribute name of the value object which e primary keys attributes names of the class directly referring to have to be returned, discarding the foreign fields key pointing to it. If it is null or empty string or blank characters the primary key fields names of  <code>realClass</code> are returned
     * @return primary key fields names of the class directly pointing to the value object represented by <code>pAttributeName</code>, except the foreign key to it.
     * @throws ApplicationServiceException -
     *      If <code>realClass</code> is null or
     *      <code>pAttributeName</code> is null or empty string or blank characters string.</br>
     */
    public String[] getPkNotForeignKeyFields(Class realClass, String pAttributeName) throws ApplicationServiceException;


    /**
     * This method returns the array of the attributes names that are primary keys of the class that is reached following the path specified by <code>pAttributeName</code> from the class <code>realClass</code>.</br>
     * If <code>pAttributeName</code> is null or empty string or blank characters string, will returned the primary key fields of <code>realClass</code> .
     *
     * @param realClass starting point class to reach the class whose primary key fields have to be returned following <code>pAttributeName</code>.
     * @param pAttributeName path that specifies which is the class whose primary key fields have to be returned.
     * @return  the primary key fields of <code>realClass#pAttributeName</code>
     * @throws ApplicationServiceException  - If <code>realClass</code> is null.</br>
     *
     */
    public String[] getPkNames(Class realClass, String pAttributeName) throws ApplicationServiceException;


    /**
     * This method gets (and returns) the key values of the value object that is held by the attribute named <code>pAttributeName</code> of
     * <code>pInstance</code>. <code>pAttributeName</code> can be a dot separated list of attributes that leave from <code>pInstance</code>
     * to the value object whose key values have to be returned.</br>
     * <code>pAttributeName</code> must specify a value object or a walk through just value objects.
     * It can't specify a collection nor a path walking through some collection, otherwise a ApplicationServiceException is thrown</br>
     * If  <code>pAttributeName</code> is null or s an empty string or a blank characters string , the key values of <code>pInstance</code>  will be returned.</br>
     * If <code>pInstance</code> is null, or the value object to return the key values can't be reached, a null is returned.</br>
     *
     * @param pInstance value object where start a walk from, that leaves to the value object whose key values have to be returned.</br>
     *                  If null, a null is returned.
     * @param pAttributeName name of the attribute of <code>pInstance</code> that holds the value object whose key values have to be retuned,
     *                       or dot separated list of attributes that leave from <code>pInstance</code> to the value object whose key values have to be returned.</br>
     *                       If null, a null is returned. If it is an empty string or a blank characters string , the key values of <code>pInstance</code>  will be returned.
     * @return key values of <code>pInstance</code>, or of a value object reachable from <code>pInstance</code> walking trough <code>pAttributeName</code>.
     * @throws ApplicationServiceException -
     *      If <code>pAttributeName</code> specifies a collection and not a value object, or there is some collection on the path that it represents
     */
    public Object[] getKeyValues(Object pInstance,String pAttributeName) throws ApplicationServiceException;


    /**
     * This method sets the attributes of each element of the collection <code>pInstance.pAttributeName</code>, the attributes that are the inverse foreign keys to <code>pInstance</code>,
     * with the values of the primary key fields of <code>pInstance</code>.</br>
     * That's what happens if <code>pAttributeName</code> is a direct attribute of <code>pInstance</code>, but <code>pAttributeName</code> can be a dot separated list of attributes
     * that leave to a collection, starting from the value object <code>pInstance</code>.</br>
     * In such case the the inverse foreign  keys attributes will be the ones that reference to the actual value object holding the collection (the penultimate on the path).</br>
     * </br>
     * If the collection which inverse foreign fields have to be set can't be reached, nothing is done.</br>
     *
     * @param pInstance main object holding the collection which elements foreing keys has to be set with key values of the same main object, or starting point to get such main object through the path <code>pAttributeName</code>,
     * @param pAttributeName name of the attribute holding the collection which elements foreign  keys has to be set with key values, or path to it starting from <code>pInstance</code>
     * @throws ApplicationServiceException -If <code>pInstance</code> is null or <code>pAttributeName</code> is null or empty or blank characters string.</br>
     */
    public void setInverseForeignKeyFields(Object pInstance, String pAttributeName) throws ApplicationServiceException;


    /**
     * This method sets all the foreign key attributes of a value object with the key values of corresponding value object it references.</br>
     * The input parameter <code>pAttributeName</code> can be a direct attribute of <code>pInstance</code> or a dot separated list of attributes that define a path from <code>pInstance</code>
     * to an other value object. Such path has to walk just trough value objects without touching any collection otherwise a ApplicationServiceException is thrown.</br>
     * This method will set the foreign key fields of the penultimate value object on the path (the foreign key fields that point to the last value object) with the the key values of the last value object.
     * If the last value object is not reachable (some value object on the  path is  null and stops the walk) no job is done.</br>
     * If <code>pAttributeName</code> is a direct attribute of <code>pInstance</code> the foreign key fields to set are the ones of the same <code>pInstance</code>
     * that reference the value object <code>pInstance.pAttributeName</code>,
     * and of course they will be set with the primary key values of <code>pInstance.pAttributeName</code>.</br>
     *
     * if  <code>pAttributeName</code> is null or empty string or blank characters string no job is done.</br>
     *
     * @param pInstance value object holding the reference <code>pAttributeName</code>. It can't be null.</br>
     * @param pAttributeName attribute of <code>pInstance</code> or dot separated list of attribute.</br>
     * @throws ApplicationServiceException if <code>pInstance</code> is null or there is some collection on the path represented  by <code>pAttributeName</code>
     */
    public void setForeignKeyFields(Object pInstance, String pAttributeName) throws ApplicationServiceException;



    /**
     * This method analyze the primary key fields of <code>pInstance</code>, and if no one of them is null returns true, otherwise it returns false
     * @param pInstance value object which primary key fields have to be analyzed.
     * @return true if no one of primary key fields of <code>pInstance</code> is null, and returns false if at least one of these fields is null
     * @throws ApplicationServiceException - if <code>pInstance</code> is null
     */
    public boolean isKeyNotNull(Object pInstance) throws ApplicationServiceException;

    /**
     * This method applies the method {@link #isKeyNotNull(Object pInstance)} for each elements of the collection <code>valueObjectsCollection</code>.</br>
     * So for every element of  <code>valueObjectsCollection</code>, its  primary key fields will be analyzed and if at least one of them is  null, false will be returned.
     * If there is no one of the primary key fields of no one of the elements of <code>valueObjectsCollection</code> having a null value, a true is returned, otherwise false
     * is returned.
     * @param valueObjectsCollection value objects collection  which elements primary key fields have to be analyzed
     * @return true if there is no one of the primary key fields of no one of the elements of <code>valueObjectsCollection</code> having a null value, otherwise false
     * @throws ApplicationServiceException if <code>valueObjectsCollection</code> or someone of its elements is null.
     */
    public boolean isKeyNotNull(Collection valueObjectsCollection) throws ApplicationServiceException;



    /**
     * This method adds new entries to <code>map</code> , only if the key of the entry to be added doesn't exist yet in <code>map</code> or if it exists, it is mapped to a null value.</br>
     *
     * This method adds new map-entries to, and/or updates the values of existing entries in <code>map</code> on the base of the values of specific attributes of the elements of <code>valueObjectsCollection</code>.</br>
     * The elements of <code>valueObjectsCollection</code>, as his name states, are valueObjects.</br>
     * </br>
     * This method generates map-entries for <code>map</code> using as keys the values of the valueObjects attribute named as specified by the string parameter <code>valueObjectKeyAttributeName</code>.</br>
     * More precisely, for each valueObject, if its attribute specified by the string <code>valueObjectKeyAttributeName</code> has not null value, will be generated a map entry with the same value as key;
     * the value of the map entry will be a new instance of the class <code>mapValueClass</code>, or , if <code>mapValueClass</code> is null, will be the valueObject's attribute value of the attribute specified by the string <code>valueObjectValueAttributeName</code>.</br>
     * So resuming it is created a Map entry for each not null value of the <code>valueObjectsCollection</code>'s valueObjects attribute specified by the input parameter <code>valueObjectKeyAttributeName</code>, with entry key the value of the <code>valueObjectKeyAttributeName</code>
     * and entry value the  value of the <code>valueObjectValueAttributeName</code> or a new instance of <code>mapValueClass</code>. </br>
     * Of course each valueObjects of <code>valueObjectsCollection</code> must have an attribute named as the value of <code>valueObjectKeyAttributeName</code>, otherwise a ApplicationServiceException will be thrown.</br>
     * If the input string parameter <code>valueObjectKeyAttributeName</code> is null or empty string or blank characters string, a BusinessObjectException will be thrown as well.</br>
     * </br>
     * If <code>mapValueClass</code> is not null the value of the entry value of each generated entry is a new instance of <code>mapValueClass</code> created with the no arguments constructor. This newly created instance must have
     * an attribute named as the value of <code>mapValueClassAttributeToSetName</code>, and this attribute will be set with the value of the attribute specified by the string <code>valueObjectValueAttributeName</code> of the correspondent valueObject,
     * if this value is not null. If this value is null the attribute named as the value of <code>mapValueClassAttributeToSetName</code> won't be set at all.</br>
     * As in both cases of <code>mapValueClass</code> null or not null, the attribute specified by <code>valueObjectValueAttributeName</code> is needed for the entry value, each valueObjects of <code>valueObjectsCollection</code>
     * must have an attribute named as the value of the input string <code>valueObjectValueAttributeName</code>, otherwise a ApplicationServiceException will be thrown.</br>
     * If the input string parameter <code>valueObjectValueAttributeName</code> is null or empty string or blank characters string, <code>valueObjectValueAttributeName</code>
     * is forced to assume the same value of the input string parameter <code>valueObjectKeyAttributeName</code>.</br>
     * Analogously the <code>mapValueClass</code>, if not null, must have an attribute named as specified by the input string parameter <code>mapValueClassAttributeToSetName</code>. </br>
     * If the input string parameter <code>mapValueClassAttributeToSetName</code> is null or empty string or blank characters string, <code>mapValueClassAttributeToSetName</code>
     * is forced to assume the same value of the input string parameter <code>valueObjectValueAttributeName</code> (that eventually has been forced to assume the value of <code>valueObjectKeyAttributeName<code> ).</br>
     * All the entries generated by this method will be added to <code>map</code>, if not existing yet an entry in <code>map</code> with the same key, and if such key is yet existing, <code>map</code>
     * will be updated with the new entry value if and only if the value of entry to update is null: </br>
     * </br>
     *
     *
     * @param valueObjectsCollection collection containing the elements (value objects) to use to add entries to  <code>map</code>
     * @param map Map instance toadd entries to.
     * @param valueObjectKeyAttributeName  name of the attribute of the generic element of the collection <code>valueObjectsCollection</code>, that will be used as the keys of the entries to add to <code>map</code>.</br>
     * @param valueObjectValueAttributeName  name of the attribute of the generic element of the collection <code>valueObjectsCollection</code>, that will be used as entries values in <code>map</code>.</br>
     *                                      If this parameter is null, or empty or blank characters string it will be forced to assume the value of <code>valueObjectKeyAttributeName</code>
     * @param mapValueClassAttributeToSetName name of the attribute of <code>mapValueClass</code> that will be set with the value of the valueObject attribute specified by the string input parameter <code>valueObjectValueAttributeName</code>.</br>
     *                                       If this parameter is null, or empty or blank characters string it will be forced to assume the value of <code>valueObjectValueAttributeName</code>.
     * @param mapValueClass Class of the entries values of <code>map</code>. A new instance of this class will be created (with no arguments constructor) for each element of the collection <code>valueObjectsCollection</code>.</br>
     *                      The attribute of <code>mapValueClass</code> named <code>mapValueClassAttributeToSetName</code> will be populated with the value of  attribute named <code>valueObjectValueAttributeName</code> in the element of the collection <code>valueObjectsCollection</code>, if that value is not null..</br>
     *                      Of course has to exist an attribute named with the value  <code>valueObjectValueAttributeName</code>in the the class of the element of the collection <code>valueObjectsCollection</code>
     *                      and an attribute named <code>mapValueClassAttributeToSetName</code> in the class <code>mapValueClass</code>
     * @throws ApplicationServiceException -
     *      If <code>valueObjectKeyAttributeName</code> is null, or empty or blank characters string.</br>
     *      If some element of <code>valueObjectsCollection</code> don't have an attribute named as the value of <code>valueObjectKeyAttributeName</code>.</br>
     *      If some element of <code>valueObjectsCollection</code> don't have an attribute named as the value of <code>valueObjectValueAttributeName</code>;
     *          remember that if <code>valueObjectValueAttributeName</code> is null or empty string or blank characters string, it is forced to assume the value of <code>valueObjectKeyAttributeName</code>.</br>
     *      If <code>mapValueClass</code> is not null and don't have an attribute named as the value of <code>mapValueClassAttributeToSetName</code>;
     *          remember that if <code>mapValueClassAttributeToSetName</code> is null or empty string or blank characters string, it is forced to assume the value of <code>valueObjectValueAttributeName</code>  (that eventually has been forced to assume the value of <code>valueObjectKeyAttributeName<code> ).</br>
     *
     */
    public void addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, String valueObjectValueAttributeName, String mapValueClassAttributeToSetName, Class mapValueClass) throws ApplicationServiceException;


    /**
     * This method has the same behavior of {@link #addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, String valueObjectValueAttributeName, String mapValueClassAttributeToSetName, Class mapValueClass)}
     * where <code>mapValueClassAttributeToSetName</code> is null or has the same value of <code>valueObjectValueAttributeName</code>.</br>
     * @param valueObjectsCollection collection containing the elements (value objects) to use to add entries to  <code>map</code>
     * @param map Map instance to add entries to.
     * @param valueObjectKeyAttributeName  name of the attribute of the generic element of the collection <code>valueObjectsCollection</code>, that will be used as the keys of the entries to add to <code>map</code>.</br>
     * @param valueObjectValueAttributeName  name of the attribute of the generic element of the collection <code>valueObjectsCollection</code>, that will be used as entries values in <code>map</code>.</br>
     *                                      If this parameter is null, or empty or blank characters string it will be forced to assume the value of <code>valueObjectKeyAttributeName</code>
     * @param mapValueClass Class of the entries values of <code>map</code>. A new instance of this class will be created (with no arguments constructor) for each element of the collection <code>valueObjectsCollection</code>.</br>
     *                      The attribute of <code>mapValueClass</code> named <code>valueObjectValueAttributeName</code> will be populated with the value of  attribute named <code>valueObjectValueAttributeName</code> in the element of the collection <code>valueObjectsCollection</code>, if that value is not null..</br>
     *                      Of course has to exist an attribute named with the value  <code>valueObjectValueAttributeName</code>in the the class of the element of the collection <code>valueObjectsCollection</code>
     *                      and in the class <code>mapValueClass</code>
     * @throws ApplicationServiceException -
     *      If <code>valueObjectKeyAttributeName</code> is null, or empty or blank characters string.</br>
     *      If some element of <code>valueObjectsCollection</code> don't have an attribute named as the value of <code>valueObjectKeyAttributeName</code>.</br>
     *      If some element of <code>valueObjectsCollection</code> don't have an attribute named as the value of <code>valueObjectValueAttributeName</code>;
     *          remember that if <code>valueObjectValueAttributeName</code> is null or empty string or blank characters string, it is forced to assume the value of <code>valueObjectKeyAttributeName</code>.</br>
     *      If <code>mapValueClass</code> is not null and don't have an attribute named as the value of <code>valueObjectValueAttributeName</code>;
     */
    public void addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, String valueObjectValueAttributeName,Class mapValueClass) throws ApplicationServiceException;


    /**
     * This method has the same behavior of {@link #addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, String valueObjectValueAttributeName, String mapValueClassAttributeToSetName, Class mapValueClass)}
     * where <code>mapValueClassAttributeToSetName</code> and <code>valueObjectValueAttributeName</code> are null or have the same value of  <code>valueObjectKeyAttributeName</code>.</br>
     * @param valueObjectsCollection collection containing the elements (value objects) to use to add entries to  <code>map</code>
     * @param map Map instance to add entries to.
     * @param valueObjectKeyAttributeName  name of the attribute of the generic element of the collection <code>valueObjectsCollection</code>, that will be used as the keys of the entries to add to <code>map</code>.</br>
     * @param mapValueClass Class of the entries values of <code>map</code>. A new instance of this class will be created (with no arguments constructor) for each element of the collection <code>valueObjectsCollection</code>.</br>
     *                      The attribute of <code>mapValueClass</code> named <code>valueObjectKeyAttributeName</code> will be populated with the value of  with the same name <code>valueObjectKeyAttributeName</code> in the element of the collection <code>valueObjectsCollection</code>, if that value is not null..</br>
     *                      Of course has to exist an attribute named with the value  <code>valueObjectKeyAttributeName</code>in the the class of the element of the collection <code>valueObjectsCollection</code>
     *                      and in the class <code>mapValueClass</code>
     * @throws ApplicationServiceException -
     *      If <code>valueObjectKeyAttributeName</code> is null, or empty or blank characters string.</br>
     *      If some element of <code>valueObjectsCollection</code> don't have an attribute named as the value of <code>valueObjectKeyAttributeName</code>.</br>
     *      If <code>mapValueClass</code> is not null and don't have an attribute named as the value of <code>valueObjectKeyAttributeName</code>;
     */
    public void addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, Class mapValueClass) throws ApplicationServiceException;


    /**
     * This method has the same behavior of {@link #addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, String valueObjectValueAttributeName, String mapValueClassAttributeToSetName, Class mapValueClass)}
     * where <code>mapValueClass</code> is null.</br>
     * @param valueObjectsCollection  collection containing the elements (value objects) to use to add entries to  <code>map</code>
     * @param map Map instance to add entries to.
     * @param valueObjectKeyAttributeName name of the attribute of the generic element of the collection <code>valueObjectsCollection</code>, that will be used as the keys of the entries to add to <code>map</code>.</br>
     * @param valueObjectValueAttributeName name of the attribute of the generic element of the collection <code>valueObjectsCollection</code>, that will be used as entries values in <code>map</code>.</br>
     *                                      If this parameter is null, or empty or blank characters string it will be forced to assume the value of <code>valueObjectKeyAttributeName</code>
     * @throws ApplicationServiceException  -
     *      If <code>valueObjectKeyAttributeName</code> is null, or empty or blank characters string.</br>
     *      If some element of <code>valueObjectsCollection</code> don't have an attribute named as the value of <code>valueObjectKeyAttributeName</code>.</br>
     *      If some element of <code>valueObjectsCollection</code> don't have an attribute named as the value of <code>valueObjectValueAttributeName</code>;
     *          remember that if <code>valueObjectValueAttributeName</code> is null or empty string or blank characters string, it is forced to assume the value of <code>valueObjectKeyAttributeName</code>.</br>
     *     
     */
    public void addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, String valueObjectValueAttributeName) throws ApplicationServiceException;


    /**
     * This method has the same behavior of {@link #addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, String valueObjectValueAttributeName, String mapValueClassAttributeToSetName, Class mapValueClass)}
     * where <code>mapValueClass</code> is null, and <code>valueObjectValueAttributeName</code> is null or has the same value of <code>valueObjectKeyAttributeName</code>.</br>
     * @param valueObjectsCollection collection containing the elements (value objects) to use to add entries to  <code>map</code>
     * @param map  to add entries to.
     * @param valueObjectKeyAttributeName name of the attribute of the generic element of the collection <code>valueObjectsCollection</code>, that will be used as the keys of the entries to add to <code>map</code>.</br>
     * @throws ApplicationServiceException -
     *      If <code>valueObjectKeyAttributeName</code> is null, or empty or blank characters string.</br>
     *      If some element of <code>valueObjectsCollection</code> don't have an attribute named as the value of <code>valueObjectKeyAttributeName</code>.</br>
     */
    public void addNoOverwrite(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName) throws ApplicationServiceException;


    /**
     * This method updates an attribute of specific elements of the  collection <code>valueObjectsCollection</code> with elements of  the input parameter <code>map</code>.</br>
     * For each <code>key</code> of the <code>map</code>, this method looks for all the elements in <code>valueObjectsCollection</code> having the attribute <code>valueObjectKeyAttributeName==key</code>.</br>
     * For all the elements found, this method updates the attribute <code>valueObjectValueAttributeName</code>  with <code>map.get(key)</code>.</br>
     * If  valueObjectsCollection is null nothing is done.</br>
     *
     * @param valueObjectsCollection Collection whose elements attribute have to be update
     * @param map map used to update the <code>valueObjectsCollection</code>
     * @param valueObjectKeyAttributeName  name of the attribute of the generic element of the collection <code>valueObjectsCollection</code>, whose value has to match with an entry's key of  <code>map</code>,
     *                                    to update the attribute <code>valueObjectValueAttributeName</code> of the same element with the entry value.</br>
     * @param valueObjectValueAttributeName name of the attribute of the generic element of the collection <code>valueObjectsCollection</code>, that will be updated with the entry value of the <code>map</code>
     *                                    name of the attribute of the generic element of the collection <code>valueObjectsCollection</code>, that will be updated with the entry value of the <code>map</code>
     *                                      If this parameter is null, or empty or blank characters string it will be forced to assume the value of <code>valueObjectKeyAttributeName</code>.
     * @throws ApplicationServiceException -
     *       <code>map</code> is null.</br>
     *      if  <code>valueObjectKeyAttributeName</code>  is null, or empty or blank characters string.</br>
     */
    public void  updateCollectionWithMap(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, String valueObjectValueAttributeName) throws ApplicationServiceException;


    /**
     * This method has the same behavior of {@link #updateCollectionWithMap(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName, String valueObjectValueAttributeName)}
     * where <code>valueObjectValueAttributeName</code> is null or has the same value of <code>valueObjectKeyAttributeName</code>.</br>
     *
     * @param valueObjectsCollection Collection whose elements attribute have to be update
     * @param map map used to update the <code>valueObjectsCollection</code>
     * @param valueObjectKeyAttributeName name of the attribute of the generic element of the collection <code>valueObjectsCollection</code>, whose value has to match with an entry's key of  <code>map</code>,
     *                                    to update the same attribute <code>valueObjectKeyAttributeName</code> of the same element with the entry value.</br>
     * @throws ApplicationServiceException -
     *       <code>map</code> is null.</br>
     *      if  <code>valueObjectKeyAttributeName</code>  is null, or empty or blank characters string.</br>
     */
    public void  updateCollectionWithMap(Collection valueObjectsCollection, Map map, String valueObjectKeyAttributeName) throws ApplicationServiceException;

    

    /**
     * This method adds the <code>pInstance</code> to the collection <code>valueObjectsCollection</code> if not yet present in it (The comparison is done with <code>pAttributeNames</code>).
     * See {@link #isInCollection(Collection valueObjectsCollection, Object pInstance, String[]  pAttributeNames)}.</br>
     * If <code>pAttributeNames</code> is null, in its place will be considered an array holding the primary key fields names of <code>pInstance</code>
     *
     * @param valueObjectsCollection Collection to be added <code>pInstance</code> to.
     * @param pInstance Element to add to <code>valueObjectsCollection</code>
     * @param pAttributeNames used to compare <code>pInstance</code> to the collection <code>valueObjectsCollection</code> to decide if add or not.
     * @return true if <code>pInstance</code> is added.
     * @throws ApplicationServiceException - If  <code>valueObjectsCollection</code> or <code>pInstance</code> is null.</br>
     *       If <code>pAttributeNames</code>  is null.</br>
     */
    public boolean addToCollection(Collection valueObjectsCollection, Object pInstance, String[] pAttributeNames) throws ApplicationServiceException;



    /**
     * This method adds all the elements of <code>valueObjectsCollectionToAdd</code> not yet present in the collection <code>valueObjectsCollection</code> to
     * the same collection <code>valueObjectsCollection</code>.</br>. The comparison to establish if an element is present or not in <code>valueObjectsCollectionToAdd</code>
     * is done with the Comparator <code>pAttributeNames</code>.</br>
     * Note that if are equals element in <code>valueObjectsCollectionToAdd</code>, just the first one in the iteration will be added, of course if not yet present, to the collection <code>valueObjectsCollection</code>
     * If  <code>valueObjectsCollectionToAdd</code> no job is done and false is returned.</br>
     * @param valueObjectsCollection  Collection to be added the elements of <code>valueObjectsCollectionToAdd</code> to. It can' be null.
     * @param valueObjectsCollectionToAdd Elements to add to <code>valueObjectsCollection</code>. If null no job is done and false is returned.</br>
     * @param pAttributeNames used to compare <code>valueObjectsCollectionToAdd</code> elements to the <code>valueObjectsCollection</code> elements to decide which add and which not.
     * @return true if at least one elements is added
     * @throws ApplicationServiceException  - If  <code>valueObjectsCollection</code> is null
     */
    public boolean addAllToCollection(Collection valueObjectsCollection, Collection  valueObjectsCollectionToAdd, String[] pAttributeNames) throws ApplicationServiceException;


    /**
     * This method looks for all the elements of <code>valueObjectsCollectionToAdd</code> that have the value of the attribute <code>pAttributeNameMapKey</code> equals to
     * some key mapped to a not null value in the <code>map</code>, and adds  each one of such elements to the collection  <code>valueObjectsCollection</code>,
     * if such collection doesn't hold yet an element with the same value for the attribute <code>pAttributeNameMapKey</code> of the element being processed.</br>
     * Note that the value of the attribute <code>pAttributeNameMapKey</code> is compared to the keys of the <code>map</code> and not with the values mapped to the keys.</br>
     * If <code>map</code> is null , nothing is done and false is returned
     * @param valueObjectsCollection collection to add elements to
     * @param map Map which keys that are mapped to not null values are used to compare the values of the attribute <code>pAttributeNameMapKey</code> of the elements of <code>valueObjectsCollectionToAdd</code>
     * @param valueObjectsCollectionToAdd collection which elements which the values of the attribute <code>pAttributeNameMapKey</code> is equals to at least one of the keys of <code>map</code>
     *      mapped to not null values, are added to <code>valueObjectsCollection</code>.
     * @param pAttributeNameMapKey name of the attribute of the elements of <code>valueObjectsCollectionToAdd</code> and <code>valueObjectsCollection</code> used to compare
     * @return  true if some element is added to  <code>valueObjectsCollection</code>, false otherwise.</br>
     * @throws ApplicationServiceException -
     *      if <code>valueObjectsCollection</code> is null
     */
    public boolean addAllToCollection(Collection valueObjectsCollection, Map map, Collection  valueObjectsCollectionToAdd, String pAttributeNameMapKey) throws ApplicationServiceException;


    /**
     * This method compares all the objects of the collection <code>valueObjectsCollection</code> with the object <code>toRemovePInstance</code> comparing the attributes <code>pAttributeNames</code>.</br>
     * and removes from <code>valueObjectsCollection</code> all the matching elements.</br>
     * If <code>valueObjectsCollection</code> is null nothing is done and false is returned.</br>
     * If <code>pAttributeNames</code> is null, in its place will be used the primary key fields of <code>toRemovePInstance</code>.</br>
     * @param valueObjectsCollection  collection to remove elements from.
     * @param toRemovePInstance  Object to compare  <code>valueObjectsCollection</code> elements with.
     * @param pAttributeNames  attributes names used to compare <code><code></code> with the elements of <code>valueObjectsCollection</code>.
     * @return true if some element is removed, or false if not.
     * @throws ApplicationServiceException - if <code>toRemovePInstance</code> is null 
     */
    public boolean removeFromCollection(Collection valueObjectsCollection, Object toRemovePInstance, String[] pAttributeNames) throws ApplicationServiceException;


    /**
     * This method removes from the collection <code>valueObjectsCollection</code> all the elements which attributes String[] pAttributeNames assume the same values
     * of the same attributes of at least one element of <code>valueObjectsCollectionToRemove</code>.</br>
     * If some element is removed it will be returned true, otherwise false.</br>
     * If <code>valueObjectsCollectionToRemove</code> is null, nothing is done and false is returned.</br>
     *
     * @param valueObjectsCollection Collection to remove element from
     * @param valueObjectsCollectionToRemove collection holding the elements to remove from <code>valueObjectsCollection</code>.
     * @param pAttributeNames attributes used to compare the elements of  <code>valueObjectsCollection</code> with the elements of  <code>valueObjectsCollectionToRemove</code>.
     * @return true if some element is removed from <code>valueObjectsCollection</code>, false otherwise.
     * @throws ApplicationServiceException - if <code>valueObjectsCollection</code> is null
     */
    public boolean removeAllFromCollection(Collection valueObjectsCollection, Collection  valueObjectsCollectionToRemove, String[] pAttributeNames) throws ApplicationServiceException;


    /**
     * This method removes from the collection  <code>valueObjectsCollection</code>  all the elements not present in the collection
     * <code>toRetainValueObjectsCollection</code> .</br>
     * in other words each element of <code>valueObjectsCollection</code> is searched in <code>toRetainValueObjectsCollection</code>,  comparing with the attributes
     * <code>pAttributeNames</code>, and if it is not found, it is removed from <code>valueObjectsCollection</code>.</br>
     * If <code>valueObjectsCollection</code> is null nothing is done and false is returned.</br>
     * If <code>toRetainValueObjectsCollection</code> is null or empty, if  <code>valueObjectsCollection</code> is empty a false is returned and nothing is done
     * otherwise <code>valueObjectsCollection</code> is cleared and true is returned.</br>
     *
     * @param valueObjectsCollection  collection to remove elements from.
     * @param toRetainValueObjectsCollection collection holding the elements that have not to be removed from <code>valueObjectsCollection</code>
     * @param pAttributeNames attributes  used to compare <code>valueObjectsCollection</code> elements with <code>toRetainValueObjectsCollection</code> elements
     * @return true if some element is removed, or false if not.
     * @throws ApplicationServiceException - if <code>pAttributeNames</code> is null
     */
    public boolean retainAllInCollection(Collection valueObjectsCollection, Collection toRetainValueObjectsCollection, String[] pAttributeNames) throws ApplicationServiceException;


    /**
     * This method removes from the collection <code>valueObjectsCollection</code> all his elements for which the value of their attribute <code>pAttributeName</code>
     * used as key in <code>map</code> return a null value.</br>
     * It will be returned true is some element is removed, and false otherwise.</br>
     * If <code>valueObjectsCollection</code> is null , nothing is done and false will be returned.</br>
     * If <code>map</code> is null, all the elements will be removed from <code>valueObjectsCollection</code> and true will be returned.</br>
     *
     * @param valueObjectsCollection collection to remove elements from.
     * @param map  map to use to check if the value of the attribute  <code>pAttributeName</code> of an element of <code>valueObjectsCollection</code>, used as key, is mapped to a null value or not
     * @param pAttributeName attribute which value is used as key of <code>map</code>
     * @return  true if some element is removed, and false otherwise.</br>
     * @throws ApplicationServiceException for any trouble
     */
    public boolean retainAllInCollection(Collection valueObjectsCollection, Map map, String pAttributeName) throws ApplicationServiceException;


    /**
     *
     * This method creates and returns a collection holding leaves of a tree of value objects, or of a collection of trees of value objects. Not all the leaves will be added to the
     * collection to be returned, but just the leaves that have the depth specified by the number of the dot separated tokens of the input string parameter <code>path</code>.</br>
     * The value object root of the tree, or the collection of the value object roots of the trees, is represented by the input parameter
     * <code>valueObjectOrCollection</code>, that, as his name states, can be a value object or a collection of value objects.</br>
     * <code>valueObjectOrCollection</code> (or each element of it, if it is a collection) must have an attribute named as the first token
     * of <code>path</code> (the separator is the dot), and such attribute represents a value object or an other collection of value objects. In both cases, these value objects,
     * must have in turn an attribute named as the second token of <code>path</code>, and so on.</br>
     * We can say that the two input parameters  <code>valueObjectOrCollection</code> and <code>path</code>  represent a tree of value objects or a collection of
     * trees of value objects (if <code>valueObjectOrCollection</code> is a collection), where the nodes are value objects and the branches
     * are tokens of <code>path</code>. </br>
     * Considering the root (or roots) the level 1, each node value object of level <code>i</code>, let's call it <code>NODE-N</code>, must have an attribute named as the <code>i-th</code> token
     * of <code>path</code>. As we saw such attribute value can be null, or can be a value object, or a not empty collection or an empty collection.
     * If the attribute value is null or empty collection, <code>NODE-N</code> doesn't have any child, so it is a leaf, but it won't be added to the collection to return.
     * If the attribute value is a value object, this is the only child of <code>NODE-N</code>,
     * and it is joined to <code>NODE-N</code> by a branch labeled as the <code>i-th</code> token of <code>path</code>.  If the attribute value is a not empty collection
     * of value objects, all of them are children of <code>NODE-N</code>, and are joined to <code>NODE-N</code> by a branch labeled as the <code>i-th</code> token of <code>path</code>.</br>
     * All the value object that are leaves and that are joined to their parent by the last token of <code>path</code> will be the elements (and the only elements) of the collection
     * to be returned.</br>
     * If no one of the leaves of the tree is suitable to be added to the collection (no one is depth enough) to return an empty collection is returned
     * </br>
     * If  <code>valueObjectOrCollection</code> is null, or <code>path</code> is null or empty string or blank characters string, a null is returned.</br>
     * If  <code>valueObjectOrCollection</code> is an empty collection, an empty collection is returned.</br>
     *
     * @param valueObjectOrCollection this parameter is the value object root of the tree of value objects, or the collection of value object roots of the trees of value objects
     * @param path dot separated list of the attributes that represent the path from the root to the leaves
     * @return a collection holding leaves of depth of the number of tokens of <code>path</code>
     * @throws ApplicationServiceException for any trouble
     *
     * @deprecated use {@link BeanCollectionUtils#getTreeLeaves(Object valueObjectOrCollection, String path)}
     */
    public Collection getTreeLeaves(Object valueObjectOrCollection, String path) throws ApplicationServiceException ;

    /**
     * This method searches in the the collection <code>valueObjectsCollection</code> an element which attributes whose names are specified in  <code>pAttributeNames</code>
     * assumes the same values that the same attributes assume in <code>pInstance</code>.</br>
     * If such element is found this method returns true, otherwise returns false.<br>
     * If <code>pAttributeNames</code> is null, in its place will be considered an array holding the primary key fields names of <code>pInstance</code>
     * This method returns true if comparing <code>pInstance</code> to all the elements of the collection <code>valueObjectsCollection</code> with <code>pAttributeNames</code> values
     * at least a matching element is found.</br>
     * If <code>valueObjectsCollection</code> is null or empty, false is returned.</br>
     *
     * @param valueObjectsCollection Collection where to look for  <code>pInstance</code>. It can't be null
     * @param pInstance  element to search in  <code>valueObjectsCollection</code>
     * @param pAttributeNames used to compare <code>pInstance</code> to all the elements of the collection <code>valueObjectsCollection</code>.
     * @return true if <code>pInstance</code> is in <code>valueObjectsCollection</code>, and false if not.
     * @throws ApplicationServiceException - If <code>pInstance</code> is null
     */
    public boolean isInCollection(Collection valueObjectsCollection, Object pInstance, String[] pAttributeNames) throws ApplicationServiceException;


    /**
     * This method has the same behavior of {@link #isInCollection(Collection valueObjectsCollection, Object pInstance, String[] pAttributeNames)}
     * where <code>pAttributeNames</code> is null
     * @param valueObjectsCollection valueObjectsCollection Collection where to look for  <code>pInstance</code>. It can't be null
     * @param pInstance lement to search in  <code>valueObjectsCollection</code>
     * @return true if <code>pInstance</code> is in <code>valueObjectsCollection</code>, and false if not.
     * @throws ApplicationServiceException - If <code>pInstance</code> is null
     */
    public boolean isInCollection(Collection valueObjectsCollection, Object pInstance) throws ApplicationServiceException;



    /**
     * This method creates and returns a new collection instance, which implementation class is <code>collectionImplClass</code>, and whose elements class is <code>realClass</code>,
     * and its elements are created using the tree nodes of a tree of value objects that is identified by the two input parameter <code>pInstance</code> and <code>path</code>.</br>
     * The root of the tree is <code>pInstance</code>. The input parameter <code>path</code> is a dot separated list of attributes. The first attribute must be an attribute
     * of <code>pInstance</code>, that can be a  value object or a collection of value objects. If it is a value object, this one must have an attribute named as the second
     * attribute of <code>path</code>, that in turn can be a value object or a collection of value objects, while if it is a collection of value object, each of them must have an attribute named as the second
     * attribute of <code>path</code>, that in turn can be a value object or a collection of value objects. Applying this rule recursively for all the attributes of path, the tree is identified.
     * For each walk from the root to each leaf that is the end of <code>path</code> (no null value object or null or empty collection has forbidden to reach the end of the dot separated list of attributes)
     * a new instance of <code>realClass</code> is created and added to the collection to return.</br>
     * Some, or all, of the attributes of the created instance of <code>realClass</code> is set with values that are collected during the corresponding walk from the root to the leaf.
     * The attributes of <code>realClass</code> to set are the ones specified by the input parameter <code>pkNames</code>, and the input parameter <code>nodeTargetPAttributeNames</code>.</br>
     * If <code>pkNames</code> is null in his place will be considered the primary key attributes names of <code>realClass</code> specified in the mapping file (i.e. repository.xml for Ojb).</br>
     * The values to use to set the <code>realClass</code>  attributes specified by <code>groupedPkNames</code>, are the primary key values of all the nodes on the walk from the root (<code>pInstance</code>) to the specific leaf,
     * but for each node are discarded the inverse foreign keys to his parent, if the node belongs to a collection
     * of the parent (the attribute of <code>path</code> used for the parent's children is a collection), and are discarded the foreign key to his child, if the link to his child is an attribute holding a value object and not a collection.</br>
     * The input parameter <code>nodeTargetPAttributeNames</code> specifies other attributes names of <code>realClass</code>, that will be set with the values of the attributes of the value objects of the walk, attributes
     * whose names are specified by the input parameter <code>nodeSourcePAttributeNames</code>.
     * Both <code>nodeTargetPAttributeNames</code> and <code>nodeSourcePAttributeNames</code> are arrays of arrays of attributes names; the first one is of arrays of the <code>realClass attributes names</code>,
     * while the second one is of arrays of the node of the tree attributes names.</br>
     * For a node of depth <code>i</code> (considering the root of depth 0) on the path from the root to the leaf, the attributes names in the
     * array  <code>nodeTargetPAttributeNames[depth]</code>  of the corresponding instance of  <code>realClass</code> will be set with the values of the attributes of the current node whose names are specified in <code>nodeSourcePAttributeNames[depth]</code>
     * if <code>nodeTargetPAttributeNames[depth]</code>  and <code>nodeSourcePAttributeNames[depth]</code> are not null.
     * Once the attributes of <code>pkNames</code> and of all arrays of <code>nodeTargetPAttributeNames</code> for an instance of <code>realClass</code> are set,
     * all the attribute of this instance whose names are in <code>pAttributeNames</code> will be set with the corresponding values of <code>valuesArray</code>.</br>
     * </br>
     * The input parameter <code>nodeSourcePAttributeNames</code> and <code>nodeTargetPAttributeNames</code> are both null or both not null otherwise an ApplicationServiceException is thrown.</br>
     * If they are not null must have the same length, that must be the number of token of <code>path</code> more 1 otherwise an ApplicationServiceException is thrown.</br>
     * For each level (depth) of the tree, <code>nodeSourcePAttributeNames[depth]</code> and <code>nodeTargetPAttributeNames[depth]</code> must be bot null or both not null, and
     * if not null must have the same length otherwise an ApplicationServiceException is thrown.</br>
     * When the method reaches a leaf, the built array of primary key values must have reached the same length of <code>pkNames</code> otherwise an ApplicationServiceException is thrown.</br>
     * <code>pAttributeNames</code> and <code>valuesArray</code> have to be both null or both not null, and if they are not null must have the same length otherwise an ApplicationServiceException will be thrown..</br>
     * If <code>collectionImplClass</code> or <code>realClass</code> are null an ApplicationServiceException is thrown.
     * If <code>pInstance</code> is null, a null is returned.</br>
     * If <code>path</code> is null, it will be consdered empty string (tree with just the root.)</br>
     *
     *
     * @param collectionImplClass Implementation class of the collection to create and return. It can be null.
     * @param realClass  class of the elements of the collection to create and return. It can be null.
     * @param pkNames arrays holding the attribute names of <code>realClass</code> that will be set with key values of the nodes. If null in his place will be considered the primary key attributes names of <code>realClass</code> specified in the mapping file (i.e. repository.xml for Ojb).
     * @param pInstance root of the tree. If null a null is returned
     * @param path  dot separated list of attributes that specifies the tree of root <code>pInstance</code>. If null it will be considered empty string.
     * @param nodeSourcePAttributeNames array of arrays of attributes names. For a node of a depth, <code>nodeSourcePAttributeNames[depth]</code> is an array holding the attributes names of the node
     *                                  which values have to be used to set the attributes of an instance of  <code>realClass</code> whose names are in <code>nodeTargetPAttributeNames[depth]</code>.
     * @param nodeTargetPAttributeNames array of arrays of attributes names. For a node of a depth, <code>nodeTargetPAttributeNames[depth]</code> elements
     *                                   have to be set with the values of the attributes in <code>nodeSourcePAttributeNames[depth]</code> of some node in the tree.
     * @param pAttributeNames names of <code>realClass</code> attributes to populate with values in <code>valuesArray</code>
     * @param valuesArray values to use to populate <code>realClass</code> attributes in <code>pAttributeNames</code>.
     * @return   A collection instance of <code>collectionImplClass</code> which items are instances of <code>realClass</code>
     * @throws ApplicationServiceException -
     *      <code>nodeSourcePAttributeNames</code> and <code>nodeTargetPAttributeNames</code>  must be both null or both not null, and
     *      ifthey are not null must have the same length, that must be the number of token of <code>path</code> more 1.</br>
     *      For each level (depth) of the tree, <code>nodeSourcePAttributeNames[depth]</code> and <code>nodeTargetPAttributeNames[depth]</code> must be bot null or both not null, and
     *      if not null must have the same length.</br>
     *      <code>pAttributeNames</code> and <code>valuesArray</code>  must be both null or both not null, and
     *      ifthey are not null must have the same length
     *      When the method reaches a leaf, the built array of primary key values must have reached the same length of <code>pkNames</code>.</br>
     *      If <code>collectionImplClass</code> or <code>realClass</code> are null.</br>
     */
    public Collection createCollectionWithTreeNodes(Class collectionImplClass, Class realClass, String[] pkNames, Object pInstance,  String path, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames,  String[] pAttributeNames,Object[] valuesArray) throws ApplicationServiceException;


    /**
     * This method creates a tree of value object, using as source of information the items of the collection input parameter <code>valueObjectsCollection</code>.</br>
     * The root of the tree is <code>pInstance</code>. The input parameter <code>path</code> is a dot separated list of attributes. The first attribute must be an attribute
     * of <code>pInstance</code>, which class can be a of a value object or of a collection of value objects. If it value object class, this one must have an attribute named as the second
     * attribute of <code>path</code>, which class in turn can be of a value object or of a collection of value objects, while if it is a collection of value object, each of them must have an attribute named as the second
     * attribute of <code>path</code>, which class in turn can be of a value object or of a collection of value objects. Applying this rule recursively for all the attributes of path, the tree structure is identified.</br>
     * So note that all the nodes of the same level of the tree are instances of the same class.</br>
     * </br>
     * This method will select all the distinct sets of values that the attributes specified by  <code>groupedPkNames[0]</code> assume in the items of <code>valueObjectsCollection</code>.</br>
     * For each one of these sets this method will creates a new instance of the class of the items of the collection held by the attribute of <code>pInstance</code> specified by
     * the first attribute of <code>path</code>, if such attribute specifies a collection, or creates a new instance of the class of the value object of the the attribute of <code>pInstance</code> specified by
     * the first attribute of <code>path</code>, if it specifies a simple value object.</br>
     * If the first attribute of <code>path</code> specifies an attribute of <code>pInstance</code> that is a value object and not a collection, there must be only one distinct set of values that the attributes specified by  <code>pkNames[0]</code>
     * assume in the items of <code>valueObjectsCollection</code>, otherwise an ApplicationServiceException is thrown.</br>
     * For each one of the created instances,its primary key fields will be set with the set of the values of <code>valueObjectsCollection</code> that is being processed.</br>
     * If the first attribute of path of <code>pInstance</code> is a collection all the inverse foreign key of the elements of  the collection referring to <code>pInstance</code>
     * will be set with the key values of  <code>pInstance</code>, while if the first attribute of path of <code>pInstance</code> is a value object,
     * the foreign keys of  <code>pInstance</code> referring to such value objects will set with the key values of the value object.</br>
     * Moreover, the new created nodes must have attributes named as specified in nodePAttributeNames[0], and such attributes will be set with the corresponding values of nodeValuesArray[0]
     * For each one of the created child nodes, the method will be called recursively, where the new   <code>pInstance</code> is the child, and <code>path</code> will be the same with
     * the first attribute excluded, and  as <code>valueObjectsCollection</code> will be passed the same <code>valueObjectsCollection</code> filtered
     * so to have just the elements that have the attributes groupedPkNames[depth] equals to the key values of the child being passed as <code>pInstance</code>.</br>
     * In the generic recursion, will be used the arrays <code>groupedPkNames[depth]</code> <code>nodePAttributeNames[depth]</code> <code>nodeValuesArray[depth]</code>
     * where <code>depth</code> is the depth of <code>pInstance</code>, considering the root of depth 0.</br>
     * </br>
     * If <code>valueObjectsCollection</code> is null or empty the method return.</br>
     * If <code>path</code> is empty string or blank characters string the method return.</br>
     * If <code>groupedPkNames</code> is null, as <code>groupedPkNames[depth]</code> will be considered the primary key fields of the class of nodes of level  <code>depth+1</code>
     * where the root is considered to be of level 0; even if groupedPkNames is not null, some <code>groupedPkNames[depth]</code> can be null, and in such case, the  same rule is applied.</br>
     * If <code>groupedPkNames</code> is not null, his length must be greater or equal than the number of tokens of <code>path</code>, otherwise an ApplicationServiceException is thrown;
     * if strictly greater, the ones left over, will be ignored.</br>
     * For each depth <code>groupedPkNames[depth]</code> must be greater or equals than the number of the key fields of the node class of the level  <code>depth+1</code> (the over ones will be ignored)
     * otherwise an ApplicationServiceException is thrown.</br>
     *
     *
     * @param valueObjectsCollection Collection of value objects used to create the tree of value objects. If null or empty the method returns without doing nothing.
     * @param pInstance  root of the tree. It can't be null.
     * @param path dot separated list of attributes, defining the tree with <code>pInstance</code>
     * @param groupedPkNames array of arrays of attributes names that specifies how to group the <code>valueObjectsCollection</code> item attributes to constitute the primary keys of the nodes of the tree to create.</br>
     * @param nodePAttributeNames array of arrays of attributes names of the children of <code>pInstance</code> to create, attributes to populate with values in <code>nodeValuesArray</code>
     * @param nodeValuesArray  array of arrays of values to use to populate the children of <code>pInstance</code> to create attributes in <code>nodePAttributeNames</code>.
     * @throws ApplicationServiceException if <code>pInstance</code> or <code>path</code> are null.</br>
     *      If <code>groupedPkNames</code> is not null, and his length is less than the number of tokens of <code>path</code>.</br>
     *      If <code>groupedPkNames</code> is not null and for some depth <code>groupedPkNames[depth]</code> has length less than the number of the key fields of the node class of the level  <code>depth+1</code> where the root is considered to be of level 0.</br>
     *      If <code>nodePAttributeNames</code> and <code>nodeValuesArray</code> are not both null or both not null.</br>
     *      If <code>nodePAttributeNames</code> and <code>nodeValuesArray</code> are both not null and they don't have the same length.</br>
     *      If <code>nodePAttributeNames</code> and <code>nodeValuesArray</code> are both not null, have the same length, but the length is less than the number of tokens of <code>path</code> .</br>
     *      If <code>nodePAttributeNames</code> and <code>nodeValuesArray</code> are both not null, have the same length, that is greater or equals  than the number of tokens of <code>path</code>,
     *      but for some depth, <code>nodePAttributeNames[depth]</code> <code>nodePAttributeNames[depth]</code> are not both null and  not both not null, or if both not null, they don't have  the same length   .</br>
     */
    public void createValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray) throws ApplicationServiceException;



    /**
     *
     * This method adds nodes to a tree of value object, using as source of information the items of the collection input parameter <code>valueObjectsCollection</code>.</br>
     * The root of the tree is <code>pInstance</code>. The input parameter <code>path</code> is a dot separated list of attributes. The first attribute must be an attribute
     * of <code>pInstance</code>, which class can be a of a value object or of a collection of value objects. If it is a value object class, this one must have an attribute named as the second
     * attribute of <code>path</code>, which class in turn can be of a value object or of a collection of value objects, while if it is a collection of value object, each of them must have an attribute named as the second
     * attribute of <code>path</code>, which class in turn can be of a value object or of a collection of value objects. Applying this rule recursively for all the attributes of path, the tree structure is identified.</br>
     * So note that all the nodes of the same level of the tree are instances of the same class.</br>
     * This method will select all the distinct sets of values that the attributes specified by  <code>groupedPkNames[0]</code> assume in the items of <code>valueObjectsCollection</code>.</br>
     * Such sets of values will be the key values of the children of <code>pInstance</code> to add to it.
     * </br>
     * If the first attribute of <code>path</code> specifies the name of an attribute of  <code>pInstance</code> that is a value objects, there must be just
     * one distinct set of values, otherwise an ApplicationServiceException is thrown; if such attribute of <code>pInstance</code> is null or the primary keys values
     * of the value object represented by such attribute are not equals to the distinct set of values, the attribute of  <code>pInstance</code> is replaced
     * by a new instance of the class of the attribute that have as primary key values the set of distinct values. Moreover for such new instance the attributes named as in <code>nodePAttributeNames[0]</code> will be set
     * with the corresponding values of  <code>nodeValuesArray[0]</code> (of course if they are not null); in both cases the foreign key fields
     * of <code>pInstance</code> referring to the value object child, are set with the primary key values of the same child. (It could be that even if the right
     * child was already existing, the foreign key fields to it were not properly set). </br>
     * If the first attribute of <code>path</code> specifies the name of an attribute of  <code>pInstance</code> that is a collection, if such collection is null
     * a new empty one is created (using the implementation specified in the mapping file, i.e repository.xml for Ojb), and the attribute of  <code>pInstance</code>
     * will be set to it.</br>
     * For each one of the distinct sets of values of the attributes, whose names are in <code>groupedPkNames[0]</code>, of the items of <code>valueObjectsCollection</code>
     * if in the collection of the children of <code>pInstance</code> is not yet present  a value object which primary key values are  equals to the distinct set of values
     * being processed, such value object will be created (a new instance of the class of the children of <code>pInstance</code>, class that should be mapped
     * in the mapping file, i.e repository.xml for Ojb) with key primary values set to the values of the distinct set of values being processed.
     * Moreover for such new instance the attributes named as in <code>nodePAttributeNames[0]</code> will be set
     * with the corresponding values of  <code>nodeValuesArray[0]</code> (of course if they are not null); then the new created instances will be added
     * to the collection of the children of <code>pInstance</code>.</br>
     * For all the children of <code>pInstance</code>, the inverse foreign key field referring to the parent <code>pInstance</code> will be set with the key values
     * of <code>pInstance</code>, this is done for the new added ones and for the already existing children, as it could be that such fields, for the already existing children,
     * were not properly set.</br>
     * For all the the children of <code>pInstance</code>, in both cases that the first attribute of <code>path</code> specifies a value object or a collection,
     * this method will be called recursively, where the new   <code>pInstance</code> is the child, and <code>path</code> will be the same with
     * the first attribute excluded, and  as <code>valueObjectsCollection</code> will be passed the same <code>valueObjectsCollection</code> filtered
     * so to have just the elements that have the attributes groupedPkNames[1] equals to the key values of the child being passed as <code>pInstance</code>.</br>
     * In the generic recursion, will be used the arrays <code>groupedPkNames[depth]</code> <code>nodePAttributeNames[depth]</code> <code>nodeValuesArray[depth]</code>
     * where <code>depth</code> is the depth of <code>pInstance</code>, considering the root of depth 0.</br>
     * The recursion will end at the end of <code>path</code> .</br>
     * </br>
     * If <code>valueObjectsCollection</code> is null or empty the method return.</br>
     * If <code>path</code> is empty string or blank characters string the method return.</br>
     * If <code>groupedPkNames</code> is null, as <code>groupedPkNames[depth]</code> will be considered the primary key fields of the class of nodes of level  <code>depth+1</code>
     * where the root is considered to be of level 0; even if groupedPkNames is not null, some <code>groupedPkNames[depth]</code> can be null, and in such case, the  same rule is applied.</br>
     * If <code>groupedPkNames</code> is not null, his length must be greater or equal than the number of tokens of <code>path</code>, otherwise an ApplicationServiceException is thrown;
     * if strictly greater, the ones left over, will be ignored.</br>
     * For each depth <code>groupedPkNames[depth]</code> must be greater or equals than the number of the key fields of the node class of the level  <code>depth+1</code> (the over ones will be ignored)
     * otherwise an ApplicationServiceException is thrown.</br>
     *
     * @param valueObjectsCollection  Collection of value objects used to create the value objects nodes to add to the tree. If null or empty the method returns.
     * @param pInstance root of the tree. It can't be null.
     * @param path dot separated list of attributes, defining the tree with <code>pInstance</code>
     * @param groupedPkNames array of arrays of attributes names that specifies how to group the <code>valueObjectsCollection</code> item attributes to constitute the primary keys of the nodes to add to the the tree if not yet present.</br>
     * @param nodePAttributeNames  array of arrays of attributes names of the children of <code>pInstance</code> to create and add to the tree, attributes to populate with values in <code>valuesArray</code>
     * @param nodeValuesArray  array of arrays of values to use to populate the children of <code>pInstance</code> attributes in <code>nodePAttributeNames</code>.
     * @throws ApplicationServiceException - if <code>pInstance</code> or <code>path</code> are null.</br>
     *      If <code>groupedPkNames</code> is not null, and his length is less than the number of tokens of <code>path</code>.</br>
     *      If <code>groupedPkNames</code> is not null and for some depth <code>groupedPkNames[depth]</code> has length less than the number of the key fields of the node class of the level  <code>depth+1</code> where the root is considered to be of level 0.</br>
     *      If <code>nodePAttributeNames</code> and <code>nodeValuesArray</code> are not both null or both not null.</br>
     *      If <code>nodePAttributeNames</code> and <code>nodeValuesArray</code> are both not null and they don't have the same length.</br>
     *      If <code>nodePAttributeNames</code> and <code>nodeValuesArray</code> are both not null, have the same length, but the length is less than the number of tokens of <code>path</code> .</br>
     *      If <code>nodePAttributeNames</code> and <code>nodeValuesArray</code> are both not null, have the same length, that is greater or equals  than the number of tokens of <code>path</code>,
     *      but for some depth, <code>nodePAttributeNames[depth]</code> <code>nodePAttributeNames[depth]</code> are not both null and  not both not null, or if both not null, they don't have  the same length   .</br>
     */
    public void addToValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray) throws ApplicationServiceException;


     /**
     * This method retrieves all the null references of each element of the collection <code>valueObjectsCollection</code>.<br>
     * If  <code>valueObjectsCollection</code> is null nothing is done.</br>
     * </br>
     * @param valueObjectsCollection collection of value objects for whose elements have to be retrieved the null references. If  null nothing is done.</br>
     * @throws ApplicationServiceException for any trouble
     */
    public void retrieveAllNullReferencesInCollection(Collection valueObjectsCollection) throws ApplicationServiceException;



    /**
     * This method creates and returns a new collection of relationship between an instance of <code>realClass</code> which key values are specified by the input parameter <code>keyValues</code>,
     * and the value objects of the collection <code>valueObjectsCollection</code>.</br>
     * If <code>valueObjectsCollection</code> is null, in its place it will be considered the collection of all the elements of the class
     * specified in the mapping file (i.e. repository.xml for Ojb ) by the path <code>collectionName.pAttributeName</code> starting from <code>realClass</code>, elements present in the underlying media store.</br>
     * If <code>valueObjectsCollection</code> is still null, a null is retruned.</br>
     * code>realClass</code> must have an attribute named <code>collectionName</code> that is a collection, and the class of the items of such collection
     * must be of the same class of the elements of <code>valueObjectsCollection</code>, and must have an attribute named <code>pAttributeName</code>.</br>
     * In the mapping file must be specified which is the collection implementation class of the relationship collection, that is the one of the attribute  <code>collectionName</code>,
     * of the class <code>realClass</code>, and the class of the items of such collection.</br>
     * For each element of the collection <code>valueObjectsCollection</code> will be created a new instance of the class of the  elements of the relationship collection of the attribute <code>collectionName</code>;
     * the inverse foreign  key fields of such instance to the class <code>realClass</code> will be populated with the input parameter <code>keyValues</code>,
     * and the foreign key fields to the elements of <code>valueObjectsCollection</code> being precessed will be set to its key values;
     * moreover the attribute <code>pAttributeName</code> of the created instance will be set to the value object being processed. At the end,
     * if <code>pAttributeNames</code> and  <code>valuesArray</code> are not null, the attributes <code>pAttributeNames</code> of the new created instance are set with values in <code>valuesArray</code>.</br>
     * Note that, being the new instance a relationship between an instance of <code>realClass</code> which key values are specified by the input parameter <code>keyValues</code> and the value object being processed,
     * the inverse foreign key to the instance of <code>realClass</code>,
     * joined with the foreign key to the value object being processed must be the primary key fields of the elements of the collection  of the attribute <code>collectionName</code>.
     *
     *
     * @param realClass class of the instance to be related
     * @param keyValues key values of the instance to be related
     * @param collectionName name of the attribute of <code>realClass</code> holding the collection of the relationships
     * @param pAttributeName property name of the generic elements of the collection of the relationships representing the value object which the instance of <code>realClass</code> has to be related to
     * @param valueObjectsCollection Collection of the value objects which  the instance of <code>realClass</code>  has to be related to. If it is null all instance in the media store will be used
     * @param pAttributeNames  attributes of the generic value object of the collection of the relationships that has to be populated with <code>valuesArray</code>
     * @param valuesArray values to use to populate <code>pAttributeNames</code>
     * @return  a new collection of relationship.
     * @throws ApplicationServiceException -
     *      If <code>pAttributeNames</code> and <code>valuesArray</code> are not both null or both not null, and if they are not null don't have the same length.</br>
     *      If <code>keyValues</code> is null or has not the same length of the inverse foreign fields of the relationship collection to <code>realClass</code>
     *
     */
    public Collection  createRelationshipCollection(Class realClass, Object[] keyValues, String collectionName, String pAttributeName, Collection valueObjectsCollection,  String[] pAttributeNames,Object[] valuesArray)throws ApplicationServiceException;


    /**
     * This method has the same behavior of the method
     * {@link #addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, String[][] nodePAttributeNames, Object[][] nodeValuesArray)},
     * but in place of the arrays <code>nodeSourcePAttributeNames</code>, <code>nodeTargetPAttributeNames</code>, <code>nodePAttributeNames</code> and <code>nodeValuesArray</code>
     * are used the collections <code>nodeSourcePAttributeNamesCollection</code>, <code>nodeTargetPAttributeNamesCollection</code>, <code>nodePAttributeNamesCollection</code> and <code>nodeValuesArrayCollection</code>
     * </br>
     * @param sourceRootVO Root of the source tree. It can't be null.
     * @param targetRootVO Root of the target tree. It can't be null.
     * @param sourceTreePath dot separated list of attributes defining the source tree. It can't be null.
     * @param targetTreePath dot separated list of attributes defining the target tree. It can't be null.
     * @param nodeSourcePAttributeNamesCollection the <code>i-th</code> element of this collection is an array of strings that are the attributes names of the children of the nodes of level <code>i</code> of the source tree
     * @param nodeTargetPAttributeNamesCollection the <code>i-th</code> element of this collection is an array of strings that are the attributes names of the children of the nodes of level <code>i</code> of the target tree
     * @param nodePAttributeNamesCollection the <code>i-th</code> element of this collection is an array of strings that are the attributes names of the created instances to add to the children of the nodes of level <code>index</code> of the target tree
     *              to be populated with the array that is the element of the position <code>i-th</code> of the collection<code>nodeValuesArrayCollection</code>.
     * @param nodeValuesArrayCollection the <code>i-th</code> element of this collection is an array of objects that are used to populate the attributes of the array of strings that is the elements of position <code>i-th</code> of the collection <code>nodePAttributeNamesCollection</code> of the created instances children of the nodes of level <code>i</code> of the target tree.
     * @return  true if the target tree is modified, false otherwise.
     * @throws ApplicationServiceException -
     *      If  <code>sourceRootVO</code> or <code>targetRootVO</code> or <code>sourceTreePath</code> or <code>targetTreePath</code> are null.</br>
     *      If  <code>sourceTreePath</code> and <code>targetTreePath</code> are not both empty strings or not both not empty strings.</br>
     *      If  <code>nodeSourcePAttributeNamesCollection</code> and  <code>nodeTargetPAttributeNamesCollection</code> are not null, and don't have the same size.</br>
     *      If  <code>nodeSourcePAttributeNamesCollection</code> and  <code>nodeTargetPAttributeNamesCollection</code> are not null, and, for some <code>depth</code>, <code>nodeSourcePAttributeNamesCollection(depth)</code> and <code>nodeTargetPAttributeNamesCollection(depth)</code> are not null but don't have the same length.</br>
     *      If  <code>nodePAttributeNamesCollection</code> and  <code>nodeValuesArrayCollection</code> are not both null or both both not null.</br>
     *      If  <code>nodePAttributeNamesCollection</code> and <code>nodeValuesArrayCollection</code> are not null, and don't have the same size.</br>
     *      If  <code>nodePAttributeNamesCollection</code> and  <code>nodeValuesArrayCollection</code> are not null, and, for some <code>depth</code>, <code>nodePAttributeNamesCollection(depth)</code> and <code>nodeValuesArrayCollection(depth)</code> are not null but don't have the same length.</br>
     *      If  <code>nodePAttributeNamesCollection</code>,   <code>nodeValuesArrayCollection</code>,  <code>nodeSourcePAttributeNamesCollection</code> and  <code>nodeTargetPAttributeNamesCollection</code> are not null, and don't have all the same size.</br>
     *      If two attributes of the same position of <code>sourceTreePath</code> and <code>targetTreePath</code>  are not both collection or both value objects of the class of the nodes of the level of position -1 respectively of the source and target tree.</br>
     */
    public boolean addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, Collection nodeSourcePAttributeNamesCollection, Collection nodeTargetPAttributeNamesCollection, Collection nodePAttributeNamesCollection, Collection nodeValuesArrayCollection)throws ApplicationServiceException;

    /**
     * This method recurs in a parallel way two trees of value objects, that we will call source tree and target tree.</br>
     * If a value object of the source tree is not present in the correspondent position in the target tree, it will be created a new instance of the class
     * of the corresponding position of the missing element in the target tree, some of its attributes will be populated using the attributes values of the value object of the source tree, and with
     * other values specified by the input parameters, and the reference fields will be rightly populated too; such new created instance will be then added to the same target tree.</br>
     * </br>
     * The source tree is specified by the input parameters  <code>sourceRootVO</code> and <code>sourceTreePath</code>.</br>
     * The parameter <code>sourceRootVO</code> is the value object of the root node.</br>
     * The parameter <code>sourceTreePath</code> is a dot separated list of attributes; for example it could be:</br>
     * <code>sourceAttribute_1.sourceAttribute_2.sourceAttribute_3.sourceAttribute_4</code></br>
     * The first attribute must be an attribute of <code>sourceRootVO</code> holding a value object or a collection of value objects; if it is a value object it must have an
     * attribute named as the second attribute of the dot separated list, while if it is a collection, all its elements must have the second attribute of the list.</br>
     * If the first attribute is a value object, this one will be the only child of <code>sourceRootVO</code>, while if it is a collection, its elements will be all the children
     * of <code>sourceRootVO</code>. The tree is defined applying recursively such rule, so that for a value object node of some <code>depth</code> (considering the root a node of <code>depth</code> 0)
     * we have to look at the attribute in the position <code>depth+1</code> in the dot separated list of attributes
     * (considering the first attribute as an attribute of position 1), and such value object node , if it is not a leaf, must have such attribute, that can be a value object (its only child) having in turn
     * an attribute named as the attribute in the position <code>depth+2</code>, or can be a collection of value objects (that are all its children) each one having in turn
     * an attribute named as the attribute in the position <code>depth+2</code>.</br>
     * In the same way is defined the target tree, with the input parameter <code>targetRootVO</code> and <code>targetTreePath</code>.</br>
     * </br>
     * The two trees must have the same alternate sequence of value objects and collections, in other word, if the attribute in the position <code>i+1</code> of <code>targetTreePath</code>
     * represents a collection for the value object nodes of depth <code>i</code> in the target tree, the attribute in the position <code>i+1</code> of <code>sourceTreePath</code> must
     * represent a collection for the value object nodes of depth <code>i</code> in the source tree too; analogously in the case the attribute represents  a value object.
     * </br>
     * Let's start from the two roots and let's see how this method works.</br>
     * If the first attributes of <code>targetRootVO</code> and <code>targetTreePath</code>
     * are respectively collections of  <code>sourceRootVO</code> and <code>targetRootVO</code>,  for each element of the collection held by <code>sourceRootVO</code>
     * this method will create a new instance of the class of the elements of the collection held by  <code>targetRootVO</code> (if such collection is not existing will be created an empty one, using the
     * collection implementation class specified in the mapping file for it), and for such created instance its attributes <code>nodeTargetPAttributeNames[0]</code>
     * will be populated with the attributes <code>nodeSourcePAttributeNames[0]</code> of the element being processed,  its  attributes <code>nodePAttributeNames[0]</code>
     * will be populated with <code>nodeValuesArray[0]</code>, and its foreign fields to  <code>targetRootVO</code> will be populated with the key values of <code>targetRootVO</code>.</br>
     * The new created instance will be compared with the elements of the collection held by <code>targetRootVO</code> by its key values, and if no matching element is found it will be added to it.
     * The same rule is recursively applied, where the new  <code>sourceRootVO</code> and <code>targetRootVO</code> will be respectively the element being processed of the collection held by by <code>sourceRootVO</code> and the
     * new created instance; the new <code>sourceTreePath</code> and <code>targetTreePath</code> will be the same input parameter, but from the second attribute; the index of the arrays is increased by 1 at each recursion
     * and the remaining parameters are unchanged. If in the comparison between the new created instance and the elements of the collection held by <code>targetRootVO</code> a matching element is found,
     * the recursion is the same of above, with the difference that the new <code>targetRootVO</code> won't be the created instance, but the found matching element.</br>
     * </br>
     * If the first attributes of <code>targetRootVO</code> and <code>targetTreePath</code>
     * are respectively value objects of  <code>sourceRootVO</code> and <code>targetRootVO</code>, if the value object held by <code>sourceRootVO</code> is not null and
     * the value object held by <code>targetRootVO</code> is null, this method will create a new instance of the class of the value object held by <code>targetRootVO</code> ,
     * and for such created instance its attributes <code>nodeTargetPAttributeNames[0]</code>
     * will be populated with the attributes <code>nodeSourcePAttributeNames[0]</code> of the value object held by <code>sourceRootVO</code>,  its  attributes <code>nodePAttributeNames[0]</code>
     * will be populated with <code>nodeValuesArray[0]</code>, and this new instance will be used to set the first attribute of  <code>targetTreePath</code>
     * of <code>targetRootVO</code>, and the foreign keys fields of <code>targetRootVO</code> to such value object will be set with the key values of the new instance.</br>
     * Moreover if the value object held by <code>sourceRootVO</code> is not null, a recursion will take place, in the same way described above, but where the new <code>sourceRootVO</code> and <code>targetRootVO</code>
     * will be the two value objects respectively held by themselves (for the value object held by targetRootVO it could be the new instanced one).</br>
     * </br>
     * The recursion ends when <code>sourceTreePath</code> and  <code>targetTreePath</code> are empty strings.</br>
     * </br>
     * If <code>nodeSourcePAttributeNames</code> and  <code>nodeTargetPAttributeNames</code> are both null, the relative operations are not performed; if just one of them is null, it will assume the value of the other one.
     * For example if <code>nodeSourcePAttributeNames</code> is null and <code>nodeTargetPAttributeNames</code> is not null, <code>nodeSourcePAttributeNames</code> will have the value of <code>nodeTargetPAttributeNames</code> (and viceversa).</br>
     * If <code>nodeSourcePAttributeNames</code> and  <code>nodeTargetPAttributeNames</code> are not null, for each <code>index</code>
     * if <code>nodeSourcePAttributeNames[index]</code> and  <code>nodeTargetPAttributeNames[index]</code> are both null, the relative operations are not performed for the nodes of depth  <code>index-1</code>; if just one of them is null, it will assume the value of the other one.
     * If <code>nodePAttributeNames</code> and  <code>nodeValuesArray</code> are both null, the relative operations are not performed; if they are not null for each <code>index</code>
     * if code>nodePAttributeNames[index]</code> and <code>nodeValuesArray[index]</code> are both null, the relative operations are not performed for the nodes of depth  <code>index-1</code>.
     * </br>
     *
     * @param sourceRootVO Root of the source tree. It can't be null.
     * @param targetRootVO Root of the target tree. It can't be null.
     * @param sourceTreePath dot separated list of attributes defining the source tree. It can't be null.
     * @param targetTreePath dot separated list of attributes defining the target tree. It can't be null.
     * @param nodeSourcePAttributeNames  <code>nodeSourcePAttributeNames[index]</code> are the attributes names of the children of the nodes of level <code>index</code> of the source tree
     * @param nodeTargetPAttributeNames  <code>nodeTargetPAttributeNames[index]</code> are the attributes names of the children of the nodes of level <code>index</code> of the target tree
     * @param nodePAttributeNames <code>nodePAttributeNames[index]</code> are the attributes names of the created instances to add to the children of the nodes of level <code>index</code> of the target tree
     *              to be populated with <code>nodeValuesArray[index]</code>.
     * @param nodeValuesArray <code>nodeValuesArray[index]</code> are used to populate the attributes <code>nodePAttributeNames[index]</code> of the created instances children of the nodes of level <code>index</code> of the target tree.
     * @return  true if the target tree is modified, false otherwise.
     * @throws ApplicationServiceException -
     *      If  <code>sourceRootVO</code> or <code>targetRootVO</code> or <code>sourceTreePath</code> or <code>targetTreePath</code> are null.</br>
     *      If  <code>sourceTreePath</code> and <code>targetTreePath</code> are not both empty strings or not both not empty strings.</br>
     *      If  <code>nodeSourcePAttributeNames</code> and  <code>nodeTargetPAttributeNames</code> are not null, and don't have the same length.</br>
     *      If  <code>nodeSourcePAttributeNames</code> and  <code>nodeTargetPAttributeNames</code> are not null, and, for some <code>depth</code>, <code>nodeSourcePAttributeNames[depth]</code> and <code>nodeTargetPAttributeNames[depth]</code> are not null but don't have the same length.</br>
     *      If  <code>nodePAttributeNames</code> and  <code>nodeValuesArray</code> are not both null or both both not null.</br>
     *      If  <code>nodePAttributeNames</code> and <code>nodeValuesArray</code> are not null, and don't have the same length.</br>
     *      If  <code>nodePAttributeNames</code> and  <code>nodeValuesArray</code> are not null, and, for some <code>depth</code>, <code>nodePAttributeNames[depth]</code> and <code>nodeValuesArray[depth]</code> are not null but don't have the same length.</br>
     *      If  <code>nodePAttributeNames</code>,   <code>nodeValuesArray</code>,  <code>nodeSourcePAttributeNames</code> and  <code>nodeTargetPAttributeNames</code> are not null, and don't have all the same length.</br>
     *      If two attributes of the same position of <code>sourceTreePath</code> and <code>targetTreePath</code>  are not both collection or both value objects of the class of the nodes of the level of position -1 respectively of the source and target tree.</br>
     */
    public boolean addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, String[][] nodePAttributeNames, Object[][] nodeValuesArray)throws ApplicationServiceException;

    /**
     * This method has the same behavior of {@link #addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, Collection nodeSourcePAttributeNamesCollection, Collection nodeTargetPAttributeNamesCollection, Collection nodePAttributeNamesCollection, Collection nodeValuesArrayCollection)}
     * or {@link #addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, String[][] nodePAttributeNames, Object[][] nodeValuesArray)}
     * but it is applied for all the sourceTreePath and  targetTreePath of the collection of <code>sourceTreePaths</code> and <code>targetTreePaths</code>.</br>
     * The input parameters <code>sourceTreePaths</code>, <code>targetTreePaths</code>, <code>treeNodeSourcePAttributeNames</code>, <code>treeNodeTargetPAttributeNames</code>, <code>treeNodePAttributeNames</code>, <code>treeNodeValuesArray</code>, where not null,
     * must be collection of the same size.
     * The elements in the position <code>i</code> of this six collection will be the last six input parameter for one of the two methods above. (Note that <code>sourceRootVO</code> and <code>targetRootVO</code>
     * will be the same for all the calls). Which one the two methods is called at each iteration depends by the type of the elements of the position <code>i</code>
     * of the collection <code>treeNodeSourcePAttributeNames</code>, <code>treeNodeTargetPAttributeNames</code>, <code>treeNodePAttributeNames</code>, <code>treeNodeValuesArray</code>
     * that are not null.
     * @param sourceRootVO Root of the source trees. It can't be null.
     * @param targetRootVO Root of the target trees. It can't be null.
     * @param sourceTreePaths collection of paths, each one being a dot separated list of attributes defining a source tree which root is <code>sourceRootVO</code>
     * @param targetTreePaths collection of paths, each one being a dot separated list of attributes defining a target tree which root is <code>targetRootVO</code>
     * @param treeNodeSourcePAttributeNames collection of attributes names used as source of information to create the new value objects that will be the nodes of the target tree.</br>
     * @param treeNodeTargetPAttributeNames collection of attributes names of new nodes of the target tree that will be populated with the values of  attributes of the source tree.
     * @param treeNodePAttributeNames collection of attributes names of new nodes of the target tree that will be populated with <code>treeNodeValuesArray</code>
     * @param treeNodeValuesArray  values to populate the attributes of the new nodes of the target tree
     * @return return true id some elements is added to the tree of root <code>targetRootVO</code>, false otherwise.</br>
     * @throws ApplicationServiceException -
     *      If  <code>sourceRootVO</code> or <code>targetRootVO</code> or <code>sourceTreePaths</code> or <code>targetTreePaths</code> are null.</br>
     *      If <code>sourceTreePaths</code> and <code>targetTreePaths</code> do not have the same size.</br>
     *      If two elements in the same position of the two collection <code>sourceTreePaths</code> and <code>targetTreePaths</code> are not both empty strings or not both not empty strings.</br>
     *      If some elements of <code>sourceTreePaths</code> or <code>targetTreePaths</code> is null.</br>
     *      If two of the six collection <code>sourceTreePaths</code>, <code>targetTreePaths</code>, <code>treeNodeSourcePAttributeNames</code>, <code>treeNodeTargetPAttributeNames</code>, <code>treeNodePAttributeNames</code>, <code>treeNodeValuesArray</code> that are not null, have different size.</br>
     *      If <code>treeNodePAttributeNames</code> and <code>treeNodeValuesArray</code> are not both null or both not null.</br>
     *      If  the not null elements of the same position of the for colletions <code>treeNodeSourcePAttributeNames</code>, <code>treeNodeTargetPAttributeNames</code>, <code>treeNodePAttributeNames</code> and <code>treeNodeValuesArray</code> are not all Collection or all String[][].</br>
     *      If two elements in the same position of the two collection <code>treeNodeSourcePAttributeNames</code> and <code>treeNodeTargetPAttributeNames</code> are not null, and don't have the same length.</br>
     *      If, called <code>nodeSourcePAttributeNames</code> and  <code>nodeTargetPAttributeNames</code> two elements in the same position of the two collection <code>treeNodeSourcePAttributeNames</code> and <code>treeNodeTargetPAttributeNames</code>,<code>nodeSourcePAttributeNames</code> and  <code>nodeTargetPAttributeNames</code> are not null, and, for some <code>depth</code>, <code>nodeSourcePAttributeNames[depth]</code> and <code>nodeTargetPAttributeNames[depth]</code> are not null but don't have the same length.</br>
     *      If two elements in the same position of the two collection <code>treeNodePAttributeNames</code> and <code>treeNodeValuesArray</code> are not both null or both both not null.</br>
     *      If two elements in the same position of the two collection <code>treeNodePAttributeNames</code> and <code>treeNodeValuesArray</code> are not null, and don't have the same length.</br>
     *      If, called  <code>nodePAttributeNames</code> and  <code>nodeValuesArray</code>,  two elements in the same position of the two collection <code>treeNodePAttributeNames</code> and <code>treeNodeValuesArray</code> <code>nodePAttributeNames</code> and  <code>nodeValuesArray</code> are not null, and, for some <code>depth</code>, <code>nodePAttributeNames[depth]</code> and <code>nodeValuesArray[depth]</code> are not null but don't have the same length.</br>
     *      If elements of the same position of the collections <code>treeNodeSourcePAttributeNames</code>, <code>treeNodeTargetPAttributeNames</code>, <code>treeNodePAttributeNames</code>, <code>treeNodeValuesArray</code> that are not null don't have all the same length.</br>
     *      If two attributes of the same position of elements of the same position of <code>sourceTreePaths</code> and <code>targetTreePaths</code>  are not both collection or both value objects of the class of the nodes of the level of position -1 respectively of the source and target tree of the respective iteration.</br>
     */
    public boolean  addTreeToTree(Object sourceRootVO, Object targetRootVO,Collection sourceTreePaths,Collection targetTreePaths, Collection treeNodeSourcePAttributeNames, Collection treeNodeTargetPAttributeNames, Collection treeNodePAttributeNames, Collection treeNodeValuesArray ) throws ApplicationServiceException;


}
