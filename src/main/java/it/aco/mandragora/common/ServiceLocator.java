/* ====================================================================
 *		      GNU GENERAL PUBLIC LICENSE
 *		         Version 2, June 1991
 *
 *    Copyright (C) 1989, 1991 Free Software Foundation, Inc.
 *                        51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *    Everyone is permitted to copy and distribute verbatim copies
 *  of this license document, but changing it is not allowed.
 *
 *  			    Preamble
 *
 *    The licenses for most software are designed to take away your
 *  freedom to share and change it.  By contrast, the GNU General Public
 *  License is intended to guarantee your freedom to share and change free
 *  software--to make sure the software is free for all its users.  This
 *  General Public License applies to most of the Free Software
 *  Foundation's software and to any other program whose authors commit to
 *  using it.  (Some other Free Software Foundation software is covered by
 *  the GNU Library General Public License instead.)  You can apply it to
 *  your programs, too.
 *
 *    When we speak of free software, we are referring to freedom, not
 *  price.  Our General Public Licenses are designed to make sure that you
 *  have the freedom to distribute copies of free software (and charge for
 *  this service if you wish), that you receive source code or can get it
 *  if you want it, that you can change the software or use pieces of it
 *  in new free programs; and that you know you can do these things.
 *
 *     To protect your rights, we need to make restrictions that forbid
 *  anyone to deny you these rights or to ask you to surrender the rights.
 *  These restrictions translate to certain responsibilities for you if you
 *  distribute copies of the software, or if you modify it.
 *
 *     For example, if you distribute copies of such a program, whether
 *  gratis or for a fee, you must give the recipients all the rights that
 *  you have.  You must make sure that they, too, receive or can get the
 *  source code.  And you must show them these terms so they know their
 *  rights.
 *
 *     We protect your rights with two steps: (1) copyright the software, and
 *  (2) offer you this license which gives you legal permission to copy,
 *  distribute and/or modify the software.
 *
 *     Also, for each author's protection and ours, we want to make certain
 *  that everyone understands that there is no warranty for this free
 *  software.  If the software is modified by someone else and passed on, we
 *  want its recipients to know that what they have is not the original, so
 *  that any problems introduced by others will not reflect on the original
 *  authors' reputations.
 *
 *     Finally, any free program is threatened constantly by software
 *  patents.  We wish to avoid the danger that redistributors of a free
 *  program will individually obtain patent licenses, in effect making the
 *  program proprietary.  To prevent this, we have made it clear that any
 *  patent must be licensed for everyone's free use or not licensed at all.
 *
 *     The precise terms and conditions for copying, distribution and
 *  modification follow.
 *  
 *	                	    GNU GENERAL PUBLIC LICENSE
 *       TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
 *
 *     0. This License applies to any program or other work which contains
 *  a notice placed by the copyright holder saying it may be distributed
 *  under the terms of this General Public License.  The "Program", below,
 *  refers to any such program or work, and a "work based on the Program"
 *  means either the Program or any derivative work under copyright law:
 *  that is to say, a work containing the Program or a portion of it,
 *  either verbatim or with modifications and/or translated into another
 *  language.  (Hereinafter, translation is included without limitation in
 *  the term "modification".)  Each licensee is addressed as "you".
 *
 *     Activities other than copying, distribution and modification are not
 *  covered by this License; they are outside its scope.  The act of
 *  running the Program is not restricted, and the output from the Program
 *  is covered only if its contents constitute a work based on the
 *  Program (independent of having been made by running the Program).
 *  Whether that is true depends on what the Program does.
 *
 *     1. You may copy and distribute verbatim copies of the Program's
 *  source code as you receive it, in any medium, provided that you
 *  conspicuously and appropriately publish on each copy an appropriate
 *  copyright notice and disclaimer of warranty; keep intact all the
 *  notices that refer to this License and to the absence of any warranty;
 *  and give any other recipients of the Program a copy of this License
 *  along with the Program.
 *
 *  You may charge a fee for the physical act of transferring a copy, and
 *  you may at your option offer warranty protection in exchange for a fee.
 *
 *     2. You may modify your copy or copies of the Program or any portion
 *  of it, thus forming a work based on the Program, and copy and
 *  distribute such modifications or work under the terms of Section 1
 *  above, provided that you also meet all of these conditions:
 *
 *        a) You must cause the modified files to carry prominent notices
 *     stating that you changed the files and the date of any change.
 *
 *        b) You must cause any work that you distribute or publish, that in
 *     whole or in part contains or is derived from the Program or any
 *     part thereof, to be licensed as a whole at no charge to all third
 *     parties under the terms of this License.
 *
 *        c) If the modified program normally reads commands interactively
 *     when run, you must cause it, when started running for such
 *     interactive use in the most ordinary way, to print or display an
 *     announcement including an appropriate copyright notice and a
 *     notice that there is no warranty (or else, saying that you provide
 *     a warranty) and that users may redistribute the program under
 *     these conditions, and telling the user how to view a copy of this
 *     License.  (Exception: if the Program itself is interactive but
 *     does not normally print such an announcement, your work based on
 *     the Program is not required to print an announcement.)
 *     
 *     These requirements apply to the modified work as a whole.  If
 *  identifiable sections of that work are not derived from the Program,
 *  and can be reasonably considered independent and separate works in
 *  themselves, then this License, and its terms, do not apply to those
 *  sections when you distribute them as separate works.  But when you
 *  distribute the same sections as part of a whole which is a work based
 *  on the Program, the distribution of the whole must be on the terms of
 *  this License, whose permissions for other licensees extend to the
 *  entire whole, and thus to each and every part regardless of who wrote it.
 *
 *     Thus, it is not the intent of this section to claim rights or contest
 *  your rights to work written entirely by you; rather, the intent is to
 *  exercise the right to control the distribution of derivative or
 *  collective works based on the Program.
 *
 *     In addition, mere aggregation of another work not based on the Program
 *  with the Program (or with a work based on the Program) on a volume of
 *  a storage or distribution medium does not bring the other work under
 *  the scope of this License.
 *
 *      3. You may copy and distribute the Program (or a work based on it,
 *  under Section 2) in object code or executable form under the terms of
 *  Sections 1 and 2 above provided that you also do one of the following:
 *
 *        a) Accompany it with the complete corresponding machine-readable
 *     source code, which must be distributed under the terms of Sections
 *     1 and 2 above on a medium customarily used for software interchange; or,
 *
 *        b) Accompany it with a written offer, valid for at least three
 *     years, to give any third party, for a charge no more than your
 *     cost of physically performing source distribution, a complete
 *     machine-readable copy of the corresponding source code, to be
 *     distributed under the terms of Sections 1 and 2 above on a medium
 *     customarily used for software interchange; or,
 *
 *        c) Accompany it with the information you received as to the offer
 *     to distribute corresponding source code.  (This alternative is
 *     allowed only for noncommercial distribution and only if you
 *     received the program in object code or executable form with such
 *     an offer, in accord with Subsection b above.)
 *
 *  The source code for a work means the preferred form of the work for
 *  making modifications to it.  For an executable work, complete source
 *  code means all the source code for all modules it contains, plus any
 *  associated interface definition files, plus the scripts used to
 *  control compilation and installation of the executable.  However, as a
 *  special exception, the source code distributed need not include
 *  anything that is normally distributed (in either source or binary
 *  form) with the major components (compiler, kernel, and so on) of the
 *  operating system on which the executable runs, unless that component
 *  itself accompanies the executable.
 *
 *  If distribution of executable or object code is made by offering
 *  access to copy from a designated place, then offering equivalent
 *  access to copy the source code from the same place counts as
 *  distribution of the source code, even though third parties are not
 *  compelled to copy the source along with the object code.
 *  
 *     4. You may not copy, modify, sublicense, or distribute the Program
 *  except as expressly provided under this License.  Any attempt
 *  otherwise to copy, modify, sublicense or distribute the Program is
 *  void, and will automatically terminate your rights under this License.
 *  However, parties who have received copies, or rights, from you under
 *  this License will not have their licenses terminated so long as such
 *  parties remain in full compliance.
 *
 *    5. You are not required to accept this License, since you have not
 *  signed it.  However, nothing else grants you permission to modify or
 *  distribute the Program or its derivative works.  These actions are
 *  prohibited by law if you do not accept this License.  Therefore, by
 *  modifying or distributing the Program (or any work based on the
 *  Program), you indicate your acceptance of this License to do so, and
 *  all its terms and conditions for copying, distributing or modifying
 *  the Program or works based on it.
 *
 *    6. Each time you redistribute the Program (or any work based on the
 *  Program), the recipient automatically receives a license from the
 *  original licensor to copy, distribute or modify the Program subject to
 *  these terms and conditions.  You may not impose any further
 *  restrictions on the recipients' exercise of the rights granted herein.
 *  You are not responsible for enforcing compliance by third parties to
 *  this License.
 *
 *    7. If, as a consequence of a court judgment or allegation of patent
 *  infringement or for any other reason (not limited to patent issues),
 *  conditions are imposed on you (whether by court order, agreement or
 *  otherwise) that contradict the conditions of this License, they do not
 *  excuse you from the conditions of this License.  If you cannot
 *  distribute so as to satisfy simultaneously your obligations under this
 *  License and any other pertinent obligations, then as a consequence you
 *  may not distribute the Program at all.  For example, if a patent
 *  license would not permit royalty-free redistribution of the Program by
 *  all those who receive copies directly or indirectly through you, then
 *  the only way you could satisfy both it and this License would be to
 *  refrain entirely from distribution of the Program.

 *  If any portion of this section is held invalid or unenforceable under
 *  any particular circumstance, the balance of the section is intended to
 *  apply and the section as a whole is intended to apply in other
 *  circumstances.

 *  It is not the purpose of this section to induce you to infringe any
 *  patents or other property right claims or to contest validity of any
 *  such claims; this section has the sole purpose of protecting the
 *  integrity of the free software distribution system, which is
 *  implemented by public license practices.  Many people have made
 *  generous contributions to the wide range of software distributed
 *  through that system in reliance on consistent application of that
 *  system; it is up to the author/donor to decide if he or she is willing
 *  to distribute software through any other system and a licensee cannot
 *  impose that choice.

 *  This section is intended to make thoroughly clear what is believed to
 *  be a consequence of the rest of this License.
 *  
 *    8. If the distribution and/or use of the Program is restricted in
 *  certain countries either by patents or by copyrighted interfaces, the
 *  original copyright holder who places the Program under this License
 *  may add an explicit geographical distribution limitation excluding
 *  those countries, so that distribution is permitted only in or among
 *  countries not thus excluded.  In such case, this License incorporates
 *  the limitation as if written in the body of this License.
 *
 *    9. The Free Software Foundation may publish revised and/or new versions
 *  of the General Public License from time to time.  Such new versions will
 *  be similar in spirit to the present version, but may differ in detail to
 *  address new problems or concerns.
 *
 *  Each version is given a distinguishing version number.  If the Program
 *  specifies a version number of this License which applies to it and "any
 *  later version", you have the option of following the terms and conditions
 *  either of that version or of any later version published by the Free
 *  Software Foundation.  If the Program does not specify a version number of
 *  this License, you may choose any version ever published by the Free Software
 *  Foundation.

 *    10. If you wish to incorporate parts of the Program into other free
 *  programs whose distribution conditions are different, write to the author
 *  to ask for permission.  For software which is copyrighted by the Free
 *  Software Foundation, write to the Free Software Foundation; we sometimes
 *  make exceptions for this.  Our decision will be guided by the two goals
 *  vof preserving the free status of all derivatives of our free software and
 *  of promoting the sharing and reuse of software generally.
 *
 *  			    NO WARRANTY
 *
 *    11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
 *  FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
 *  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
 *  PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
 *  OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
 *  TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
 *  PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
 *  REPAIR OR CORRECTION.
 *
 *    12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
 *  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
 *  REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
 *  INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
 *  OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
 *  TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
 *  YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
 *  PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGES.
 *
 *  		     END OF TERMS AND CONDITIONS
 *  
 *  	    How to Apply These Terms to Your New Programs
 *    If you develop a new program, and you want it to be of the greatest
 *  possible use to the public, the best way to achieve this is to make it
 *  free software which everyone can redistribute and change under these terms.
 *
 *    To do so, attach the following notices to the program.  It is safest
 *  to attach them to the start of each source file to most effectively
 *  convey the exclusion of warranty; and each file should have at least
 *  the "copyright" line and a pointer to where the full notice is found.
 *
 *      <one line to give the program's name and a brief idea of what it does.>
 *      Copyright (C) <year>  <name of author>
 *
 *      This program is free software; you can redistribute it and/or modify
 *      it under the terms of the GNU General Public License as published by
 *      the Free Software Foundation; either version 2 of the License, or
 *      (at your option) any later version.
 *
 *      This program is distributed in the hope that it will be useful,
 *      but WITHOUT ANY WARRANTY; without even the implied warranty of
 *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *      GNU General Public License for more details.
 *
 *      You should have received a copy of the GNU General Public License
 *      along with this program; if not, write to the Free Software
 *      Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *
 *
 *  Also add information on how to contact you by electronic and paper mail.
 *
 *  If the program is interactive, make it output a short notice like this
 *  when it starts in an interactive mode:
 *
 *      Gnomovision version 69, Copyright (C) year name of author
 *      Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
 *      This is free software, and you are welcome to redistribute it
 *      under certain conditions; type `show c' for details.
 *
 *  The hypothetical commands `show w' and `show c' should show the appropriate
 *  parts of the General Public License.  Of course, the commands you use may
 *  be called something other than `show w' and `show c'; they could even be
 *  mouse-clicks or menu items--whatever suits your program.
 *
 *  You should also get your employer (if you work as a programmer) or your
 *  school, if any, to sign a "copyright disclaimer" for the program, if
 *  necessary.  Here is a sample; alter the names:
 *
 *    Yoyodyne, Inc., hereby disclaims all copyright interest in the program
 *    `Gnomovision' (which makes passes at compilers) written by James Hacker.
 *
 *    <signature of Ty Coon>, 1 April 1989
 *    Ty Coon, President of Vice

 *  This General Public License does not permit incorporating your program into
 *  proprietary programs.  If your program is a subroutine library, you may
 *  consider it more useful to permit linking proprietary applications with the
 *  library.  If this is what you want to do, use the GNU Library General
 *  Public License instead of this License.
 */


package it.aco.mandragora.common;

import org.apache.ojb.broker.PBFactoryException;
import org.apache.ojb.broker.PersistenceBroker;
import org.apache.ojb.broker.PersistenceBrokerFactory;
import org.quartz.Scheduler;
import org.quartz.SchedulerFactory;
import it.aco.mandragora.bd.BD;
import it.aco.mandragora.bd.BDFactory;
import it.aco.mandragora.bd.context.ContextBD;
import it.aco.mandragora.bd.context.ContextBDFactory;
import it.aco.mandragora.bd.impl.proxy.methodInterceptor.MethodInterceptorFactory;
import it.aco.mandragora.exception.*;
import it.aco.mandragora.dao.DAO;
import it.aco.mandragora.dao.DAOFactory;
import it.aco.mandragora.dao.context.ContextDAO;
import it.aco.mandragora.dao.context.ContextDAOFactory;
import it.aco.mandragora.dao.impl.ojb.pb.core.OjbPbCore;
import it.aco.mandragora.dao.impl.ojb.pb.core.OjbPbCoreFactory;
import it.aco.mandragora.dao.impl.ojb.pb.support.PersistenceBrokerSupport;
import it.aco.mandragora.dao.impl.ojb.pb.support.PersistenceBrokerSupportFactory;
import it.aco.mandragora.startup.OjbPbFactory;
import it.aco.mandragora.util.configuration.impl.MandragoraConfigurator;
import it.aco.mandragora.as.ApplicationService;
import it.aco.mandragora.as.ApplicationServiceFactory;
import it.aco.mandragora.as.context.ContextApplicationService;
import it.aco.mandragora.as.context.ContextApplicationServiceFactory;
import it.aco.mandragora.serviceFacade.ServiceFacade;
import it.aco.mandragora.serviceFacade.ServiceFacadeFactory;
import it.aco.mandragora.serviceFacade.context.ContextServiceFacade;
import it.aco.mandragora.serviceFacade.context.ContextServiceFacadeFactory;

import javax.naming.NamingException;
import javax.naming.InitialContext;
import javax.naming.Context;
import javax.ejb.EJBHome;
import javax.rmi.PortableRemoteObject;
import java.util.Hashtable;
import org.apache.ojb.broker.util.configuration.Configurator;
import org.apache.ojb.broker.util.configuration.Configuration;
import net.sf.cglib.proxy.MethodInterceptor;



public class ServiceLocator  {
	private static ServiceLocator serviceLocatorRef = null; //deleted by alessandro on 19/07/2007
	private static Scheduler scheduler= null;
	private static OjbPbFactory ojbPbFactory= null;
    private static Hashtable ejbHomeCache = null;

    private static  org.apache.log4j.Category log = org.apache.log4j.Logger.getLogger(ServiceLocator.class.getName());



    // start added by alessandro on 19/07/2007
    /*
    private static class ServiceLocatorHolder  {
        private final static ServiceLocator INSTANCE = new ServiceLocator()  ;

    }
    */
    // end added by alessandro on 19/07/2007
    static {
        try{
            serviceLocatorRef = new ServiceLocator();
        }catch (Exception e){
        log.error("Exception in static block of  ServiceLocator");
        throw new RuntimeException("Exception in the static of ServiceLocator");

      }
    }

	//
	//	/*Private Constructor for the ServiceLocator*/
    //private ServiceLocator() throws Exception {
    private ServiceLocator() throws ServiceLocatorException {
        ejbHomeCache = new Hashtable();
		//dataSourceCache = new Hashtable();
        try{
            if (Utils.getStringFromMandragoraProperties("IsInManagedEnvironment").equalsIgnoreCase("true")){
                InitialContext context = null;
                context = new InitialContext();
                ojbPbFactory = (OjbPbFactory)context.lookup("PBFactory");
            }

            String instanceServiceLocatorscheduler = Utils.getStringFromMandragoraProperties("instanceServiceLocator.scheduler");
            if(instanceServiceLocatorscheduler!=null && instanceServiceLocatorscheduler.equalsIgnoreCase("true")){
                try{
                    SchedulerFactory schedFact = new org.quartz.impl.StdSchedulerFactory();
                    scheduler = schedFact.getScheduler();
                }  catch(org.quartz.SchedulerException e){
                    log.info("SchedulerException in private constructor ServiceLocator "+e);
                    //throw new Exception("SchedulerException in private constructor ServiceLocator "); deleted on 11-09-2007 to work if the servlet is not registered in thw web.xml or if is not a web application
                    throw new ServiceLocatorException("SchedulerException in private constructor ServiceLocator() ");
                }
            }
            //Scheduler sched = StdSchedulerFactory.getDefaultScheduler();
            //scheduler.start();
            /* deleted until installing startup class  */

            /*  put out of the try catch to execute even if a SchedulerException is thrown (when not present the servlet in the web.xml,
                for example if it is not a web application) on 11-09-2007
            if (Utils.getStringFromMandragoraProperties("IsInManagedEnvironment").equalsIgnoreCase("true")){
                InitialContext context = null;
                context = new InitialContext();
                ojbPbFactory = (OjbPbFactory)context.lookup("PBFactory");
            }
            */
            //throw new Exception("EXCEPTION DE PRUEBA");
        }catch(Exception e){
            log.error("SchedulerException in private constructor ServiceLocator "+e);
            throw new ServiceLocatorException("Exception in private constructor ServiceLocator() ");
        }
        //serviceLocatorRef=ServiceLocatorHolder.INSTANCE;
    }




	//
	//	/*
	//	 * The ServiceLocator is implemented as a Singleton.  The getInstance()
	//	 * method will return the static reference to the ServiceLocator stored
	//	 * inside of the ServiceLocator Class.
	//	 */
    //public static ServiceLocator getInstance() {  // changed on 19/07/2007
    public static ServiceLocator getInstance() throws ServiceLocatorException{
        return serviceLocatorRef;
        /*
        if (serviceLocatorRef==null){
            throw new ServiceLocatorException("Exception in ServiceLocator().getInstance():No singleton instance available ");
        }   else {
            return serviceLocatorRef;
        }
        */
    }


    /**
     *    Retrieves an OJB persistence broker.
     */
    public PersistenceBroker findBroker() throws ServiceLocatorException {
        PersistenceBroker broker = null;

        try {
            //PBKey pbKey = new PBKey("repository.xml");

            //broker = PersistenceBrokerFactory.createPersistenceBroker(pbKey);
            //if (Utils.getStringFromMandragoraProperties("IsInManagedEnvironment").equalsIgnoreCase("false")){
            if (Utils.getStringFromMandragoraProperties("IsInManagedEnvironment").equalsIgnoreCase("true")){

                broker = ojbPbFactory.getInstance().defaultPersistenceBroker();
            }else{
                broker=PersistenceBrokerFactory.defaultPersistenceBroker();
            }



          //broker = PersistenceBrokerFactoryFactory.instance().defaultPersistenceBroker();




        } catch (PBFactoryException e) {
          e.printStackTrace();
          throw new ServiceLocatorException(
            "PBFactoryException error occurred while parsing the repository.xml file in ServiceLocator.findBroker() ", e);

        }catch(NamingException e){
            e.printStackTrace();
            throw new ServiceLocatorException("NamingException  in ServiceLocator.findBroker() ",  e);
        } catch (Exception e)   {
            e.printStackTrace();
            throw new ServiceLocatorException("Exception  in ServiceLocator.findBroker() ",  e);
        }

        return broker;
    }


    /**
     * This method looks up a {@link BD} implementation trough a {@link BDFactory} following the factoryfactory pattern, and this {@link BDFactory} is chosen
     * with a look up  too.<br/>
     * So what this method does is to look up a {@link BDFactory} , and then this {@link BDFactory} looks up the {@link BD} implementation.<br/>
     *
     * @param bdFactoryClassName specifies which is the {@link BDFactory} to be looked up and that has to look up the {@link BD} implementation. <br/>
     * The mapping between the input string <code>bdFactoryClassName</code> and the real {@link BDFactory} is specified in the <code>mandragora.properties</code> file.<br/>
     * If this parameter is null or empty string will be looked up the {@link BDFactory} specified in <code>mandragora.properties</code> by the property "BDFactoryDefaultClass".<br/>
     * <br/>
     * @param bdClassName specifies which {@link BD} implementation the {@link BDFactory} specified by <code>bdFactoryClassName</code> has to look up.<br/>
     * The mapping with the {@link BD} implementation depends by the  real {@link BDFactory} specified by <code>bdFactoryClassName</code>.<br/>
     * If this parameter is null or empty string the BD implementation that be default for the real {@link BDFactory} specified by <code>bdFactoryClassName</code> will be looked up and returned to the caller.<br/>
     * Note that each real {@link BDFactory}can have a different BD implementation.
     * <br/>
     * @return the implementation of the interface {@link BD} specified by the input parameter <code>bdClassName</code> and looked up by the {@link BDFactory} specified by
     * the input parameter <code>bdFactoryClassName</code> <br/>
     *
     * @throws ServiceLocatorException
     */
    public BD getManagerBD(String bdFactoryClassName, String bdClassName) throws ServiceLocatorException{
        BD bd = null;
        try{
            // start added by Alessandro on 22/09/2007
            if (bdFactoryClassName!=null && !bdFactoryClassName.equals("") && bdClassName!=null && !bdClassName.equals("")){
                bd= BDFactory.getBDFactory(bdFactoryClassName).getBD(bdClassName);
            } else if (bdFactoryClassName!=null && !bdFactoryClassName.equals("")){
                bd= BDFactory.getBDFactory(bdFactoryClassName).getBD();
            } else if (bdClassName!=null && !bdClassName.equals("")){
                bd= BDFactory.getBDFactory().getBD(bdClassName);
            } else{
                bd= BDFactory.getBDFactory().getBD();
            }
            // end  added by Alessandro on 22/09/2007
            //bd= BDFactory.getBDFactory(bdFactoryClassName).getBD(bdClassName);  deleted by alessandro  on 22/09/2007
        }catch (BdFactoryException e){
            e.printStackTrace();
            throw new ServiceLocatorException("BdFactoryException  occurred in ServiceLocator.getManagerBD(String bdFactoryClassName, String bdClassName)", e);
        }catch (Exception e){
            e.printStackTrace();
            throw new ServiceLocatorException("Exception  occurred in ServiceLocator.getManagerBD(String bdFactoryClassName, String bdClassName)", e);
        }
        return bd;
    }

    /*added by Alessandro on 22/09/2007*/

    /**
     * This method acts as  {@link #getManagerBD(null, null)}
     * @return
     * @throws ServiceLocatorException
     */
    public BD getManagerBD() throws ServiceLocatorException{
        BD bd = null;
        try{
            bd= BDFactory.getBDFactory().getBD();
        }catch (BdFactoryException e){
            e.printStackTrace();
            throw new ServiceLocatorException("BdFactoryException  occurred in ServiceLocator.getManagerBD()", e);
        }catch (Exception e){
            e.printStackTrace();
            throw new ServiceLocatorException("Exception  occurred in ServiceLocator.getManagerBD()", e);
        }
        return bd;
    }


    /**
     * This method looks up a {@link DAO} implementation trough a {@link DAOFactory} following the factoryfactory pattern, and this {@link DAOFactory} is chosen
     * with a look up too.<br/>
     * So what this method does is to look up a {@link DAOFactory} , and then this {@link DAOFactory} looks up the {@link DAO} implementation.<br/>
     *
     * @param daoFactoryClassName specifies which is the {@link DAOFactory} to be looked up and that has to look up the {@link DAO} implementation. <br/>
     * The mapping between the input string <code>daoFactoryClassName</code> and the real {@link DAOFactory} is specified in the <code>Mandragora.properties</code> file.<br/>
     * If this parameter is null or empty string will be looked up the {@link DAOFactory} specified in <code>mandragora.properties</code> by the property "DAOFactoryDefaultClass".<br/>
     * <br/>
     * @param daoClassName specifies which {@link DAO} implementation the {@link DAOFactory} specified by <code>daoFactoryClassName</code> has to look up.<br/>
     * The mapping with the {@link DAO} implementation depends by the  real {@link DAOFactory} specified by <code>daoFactoryClassName</code>.<br/>
     * If this parameter is null or empty string the DAO implementation that be default for the real {@link DAOFactory} specified by <code>daoFactoryClassName</code> will be looked up and returned to the caller.<br/>
     * Note that each real {@link BDFactory}can have a different BD implementation.
     * <br/>
     * @return the implementation of the interface {@link DAO} specified by the input parameter <code>daoClassName</code> and looked up by the {@link DAOFactory} specified by
     * the input parameter <code>daoFactoryClassName</code> <br/>
     *
     * @throws ServiceLocatorException
     */
    public DAO getDAO(String daoFactoryClassName, String daoClassName) throws ServiceLocatorException{
        DAO dao = null;
        try{
            // start added by Alessandro on 25/09/2007
            if (daoFactoryClassName!=null && !daoFactoryClassName.equals("") && daoClassName!=null && !daoClassName.equals("")){
                dao = DAOFactory.getDAOFactory(daoFactoryClassName).getDAO(daoClassName);
            } else if (daoFactoryClassName!=null && !daoFactoryClassName.equals("")){
                dao = DAOFactory.getDAOFactory(daoFactoryClassName).getDAO();
            } else if (daoClassName!=null && !daoClassName.equals("")){
                dao = DAOFactory.getDAOFactory().getDAO(daoClassName);
            } else{
                dao = DAOFactory.getDAOFactory().getDAO();        
            }
            // end added by Alessandro on 25/09/2007
            //dao = DAOFactory.getDAOFactory(daoFactoryClassName).getContextDAO(daoClassName); deleted   by Alessandro on 25/09/2007
        }catch (DaoFactoryException e){
            e.printStackTrace();
            throw new ServiceLocatorException("DaoFactoryException  occurred in ServiceLocator.getContextDAO(String daoFactoryClassName, String daoClassName)", e);
        }catch (Exception e){
            e.printStackTrace();
            throw new ServiceLocatorException("Exception  occurred in ServiceLocator.getContextDAO(String daoFactoryClassName, String daoClassName)", e);
        }
        return dao;
    }

    /**
     * This method acts as  {@link #getDAO(null, null)}
     * @return
     * @throws ServiceLocatorException
     */
    public DAO getDAO() throws ServiceLocatorException{
        DAO dao = null;
        try{
            dao = DAOFactory.getDAOFactory().getDAO();
        }catch (DaoFactoryException e){
            e.printStackTrace();
            throw new ServiceLocatorException("DaoFactoryException  occurred in ServiceLocator.getContextDAO()", e);
        }catch (Exception e){
            e.printStackTrace();
            throw new ServiceLocatorException("Exception  occurred in ServiceLocator.getContextDAO()", e);
        }
        return dao;
    }



    /**
     * This method looks up a {@link ContextDAO} implementation trough a {@link ContextDAOFactory} following the factoryfactory pattern, and this {@link ContextDAOFactory} is chosen
     * with a look up too.<br/>
     * So what this method does is to look up a {@link ContextDAOFactory} , and then this {@link ContextDAOFactory} looks up the {@link ContextDAO} implementation.<br/>
     *
     * @param contextDaoFactoryClassName specifies which is the {@link ContextDAO} to be looked up and that has to look up the {@link ContextDAO} implementation. <br/>
     * The mapping between the input string <code>contextDaoFactoryClassName</code> and the real {@link ContextDAOFactory} is specified in the <code>mandragora.properties</code> file.<br/>
     * If this parameter is null or empty string will be looked up the {@link it.aco.mandragora.dao.context.ContextDAOFactory} specified in <code>mandragora.properties</code> by the property "ContextDAOFactoryDefaultClass".<br/>
     * <br/>
     * @param contextDaoClassName specifies which {@link ContextDAO} implementation the {@link ContextDAOFactory} specified by <code>contextDaoFactoryClassName</code> has to look up.<br/>
     * The mapping with the {@link ContextDAO} implementation depends by the  real {@link ContextDAOFactory} specified by <code>contextDaoFactoryClassName</code>.<br/>
     * If this parameter is null or empty string the {@link ContextDAO}  implementation that be default for the real {@link ContextDAOFactory} specified by <code>contextDaoFactoryClassName</code> will be looked up and returned to the caller.<br/>
     * Note that each real {@link it.aco.mandragora.dao.context.ContextDAOFactory} can have a different {@link context.ContextDAO}  implementation.
     * <br/>
     * @return the implementation of the interface {@link ContextDAO} specified by the input parameter <code>contextDaoClassName</code> and looked up by the {@link ContextDAOFactory} specified by
     * the input parameter <code>contextDaoFactoryClassName</code> <br/>
     *
     * @throws ServiceLocatorException
     */
    public ContextDAO getContextDAO(String contextDaoFactoryClassName, String contextDaoClassName) throws ServiceLocatorException{
        ContextDAO contextDAO = null;
        try{
            if (contextDaoFactoryClassName!=null && !contextDaoFactoryClassName.equals("") && contextDaoClassName!=null && !contextDaoClassName.equals("")){
                contextDAO = ContextDAOFactory.getContextDAOFactory(contextDaoFactoryClassName).getContextDAO(contextDaoClassName);
            } else if (contextDaoFactoryClassName!=null && !contextDaoFactoryClassName.equals("")){
                contextDAO = ContextDAOFactory.getContextDAOFactory(contextDaoFactoryClassName).getContextDAO();
            } else if (contextDaoClassName!=null && !contextDaoClassName.equals("")){
                contextDAO = ContextDAOFactory.getContextDAOFactory().getContextDAO(contextDaoClassName);
            } else{
                contextDAO = ContextDAOFactory.getContextDAOFactory().getContextDAO();
            }
        }catch (DaoFactoryException e){
            e.printStackTrace();
            throw new ServiceLocatorException("DaoFactoryException  occurred in ServiceLocator.getContextDAO(String contextDaoFactoryClassName, String contextDaoClassName)", e);
        }catch (Exception e){
            e.printStackTrace();
            throw new ServiceLocatorException("Exception  occurred in ServiceLocator.getContextDAO(String contextDaoFactoryClassName, String contextDaoClassName)", e);
        }
        return contextDAO;
    }


    /**
     * This method acts as  {@link #getContextDAO(null, null)}
     * @return
     * @throws ServiceLocatorException
     */
    public ContextDAO getContextDAO() throws ServiceLocatorException{
        ContextDAO contextDAO;
        try{
            contextDAO = ContextDAOFactory.getContextDAOFactory().getContextDAO();
        }catch (DaoFactoryException e){
            e.printStackTrace();
            throw new ServiceLocatorException("DaoFactoryException  occurred in ServiceLocator.getContextDAO()", e);
        }catch (Exception e){
            e.printStackTrace();
            throw new ServiceLocatorException("Exception  occurred in ServiceLocator.getContextDAO()", e);
        }
        return contextDAO;
    }




    /**
     * This method looks up a {@link OjbPbCore} implementation trough a {@link OjbPbCoreFactory} following the factoryfactory pattern, and this {@link OjbPbCoreFactory} is chosen
     * with a look up too.<br/>
     * So what this method does is to look up a {@link OjbPbCoreFactory} , and then this {@link OjbPbCoreFactory} looks up the {@link OjbPbCore} implementation.<br/>
     *
     * @param ojbPbCoreFactoryClassName specifies which is the {@link OjbPbCoreFactory} to be looked up and that has to look up the {@link OjbPbCore} implementation. <br/>
     * The mapping between the input string <code>ojbPbCoreFactoryClassName</code> and the real {@link OjbPbCoreFactory} is specified in the <code>mandragora.properties</code> file.<br/>
     * If this parameter is null or empty string will be looked up the {@link OjbPbCoreFactory} specified in <code>mandragora.properties</code> by the property "OjbPbCoreFactoryDefaultClass".<br/>
     * <br/>
     * @param ojbPbCoreClassName specifies which {@link OjbPbCore} implementation the {@link OjbPbCoreFactory} specified by <code>ojbPbCoreFactoryClassName</code> has to look up.<br/>
     * The mapping with the {@link OjbPbCore} implementation depends by the  real {@link OjbPbCoreFactory} specified by <code>ojbPbCoreFactoryClassName</code>.<br/>
     * If this parameter is null or empty string the OjbPbCore implementation that be default for the real {@link OjbPbCoreFactory} specified by <code>ojbPbCoreFactoryClassName</code> will be looked up and returned to the caller.<br/>
     * Note that each real {@link OjbPbCoreFactory} can have a different OjbPbCore implementation.
     * <br/>
     * @return the implementation of the interface {@link OjbPbCore} specified by the input parameter <code>ojbPbCoreClassName</code> and looked up by the {@link OjbPbCoreFactory} specified by
     * the input parameter <code>ojbPbCoreClassName</code> <br/>
     *
     * @throws ServiceLocatorException
     */
    public OjbPbCore getOjbPbCore(String ojbPbCoreFactoryClassName, String ojbPbCoreClassName) throws ServiceLocatorException{
        OjbPbCore ojbPbCore = null;
        try{
            if (ojbPbCoreFactoryClassName!=null && !ojbPbCoreFactoryClassName.equals("") && ojbPbCoreClassName!=null && !ojbPbCoreClassName.equals("")){
                ojbPbCore= OjbPbCoreFactory.getOjbPbCoreFactory(ojbPbCoreFactoryClassName).getOjbPbCore(ojbPbCoreClassName);
            } else if (ojbPbCoreFactoryClassName!=null && !ojbPbCoreFactoryClassName.equals("")){
                ojbPbCore= OjbPbCoreFactory.getOjbPbCoreFactory(ojbPbCoreFactoryClassName).getOjbPbCore();
            } else if (ojbPbCoreClassName!=null && !ojbPbCoreClassName.equals("")){
                ojbPbCore= OjbPbCoreFactory.getOjbPbCoreFactory().getOjbPbCore(ojbPbCoreClassName);
            } else{
                ojbPbCore= OjbPbCoreFactory.getOjbPbCoreFactory().getOjbPbCore();
            }
        }catch (OjbPbCoreFactoryException e){
            e.printStackTrace();
            throw new ServiceLocatorException("OjbPbCoreFactoryException  occurred in ServiceLocator.getOjbPbCore(String ojbPbCoreFactoryClassName, String ojbPbCoreClassName)", e);
        }catch (Exception e){
            e.printStackTrace();
            throw new ServiceLocatorException("Exception  occurred in ServiceLocator.getOjbPbCore(String ojbPbCoreFactoryClassName, String ojbPbCoreClassName)", e);
        }
        return ojbPbCore;
    }


    /**
     * This method acts as  {@link #getOjbPbCore(null, null)}
     * @return
     * @throws ServiceLocatorException
     */
    public OjbPbCore getOjbPbCore() throws ServiceLocatorException{
        OjbPbCore ojbPbCore = null;
        try{
            ojbPbCore= OjbPbCoreFactory.getOjbPbCoreFactory().getOjbPbCore();
        }catch (OjbPbCoreFactoryException e){
            e.printStackTrace();
            throw new ServiceLocatorException("OjbPbCoreFactoryException  occurred in ServiceLocator.getOjbPbCore()", e);
        }catch (Exception e){
            e.printStackTrace();
            throw new ServiceLocatorException("Exception  occurred in ServiceLocator.getOjbPbCore()", e);
        }
        return ojbPbCore;
    }



    /**
     * This method looks up a {@link PersistenceBrokerSupport} implementation trough a {@link PersistenceBrokerSupportFactory} following the factoryfactory pattern, and this {@link it.aco.mandragora.dao.impl.ojb.pb.support.PersistenceBrokerSupportFactory} is chosen
     * with a look up too.<br/>
     * So what this method does is to look up a {@link PersistenceBrokerSupportFactory} , and then this {@link it.aco.mandragora.dao.impl.ojb.pb.support.PersistenceBrokerSupportFactory} looks up the {@link it.aco.mandragora.dao.impl.ojb.pb.support.PersistenceBrokerSupport} implementation.<br/>
     *
     * @param persistenceBrokerSupportFactoryClassName specifies which is the {@link OjbPbCoreFactory} to be looked up and that has to look up the {@link OjbPbCore} implementation. <br/>
     * The mapping between the input string <code>ojbPbCoreFactoryClassName</code> and the real {@link OjbPbCoreFactory} is specified in the <code>mandragora.properties</code> file.<br/>
     * If this parameter is null or empty string will be looked up the {@link OjbPbCoreFactory} specified in <code>mandragora.properties</code> by the property "OjbPbCoreFactoryDefaultClass".<br/>
     * <br/>
     * @param persistenceBrokerSupportClassName specifies which {@link it.aco.mandragora.dao.impl.ojb.pb.support.PersistenceBrokerSupport} implementation the {@link it.aco.mandragora.dao.impl.ojb.pb.support.PersistenceBrokerSupportFactory} specified by <code>persistenceBrokerSupportFactoryClassName</code> has to look up.<br/>
     * The mapping with the {@link it.aco.mandragora.dao.impl.ojb.pb.support.PersistenceBrokerSupport} implementation depends by the  real {@link it.aco.mandragora.dao.impl.ojb.pb.support.PersistenceBrokerSupportFactory} specified by <code>persistenceBrokerSupportFactoryClassName</code>.<br/>
     * If this parameter is null or empty string the PersistenceBrokerSupport implementation that be default for the real {@link it.aco.mandragora.dao.impl.ojb.pb.support.PersistenceBrokerSupportFactory} specified by <code>persistenceBrokerSupportFactoryClassName</code> will be looked up and returned to the caller.<br/>
     * Note that each real {@link it.aco.mandragora.dao.impl.ojb.pb.support.PersistenceBrokerSupportFactory} can have a different PersistenceBrokerSupport implementation.
     * <br/>
     * @return the implementation of the interface {@link it.aco.mandragora.dao.impl.ojb.pb.support.PersistenceBrokerSupport} specified by the input parameter <code>persistenceBrokerSupportClassName</code> and looked up by the {@link it.aco.mandragora.dao.impl.ojb.pb.support.PersistenceBrokerSupportFactory} specified by
     * the input parameter <code>persistenceBrokerSupportClassName</code> <br/>
     *
     * @throws ServiceLocatorException
     */
    public PersistenceBrokerSupport getPersistenceBrokerSupport(String persistenceBrokerSupportFactoryClassName, String persistenceBrokerSupportClassName) throws ServiceLocatorException{
        PersistenceBrokerSupport persistenceBrokerSupport = null;
        try{
            if (persistenceBrokerSupportFactoryClassName!=null && !persistenceBrokerSupportFactoryClassName.equals("") && persistenceBrokerSupportClassName!=null && !persistenceBrokerSupportClassName.equals("")){
                persistenceBrokerSupport= PersistenceBrokerSupportFactory.getPersistenceBrokerSupportFactory(persistenceBrokerSupportFactoryClassName).getPersistenceBrokerSupport(persistenceBrokerSupportClassName);
            } else if (persistenceBrokerSupportFactoryClassName!=null && !persistenceBrokerSupportFactoryClassName.equals("")){
                persistenceBrokerSupport= PersistenceBrokerSupportFactory.getPersistenceBrokerSupportFactory(persistenceBrokerSupportFactoryClassName).getPersistenceBrokerSupport();
            } else if (persistenceBrokerSupportClassName!=null && !persistenceBrokerSupportClassName.equals("")){
                persistenceBrokerSupport= PersistenceBrokerSupportFactory.getPersistenceBrokerSupportFactory().getPersistenceBrokerSupport(persistenceBrokerSupportClassName);
            } else{
                persistenceBrokerSupport= PersistenceBrokerSupportFactory.getPersistenceBrokerSupportFactory().getPersistenceBrokerSupport();
            }
        }catch (PersistenceBrokerSupportFactoryException e){
            e.printStackTrace();
            throw new ServiceLocatorException("PersistenceBrokerSupportFactoryException  occurred in ServiceLocator.getPersistenceBrokerSupport(String persistenceBrokerSupportFactoryClassName, String persistenceBrokerSupportClassName)", e);
        }catch (Exception e){
            e.printStackTrace();
            throw new ServiceLocatorException("Exception  occurred in ServiceLocator.getPersistenceBrokerSupport(String persistenceBrokerSupportFactoryClassName, String persistenceBrokerSupportClassName)", e);
        }
        return persistenceBrokerSupport;
    }


    /**
     * This method acts as  {@link #getPersistenceBrokerSupport(null, null)}
     * @return
     * @throws ServiceLocatorException
     */
    public PersistenceBrokerSupport getPersistenceBrokerSupport() throws ServiceLocatorException{
        PersistenceBrokerSupport persistenceBrokerSupport = null;
        try{
            persistenceBrokerSupport= PersistenceBrokerSupportFactory.getPersistenceBrokerSupportFactory().getPersistenceBrokerSupport();
        }catch (PersistenceBrokerSupportFactoryException e){
            e.printStackTrace();
            throw new ServiceLocatorException("PersistenceBrokerSupportFactoryException  occurred in ServiceLocator.getPersistenceBrokerSupport()", e);
        }catch (Exception e){
            e.printStackTrace();
            throw new ServiceLocatorException("Exception  occurred in ServiceLocator.getPersistenceBrokerSupport()", e);
        }
        return persistenceBrokerSupport;
    }

    /**
     * This method looks up a {@link MethodInterceptor} implementation trough a {@link MethodInterceptorFactory} following the factoryfactory pattern, and this {@link MethodInterceptorFactory} is chosen
     * with a look up too.<br/>
     * So what this method does is to look up a {@link MethodInterceptorFactory} , and then this {@link MethodInterceptorFactory} looks up the {@link MethodInterceptor} implementation.<br/>
     *
     * @param methodInterceptorFactoryClassName specifies which is the {@link MethodInterceptorFactory} to be looked up and that has to look up the {@link MethodInterceptor} implementation. <br/>
     * The mapping between the input string <code>methodInterceptorClassName</code> and the real {@link MethodInterceptorFactory} is specified in the <code>mandragora.properties</code> file.<br/>
     * If this parameter is null or empty string will be looked up the {@link MethodInterceptorFactory} specified in <code>mandragora.properties</code> by the property "MethodInterceptorFactoryDefaultClass".<br/>
     * <br/>
     * @param methodInterceptorClassName specifies which {@link MethodInterceptor} implementation the {@link MethodInterceptorFactory} specified by <code>methodInterceptorFactoryClassName</code> has to look up.<br/>
     * The mapping with the {@link MethodInterceptor} implementation depends by the  real {@link MethodInterceptorFactory} specified by <code>methodInterceptorFactoryClassName</code>.<br/>
     * If this parameter is null or empty string the PersistenceBrokerSupport implementation that be default for the real {@link it.aco.mandragora.dao.impl.ojb.pb.support.PersistenceBrokerSupportFactory} specified by <code>persistenceBrokerSupportFactoryClassName</code> will be looked up and returned to the caller.<br/>
     * Note that each real {@link MethodInterceptorFactory} can have a different MethodInterceptor implementation.
     * <br/>
     * @return the implementation of the interface {@link MethodInterceptor} specified by the input parameter <code>methodInterceptorClassName</code> and looked up by the {@link MethodInterceptorFactory} specified by
     * the input parameter <code>methodInterceptorClassName</code> <br/>
     *
     * @throws ServiceLocatorException
     */
    public MethodInterceptor getMethodInterceptor(String methodInterceptorFactoryClassName, String methodInterceptorClassName) throws ServiceLocatorException{
        MethodInterceptor methodInterceptor;
        try{
            if (methodInterceptorFactoryClassName!=null && !methodInterceptorFactoryClassName.equals("") && methodInterceptorClassName!=null && !methodInterceptorClassName.equals("")){
                methodInterceptor= MethodInterceptorFactory.getMethodInterceptorFactory(methodInterceptorFactoryClassName).getMethodInterceptor(methodInterceptorClassName);
            } else if (methodInterceptorFactoryClassName!=null && !methodInterceptorFactoryClassName.equals("")){
                methodInterceptor= MethodInterceptorFactory.getMethodInterceptorFactory(methodInterceptorFactoryClassName).getMethodInterceptor();
            } else if (methodInterceptorClassName!=null && !methodInterceptorClassName.equals("")){
                methodInterceptor= MethodInterceptorFactory.getMethodInterceptorFactory().getMethodInterceptor(methodInterceptorClassName);
            } else{
                methodInterceptor= MethodInterceptorFactory.getMethodInterceptorFactory().getMethodInterceptor();
            }
        }catch (MethodInterceptorFactoryException e){
            e.printStackTrace();
            throw new ServiceLocatorException("MethodInterceptorFactoryException  occurred in ServiceLocator.getMethodInterceptor(String methodInterceptorFactoryClassName, String methodInterceptorClassName)", e);
        }catch (Exception e){
            e.printStackTrace();
            throw new ServiceLocatorException("Exception  occurred in ServiceLocator.getMethodInterceptor(String methodInterceptorFactoryClassName, String methodInterceptorClassName)", e);
        }
        return methodInterceptor;
    }


    /**
     * This method acts as  {@link #getMethodInterceptor(null, null)}
     * @return
     * @throws ServiceLocatorException
     */
    public MethodInterceptor getMethodInterceptor() throws ServiceLocatorException{
        MethodInterceptor methodInterceptor;
        try{
            methodInterceptor= MethodInterceptorFactory.getMethodInterceptorFactory().getMethodInterceptor();
        }catch (MethodInterceptorFactoryException e){
            e.printStackTrace();
            throw new ServiceLocatorException("MethodInterceptorFactoryException  occurred in ServiceLocator.getMethodInterceptor()", e);
        }catch (Exception e){
            e.printStackTrace();
            throw new ServiceLocatorException("Exception  occurred in ServiceLocator.getMethodInterceptor()", e);
        }
        return methodInterceptor;
    }


    /**
     * This method looks up a {@link ApplicationService} implementation trough a {@link ApplicationServiceFactory} following the factoryfactory pattern, and this {@link ApplicationServiceFactory} is chosen
     * with a look up too.<br/>
     * So what this method does is to look up a {@link ApplicationServiceFactory} , and then this {@link ApplicationServiceFactory} looks up the {@link ApplicationService} implementation.<br/>
     *
     * @param applicationServiceFactoryClassName specifies which is the {@link ApplicationService} to be looked up and that has to look up the {@link ApplicationService} implementation. <br/>
     * The mapping between the input string <code>applicationServiceFactoryClassName</code> and the real {@link ApplicationServiceFactory} is specified in the <code>mandragora.properties</code> file.<br/>
     * If this parameter is null or empty string will be looked up the {@link ApplicationServiceFactory} specified in <code>mandragora.properties</code> by the property "ApplicationServiceFactoryDefaultClass".<br/>
     * <br/>
     * @param applicationServiceClassName specifies which {@link ApplicationService} implementation the {@link ApplicationServiceFactory} specified by <code>applicationServiceFactoryClassName</code> has to look up.<br/>
     * The mapping with the {@link ApplicationService} implementation depends by the  real {@link ApplicationServiceFactory} specified by <code>applicationServiceFactoryClassName</code>.<br/>
     * If this parameter is null or empty string the ApplicationService implementation that be default for the real {@link ApplicationServiceFactory} specified by <code>applicationServiceFactoryClassName</code> will be looked up and returned to the caller.<br/>
     * Note that each real {@link ApplicationServiceFactory} can have a different ApplicationService implementation.
     * <br/>
     * @return the implementation of the interface {@link ApplicationService} specified by the input parameter <code>applicationServiceClassName</code> and looked up by the {@link ApplicationServiceFactory} specified by
     * the input parameter <code>applicationServiceClassName</code> <br/>
     *
     * @throws ServiceLocatorException
     */
    public ApplicationService getApplicationService(String applicationServiceFactoryClassName, String applicationServiceClassName) throws ServiceLocatorException{
        ApplicationService applicationService = null;
        try{
            if (applicationServiceFactoryClassName!=null && !applicationServiceFactoryClassName.equals("") && applicationServiceClassName!=null && !applicationServiceClassName.equals("")){
                applicationService= ApplicationServiceFactory.getApplicationServiceFactory(applicationServiceFactoryClassName).getApplicationService(applicationServiceClassName);
            } else if (applicationServiceFactoryClassName!=null && !applicationServiceFactoryClassName.equals("")){
                applicationService= ApplicationServiceFactory.getApplicationServiceFactory(applicationServiceFactoryClassName).getApplicationService();
            } else if (applicationServiceClassName!=null && !applicationServiceClassName.equals("")){
                applicationService= ApplicationServiceFactory.getApplicationServiceFactory().getApplicationService(applicationServiceClassName);
            } else{
                applicationService= ApplicationServiceFactory.getApplicationServiceFactory().getApplicationService();
            }
        }catch (ApplicationServiceFactoryException e){
            e.printStackTrace();
            throw new ServiceLocatorException("ApplicationServiceFactoryException  occurred in ServiceLocator.getApplicationService(String applicationServiceFactoryClassName, String applicationServiceClassName)", e);
        }catch (Exception e){
            e.printStackTrace();
            throw new ServiceLocatorException("Exception  occurred in ServiceLocator.getApplicationService(String applicationServiceFactoryClassName, String applicationServiceClassName)", e);
        }
        return applicationService;
    }


    /**
     * This method acts as  {@link #getApplicationService(null, null)}
     * @return
     * @throws ServiceLocatorException
     */
    public ApplicationService getApplicationService() throws ServiceLocatorException{
        ApplicationService applicationService;
        try{
            applicationService= ApplicationServiceFactory.getApplicationServiceFactory().getApplicationService();
        }catch (ApplicationServiceFactoryException e){
            e.printStackTrace();
            throw new ServiceLocatorException("ApplicationServiceFactoryException  occurred in ServiceLocator.getContextApplicationService()", e);
        }catch (Exception e){
            e.printStackTrace();
            throw new ServiceLocatorException("Exception  occurred in ServiceLocator.getContextApplicationService()", e);
        }
        return applicationService;
    }



    /**
     * This method looks up a {@link ContextApplicationService} implementation trough a {@link ContextApplicationServiceFactory} following the factoryfactory pattern, and such {@link ContextApplicationServiceFactory} is chosen
     * with a look up too.<br/>
     * So what this method does is to look up a {@link ContextApplicationServiceFactory} , and then such {@link ContextApplicationServiceFactory} looks up the {@link ContextApplicationService} implementation.<br/>
     *
     * @param contextApplicationServiceFactoryClassName specifies which is the {@link ContextApplicationServiceFactory} to be looked up and that has to look up the {@link ContextApplicationService} implementation. <br/>
     * The mapping between the input string <code>contextApplicationServiceFactoryClassName</code> and the real {@link ContextApplicationServiceFactory} is specified in the <code>mandragora.properties</code> file.<br/>
     * If this parameter is null or empty string will be looked up the {@link ContextApplicationServiceFactory} specified in <code>mandragora.properties</code> by the property "ContextApplicationServiceFactoryDefaultClass".<br/>
     * <br/>
     * @param contextApplicationServiceClassName specifies which {@link ContextApplicationService} implementation the {@link ContextApplicationServiceFactory} specified by <code>contextApplicationServiceFactoryClassName</code> has to look up.<br/>
     * The mapping with the {@link ContextApplicationService} implementation depends by the  real {@link ContextApplicationServiceFactory} specified by <code>applicationServiceFactoryClassName</code>.<br/>
     * If this parameter is null or empty string the ContextApplicationService implementation that be default for the real {@link ContextApplicationServiceFactory} specified by <code>contextApplicationServiceFactoryClassName</code> will be looked up and returned to the caller.<br/>
     * Note that each real {@link ContextApplicationServiceFactory} can have a different ContextApplicationService default implementation.
     * <br/>
     * @return the implementation of the interface {@link ContextApplicationService} specified by the input parameter <code>contextApplicationServiceClassName</code> and looked up by the {@link ContextApplicationServiceFactory} specified by
     * the input parameter <code>contextApplicationServiceFactoryClassName</code> <br/>
     *
     * @throws ServiceLocatorException
     */
    public ContextApplicationService getContextApplicationService(String contextApplicationServiceFactoryClassName, String contextApplicationServiceClassName) throws ServiceLocatorException{
        ContextApplicationService contextApplicationService = null;
        try{
            if (contextApplicationServiceFactoryClassName!=null && !contextApplicationServiceFactoryClassName.equals("") && contextApplicationServiceClassName!=null && !contextApplicationServiceClassName.equals("")){
                contextApplicationService= ContextApplicationServiceFactory.getContextApplicationServiceFactory(contextApplicationServiceFactoryClassName).getContextApplicationService(contextApplicationServiceClassName);
            } else if (contextApplicationServiceFactoryClassName!=null && !contextApplicationServiceFactoryClassName.equals("")){
                contextApplicationService= ContextApplicationServiceFactory.getContextApplicationServiceFactory(contextApplicationServiceFactoryClassName).getContextApplicationService();
            } else if (contextApplicationServiceClassName!=null && !contextApplicationServiceClassName.equals("")){
                contextApplicationService= ContextApplicationServiceFactory.getContextApplicationServiceFactory().getContextApplicationService(contextApplicationServiceClassName);
            } else{
                contextApplicationService= ContextApplicationServiceFactory.getContextApplicationServiceFactory().getContextApplicationService();
            }
        }catch (ApplicationServiceFactoryException e){
            e.printStackTrace();
            throw new ServiceLocatorException("ApplicationServiceFactoryException  occurred in ServiceLocator.getContextApplicationService(String contextApplicationServiceFactoryClassName, String contextApplicationServiceClassName)", e);
        }catch (Exception e){
            e.printStackTrace();
            throw new ServiceLocatorException("Exception  occurred in ServiceLocator.getContextApplicationService(String contextApplicationServiceFactoryClassName, String contextApplicationServiceClassName)", e);
        }
        return contextApplicationService;
    }


    /**
     * This method acts as  {@link #getContextApplicationService(null, null)}
     * @return
     * @throws ServiceLocatorException
     */
    public ContextApplicationService getContextApplicationService() throws ServiceLocatorException{
        ContextApplicationService contextApplicationService;
        try{
            contextApplicationService= ContextApplicationServiceFactory.getContextApplicationServiceFactory().getContextApplicationService();
        }catch (ApplicationServiceFactoryException e){
            e.printStackTrace();
            throw new ServiceLocatorException("ApplicationServiceFactoryException  occurred in ServiceLocator.getContextApplicationService()", e);
        }catch (Exception e){
            e.printStackTrace();
            throw new ServiceLocatorException("Exception  occurred in ServiceLocator.getContextApplicationService()", e);
        }
        return contextApplicationService;
    }



    /**
     * This method looks up a {@link ServiceFacade} implementation trough a {@link ServiceFacadeFactory} following the factoryfactory pattern, and this {@link ServiceFacadeFactory} is chosen
     * with a look up too.<br/>
     * So what this method does is to look up a {@link ServiceFacadeFactory} , and then this {@link ServiceFacadeFactory} looks up the {@link ServiceFacade} implementation.<br/>
     *
     * @param serviceFacadeFactoryClassName specifies which is the {@link ServiceFacade} to be looked up and that has to look up the {@link ServiceFacade} implementation. <br/>
     * The mapping between the input string <code>serviceFacadeFactoryClassName</code> and the real {@link ServiceFacadeFactory} is specified in the <code>mandragora.properties</code> file.<br/>
     * If this parameter is null or empty string will be looked up the {@link ServiceFacadeFactory} specified in <code>mandragora.properties</code> by the property "ServiceFacadeFactoryDefaultClass".<br/>
     * <br/>
     * @param serviceFacadeClassName specifies which {@link ServiceFacade} implementation the {@link ServiceFacadeFactory} specified by <code>serviceFacadeFactoryClassName</code> has to look up.<br/>
     * The mapping with the {@link ServiceFacade} implementation depends by the  real {@link ServiceFacadeFactory} specified by <code>serviceFacadeFactoryClassName</code>.<br/>
     * If this parameter is null or empty string the {@link ServiceFacade}  implementation that be default for the real {@link ServiceFacadeFactory} specified by <code>serviceFacadeFactoryClassName</code> will be looked up and returned to the caller.<br/>
     * Note that each real {@link ServiceFacadeFactory} can have a different {@link ServiceFacade}  implementation.
     * <br/>
     * @return the implementation of the interface {@link ServiceFacade} specified by the input parameter <code>serviceFacadeClassName</code> and looked up by the {@link ServiceFacadeFactory} specified by
     * the input parameter <code>serviceFacadeClassName</code> <br/>
     *
     * @throws ServiceLocatorException
     */
    public ServiceFacade getServiceFacade(String serviceFacadeFactoryClassName, String serviceFacadeClassName) throws ServiceLocatorException{
        ServiceFacade serviceFacade = null;
        try{
            if (serviceFacadeFactoryClassName!=null && !serviceFacadeFactoryClassName.equals("") && serviceFacadeClassName!=null && !serviceFacadeClassName.equals("")){
                serviceFacade= ServiceFacadeFactory.getServiceFacadeFactory(serviceFacadeFactoryClassName).getServiceFacade(serviceFacadeClassName);
            } else if (serviceFacadeFactoryClassName!=null && !serviceFacadeFactoryClassName.equals("")){
                serviceFacade= ServiceFacadeFactory.getServiceFacadeFactory(serviceFacadeFactoryClassName).getServiceFacade();
            } else if (serviceFacadeClassName!=null && !serviceFacadeClassName.equals("")){
                serviceFacade= ServiceFacadeFactory.getServiceFacadeFactory().getServiceFacade(serviceFacadeClassName);
            } else{
                serviceFacade= ServiceFacadeFactory.getServiceFacadeFactory().getServiceFacade();
            }
        }catch (ServiceFacadeFactoryException e){
            e.printStackTrace();
            throw new ServiceLocatorException("ServiceFacadeFactoryException  occurred in ServiceLocator.getContextServiceFacade(String serviceFacadeFactoryClassName, String serviceFacadeClassName)", e);
        }catch (Exception e){
            e.printStackTrace();
            throw new ServiceLocatorException("Exception  occurred in ServiceLocator.getContextServiceFacade(String serviceFacadeFactoryClassName, String serviceFacadeClassName)", e);
        }
        return serviceFacade;
    }


    /**
     * This method acts as  {@link #getServiceFacade(null, null)}
     * @return
     * @throws ServiceLocatorException
     */
    public ServiceFacade getServiceFacade() throws ServiceLocatorException{
        ServiceFacade serviceFacade;
        try{
            serviceFacade= ServiceFacadeFactory.getServiceFacadeFactory().getServiceFacade();
        }catch (ServiceFacadeFactoryException e){
            e.printStackTrace();
            throw new ServiceLocatorException("ServiceFacadeFactoryException  occurred in ServiceLocator.getContextServiceFacade()", e);
        }catch (Exception e){
            e.printStackTrace();
            throw new ServiceLocatorException("Exception  occurred in ServiceLocator.getContextServiceFacade()", e);
        }
        return serviceFacade;
    }










    /**
     * This method looks up a {@link ContextServiceFacade} implementation trough a {@link ContextServiceFacadeFactory} following the factoryfactory pattern, and this {@link ContextServiceFacadeFactory} is chosen
     * with a look up too.<br/>
     * So what this method does is to look up a {@link ContextServiceFacadeFactory} , and then such {@link ContextServiceFacadeFactory} looks up the {@link ContextServiceFacade} implementation.<br/>
     *
     * @param contextServiceFacadeFactoryClassName specifies which is the {@link ContextServiceFacadeFactory} to be looked up and that has to look up the {@link ContextServiceFacade} implementation. <br/>
     * The mapping between the input string <code>contextServiceFacadeFactoryClassName</code> and the real {@link ContextServiceFacadeFactory} is specified in the <code>mandragora.properties</code> file.<br/>
     * If this parameter is null or empty string will be looked up the {@link ContextServiceFacadeFactory} specified in <code>Mandragora.properties</code> by the property "ContextServiceFacadeFactoryDefaultClass".<br/>
     * <br/>
     * @param contextServiceFacadeClassName specifies which {@link ContextServiceFacade} implementation the {@link ContextServiceFacadeFactory} specified by <code>contextServiceFacadeFactoryClassName</code> has to look up.<br/>
     * The mapping with the {@link ContextServiceFacade} implementation depends by the  real {@link ContextServiceFacadeFactory} specified by <code>contextServiceFacadeFactoryClassName</code>.<br/>
     * If this parameter is null or empty string the {@link ContextServiceFacade}  implementation that be default for the real {@link ContextServiceFacadeFactory} specified by <code>contextServiceFacadeFactoryClassName</code> will be looked up and returned to the caller.<br/>
     * Note that each real {@link ContextServiceFacadeFactory} can have a different {@link ContextServiceFacade} default implementation.
     * <br/>
     * @return the implementation of the interface {@link ContextServiceFacade} specified by the input parameter <code>contextServiceFacadeClassName</code> and looked up by the {@link ContextServiceFacadeFactory} specified by
     * the input parameter <code>contextServiceFacadeClassName</code> <br/>
     *
     * @throws ServiceLocatorException
     */
    public ContextServiceFacade getContextServiceFacade(String contextServiceFacadeFactoryClassName, String contextServiceFacadeClassName) throws ServiceLocatorException{
        ContextServiceFacade contextServiceFacade = null;
        try{
            if (contextServiceFacadeFactoryClassName!=null && !contextServiceFacadeFactoryClassName.equals("") && contextServiceFacadeClassName!=null && !contextServiceFacadeClassName.equals("")){
                contextServiceFacade= ContextServiceFacadeFactory.getContextServiceFacadeFactory(contextServiceFacadeFactoryClassName).getContextServiceFacade(contextServiceFacadeClassName);
            } else if (contextServiceFacadeFactoryClassName!=null && !contextServiceFacadeFactoryClassName.equals("")){
                contextServiceFacade= ContextServiceFacadeFactory.getContextServiceFacadeFactory(contextServiceFacadeFactoryClassName).getContextServiceFacade();
            } else if (contextServiceFacadeClassName!=null && !contextServiceFacadeClassName.equals("")){
                contextServiceFacade= ContextServiceFacadeFactory.getContextServiceFacadeFactory().getContextServiceFacade(contextServiceFacadeClassName);
            } else{
                contextServiceFacade= ContextServiceFacadeFactory.getContextServiceFacadeFactory().getContextServiceFacade();
            }
        }catch (ServiceFacadeFactoryException e){
            e.printStackTrace();
            throw new ServiceLocatorException("ServiceFacadeFactoryException  occurred in ServiceLocator.getContextServiceFacade(String contextServiceFacadeFactoryClassName, String contextServiceFacadeClassName))", e);
        }catch (Exception e){
            e.printStackTrace();
            throw new ServiceLocatorException("Exception  occurred in ServiceLocator.getContextServiceFacade(String contextServiceFacadeFactoryClassName, String contextServiceFacadeClassName)", e);
        }
        return contextServiceFacade;
    }


    /**
     * This method acts as  {@link #getContextServiceFacade(null, null)}
     * @return
     * @throws ServiceLocatorException
     */
    public ContextServiceFacade getContextServiceFacade() throws ServiceLocatorException{
        ContextServiceFacade contextServiceFacade;
        try{
            contextServiceFacade= ContextServiceFacadeFactory.getContextServiceFacadeFactory().getContextServiceFacade();
        }catch (ServiceFacadeFactoryException e){
            e.printStackTrace();
            throw new ServiceLocatorException("ServiceFacadeFactoryException  occurred in ServiceLocator.getContextServiceFacade()", e);
        }catch (Exception e){
            e.printStackTrace();
            throw new ServiceLocatorException("Exception  occurred in ServiceLocator.getContextServiceFacade()", e);
        }
        return contextServiceFacade;
    }







    /**
     * This method looks up a {@link ContextBD} implementation trough a {@link ContextBDFactory} following the factoryfactory pattern, and such {@link ContextBDFactory} is chosen
     * with a look up too.<br/>
     * So what this method does is to look up a {@link ContextBDFactory} , and then such {@link ContextBDFactory} looks up the {@link ContextBD} implementation.<br/>
     *
     * @param contextBDFactoryClassName specifies which is the {@link ContextBDFactory} to be looked up and that has to look up the {@link ContextBD} implementation. <br/>
     * The mapping between the input string <code>contextBDFactoryClassName</code> and the real {@link ContextBDFactory} is specified in the <code>Mandragora.properties</code> file.<br/>
     * If this parameter is null or empty string will be looked up the {@link ContextBDFactory} specified in <code>Mandragora.properties</code> by the property "ContextServiceFacadeFactoryDefaultClass".<br/>
     * <br/>
     * @param contextBDClassName specifies which {@link ContextBD} implementation the {@link ContextBDFactory} specified by <code>contextBDFactoryClassName</code> has to look up.<br/>
     * The mapping with the {@link ContextBD} implementation depends by the  real {@link ContextBDFactory} specified by <code>contextBDFactoryClassName</code>.<br/>
     * If this parameter is null or empty string the {@link ContextBD}  implementation that be default for the real {@link ContextBDFactory} specified by <code>contextBDFactoryClassName</code> will be looked up and returned to the caller.<br/>
     * Note that each real {@link ContextServiceFacadeFactory} can have a different {@link ContextServiceFacade} default implementation.
     * <br/>
     * @return the implementation of the interface {@link ContextBD} specified by the input parameter <code>contextBDClassName</code> and looked up by the {@link ContextBDFactory} specified by
     * the input parameter <code>contextServiceFacadeClassName</code> <br/>
     *
     * @throws ServiceLocatorException
     */
    public ContextBD getContextBD(String contextBDFactoryClassName, String contextBDClassName) throws ServiceLocatorException{
        ContextBD contextBD = null;
        try{
            if (contextBDFactoryClassName!=null && !contextBDFactoryClassName.equals("") && contextBDClassName!=null && !contextBDClassName.equals("")){
                contextBD= ContextBDFactory.getContextBDFactory(contextBDFactoryClassName).getContextBD(contextBDClassName);
            } else if (contextBDFactoryClassName!=null && !contextBDFactoryClassName.equals("")){
                contextBD= ContextBDFactory.getContextBDFactory(contextBDFactoryClassName).getContextBD();
            } else if (contextBDClassName!=null && !contextBDClassName.equals("")){
                contextBD= ContextBDFactory.getContextBDFactory().getContextBD(contextBDClassName);
            } else{
                contextBD= ContextBDFactory.getContextBDFactory().getContextBD();
            }
        }catch (BdFactoryException e){
            e.printStackTrace();
            throw new ServiceLocatorException("BdFactoryException  occurred in ServiceLocator.getContextBD(String contextBDFactoryClassName, String contextBDClassName)", e);
        }catch (Exception e){
            e.printStackTrace();
            throw new ServiceLocatorException("Exception  occurred in ServiceLocator.getContextBD(String contextBDFactoryClassName, String contextBDClassName)", e);
        }
        return contextBD;
    }


    /**
     * This method acts as  {@link #getContextBD(null, null)}
     * @return
     * @throws ServiceLocatorException
     */
    public ContextBD getContextBD() throws ServiceLocatorException{
        ContextBD contextBD;
        try{
            contextBD= ContextBDFactory.getContextBDFactory().getContextBD();
        }catch (BdFactoryException e){
            e.printStackTrace();
            throw new ServiceLocatorException("BdFactoryException  occurred in ServiceLocator.getContextBD()", e);
        }catch (Exception e){
            e.printStackTrace();
            throw new ServiceLocatorException("Exception  occurred in ServiceLocator.getContextBD()", e);
        }
        return contextBD;
    }




















    public Scheduler  findScheduler(){
        return scheduler;
    }

    public EJBHome getEJBHome(String pServiceId) throws ServiceLocatorException {

	    /*Trying to find the JNDI Name for the requested service*/
	  	EJBHome ejbHome = null;
        String serviceName = null;

        try {
            /*Checking to see if I can find the EJBHome interface in cache*/
            serviceName = Utils.getStringFromMandragoraProperties(pServiceId);
            log.info("serviceName ="+serviceName);
            //if (ejbHomeCache.containsKey(serviceName)) {  changed by ale on 04/03/2007
            if (ejbHomeCache.containsKey(pServiceId)) {
                //ejbHome = (EJBHome) ejbHomeCache.get(serviceName);
                ejbHome = (EJBHome) ejbHomeCache.get(pServiceId);
                //log.info("serviceName "+serviceName+"found in cache");  changed by ale on 04/03/2007
                log.info("pServiceId "+pServiceId+"found in cache");
                return ejbHome;
            } else {
                //log.info("serviceName "+serviceName+" NOT found in cache"); changed by ale on 04/03/2007
                log.info("pServiceId "+pServiceId+" NOT found in cache");
                /*
                 * If I could not find the EJBHome interface in the cache, look it
                 * up and then cache it.
                 *
                */
                Context ctx = new InitialContext();
                log.info("ctx "+ctx.toString());
                //Object jndiRef = ctx.lookup(serviceName);  changed by ale on 04/03/2007
                Object jndiRef = ctx.lookup(pServiceId);
                log.info("jndiRef "+jndiRef.toString());
                // start added by alessandro on 05/03/2007
                Configurator configurator = MandragoraConfigurator.getInstance();
                log.info("configurator "+configurator.toString());
                Configuration config = configurator.getConfigurationFor(null);
                log.info("config "+config.toString());
                Class eJBHomeRef=config.getClass(pServiceId, null);
                // end added by alessandro on 05/03/2007

                //Class eJBHomeRef=MandragoraConfigurator.getInstance().getConfigurationFor(null).getClass(serviceName, null); deleted by ale on 05/03/2007

                log.info("built eJBHomeRef ");

                if(eJBHomeRef==null){
                    log.error("eJBHomeRef is null ");
                }else{
                    log.info("eJBHomeRef "+eJBHomeRef.toString());
                }
                Object portableObj = PortableRemoteObject.narrow(jndiRef, eJBHomeRef);

                ejbHome = (EJBHome) portableObj;

                ejbHomeCache.put(pServiceId, ejbHome);
                return ejbHome;
            }
        } catch (NamingException e) {
        throw new ServiceLocatorException("Naming exception error in ServiceLocator.getEJBHome(String pServiceId): "+e,e);
        } catch (Exception e) {
            throw new ServiceLocatorException("General exception in ServiceLocator.getEJBHome(String pServiceId): "+e, e);
        }
    }

}