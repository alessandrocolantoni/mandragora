/* ====================================================================
 *		      GNU GENERAL PUBLIC LICENSE
 *		         Version 2, June 1991
 *
 *    Copyright (C) 1989, 1991 Free Software Foundation, Inc.
 *                        51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *    Everyone is permitted to copy and distribute verbatim copies
 *  of this license document, but changing it is not allowed.
 *
 *  			    Preamble
 *
 *    The licenses for most software are designed to take away your
 *  freedom to share and change it.  By contrast, the GNU General Public
 *  License is intended to guarantee your freedom to share and change free
 *  software--to make sure the software is free for all its users.  This
 *  General Public License applies to most of the Free Software
 *  Foundation's software and to any other program whose authors commit to
 *  using it.  (Some other Free Software Foundation software is covered by
 *  the GNU Library General Public License instead.)  You can apply it to
 *  your programs, too.
 *
 *    When we speak of free software, we are referring to freedom, not
 *  price.  Our General Public Licenses are designed to make sure that you
 *  have the freedom to distribute copies of free software (and charge for
 *  this service if you wish), that you receive source code or can get it
 *  if you want it, that you can change the software or use pieces of it
 *  in new free programs; and that you know you can do these things.
 *
 *     To protect your rights, we need to make restrictions that forbid
 *  anyone to deny you these rights or to ask you to surrender the rights.
 *  These restrictions translate to certain responsibilities for you if you
 *  distribute copies of the software, or if you modify it.
 *
 *     For example, if you distribute copies of such a program, whether
 *  gratis or for a fee, you must give the recipients all the rights that
 *  you have.  You must make sure that they, too, receive or can get the
 *  source code.  And you must show them these terms so they know their
 *  rights.
 *
 *     We protect your rights with two steps: (1) copyright the software, and
 *  (2) offer you this license which gives you legal permission to copy,
 *  distribute and/or modify the software.
 *
 *     Also, for each author's protection and ours, we want to make certain
 *  that everyone understands that there is no warranty for this free
 *  software.  If the software is modified by someone else and passed on, we
 *  want its recipients to know that what they have is not the original, so
 *  that any problems introduced by others will not reflect on the original
 *  authors' reputations.
 *
 *     Finally, any free program is threatened constantly by software
 *  patents.  We wish to avoid the danger that redistributors of a free
 *  program will individually obtain patent licenses, in effect making the
 *  program proprietary.  To prevent this, we have made it clear that any
 *  patent must be licensed for everyone's free use or not licensed at all.
 *
 *     The precise terms and conditions for copying, distribution and
 *  modification follow.
 *  
 *	                	    GNU GENERAL PUBLIC LICENSE
 *       TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
 *
 *     0. This License applies to any program or other work which contains
 *  a notice placed by the copyright holder saying it may be distributed
 *  under the terms of this General Public License.  The "Program", below,
 *  refers to any such program or work, and a "work based on the Program"
 *  means either the Program or any derivative work under copyright law:
 *  that is to say, a work containing the Program or a portion of it,
 *  either verbatim or with modifications and/or translated into another
 *  language.  (Hereinafter, translation is included without limitation in
 *  the term "modification".)  Each licensee is addressed as "you".
 *
 *     Activities other than copying, distribution and modification are not
 *  covered by this License; they are outside its scope.  The act of
 *  running the Program is not restricted, and the output from the Program
 *  is covered only if its contents constitute a work based on the
 *  Program (independent of having been made by running the Program).
 *  Whether that is true depends on what the Program does.
 *
 *     1. You may copy and distribute verbatim copies of the Program's
 *  source code as you receive it, in any medium, provided that you
 *  conspicuously and appropriately publish on each copy an appropriate
 *  copyright notice and disclaimer of warranty; keep intact all the
 *  notices that refer to this License and to the absence of any warranty;
 *  and give any other recipients of the Program a copy of this License
 *  along with the Program.
 *
 *  You may charge a fee for the physical act of transferring a copy, and
 *  you may at your option offer warranty protection in exchange for a fee.
 *
 *     2. You may modify your copy or copies of the Program or any portion
 *  of it, thus forming a work based on the Program, and copy and
 *  distribute such modifications or work under the terms of Section 1
 *  above, provided that you also meet all of these conditions:
 *
 *        a) You must cause the modified files to carry prominent notices
 *     stating that you changed the files and the date of any change.
 *
 *        b) You must cause any work that you distribute or publish, that in
 *     whole or in part contains or is derived from the Program or any
 *     part thereof, to be licensed as a whole at no charge to all third
 *     parties under the terms of this License.
 *
 *        c) If the modified program normally reads commands interactively
 *     when run, you must cause it, when started running for such
 *     interactive use in the most ordinary way, to print or display an
 *     announcement including an appropriate copyright notice and a
 *     notice that there is no warranty (or else, saying that you provide
 *     a warranty) and that users may redistribute the program under
 *     these conditions, and telling the user how to view a copy of this
 *     License.  (Exception: if the Program itself is interactive but
 *     does not normally print such an announcement, your work based on
 *     the Program is not required to print an announcement.)
 *     
 *     These requirements apply to the modified work as a whole.  If
 *  identifiable sections of that work are not derived from the Program,
 *  and can be reasonably considered independent and separate works in
 *  themselves, then this License, and its terms, do not apply to those
 *  sections when you distribute them as separate works.  But when you
 *  distribute the same sections as part of a whole which is a work based
 *  on the Program, the distribution of the whole must be on the terms of
 *  this License, whose permissions for other licensees extend to the
 *  entire whole, and thus to each and every part regardless of who wrote it.
 *
 *     Thus, it is not the intent of this section to claim rights or contest
 *  your rights to work written entirely by you; rather, the intent is to
 *  exercise the right to control the distribution of derivative or
 *  collective works based on the Program.
 *
 *     In addition, mere aggregation of another work not based on the Program
 *  with the Program (or with a work based on the Program) on a volume of
 *  a storage or distribution medium does not bring the other work under
 *  the scope of this License.
 *
 *      3. You may copy and distribute the Program (or a work based on it,
 *  under Section 2) in object code or executable form under the terms of
 *  Sections 1 and 2 above provided that you also do one of the following:
 *
 *        a) Accompany it with the complete corresponding machine-readable
 *     source code, which must be distributed under the terms of Sections
 *     1 and 2 above on a medium customarily used for software interchange; or,
 *
 *        b) Accompany it with a written offer, valid for at least three
 *     years, to give any third party, for a charge no more than your
 *     cost of physically performing source distribution, a complete
 *     machine-readable copy of the corresponding source code, to be
 *     distributed under the terms of Sections 1 and 2 above on a medium
 *     customarily used for software interchange; or,
 *
 *        c) Accompany it with the information you received as to the offer
 *     to distribute corresponding source code.  (This alternative is
 *     allowed only for noncommercial distribution and only if you
 *     received the program in object code or executable form with such
 *     an offer, in accord with Subsection b above.)
 *
 *  The source code for a work means the preferred form of the work for
 *  making modifications to it.  For an executable work, complete source
 *  code means all the source code for all modules it contains, plus any
 *  associated interface definition files, plus the scripts used to
 *  control compilation and installation of the executable.  However, as a
 *  special exception, the source code distributed need not include
 *  anything that is normally distributed (in either source or binary
 *  form) with the major components (compiler, kernel, and so on) of the
 *  operating system on which the executable runs, unless that component
 *  itself accompanies the executable.
 *
 *  If distribution of executable or object code is made by offering
 *  access to copy from a designated place, then offering equivalent
 *  access to copy the source code from the same place counts as
 *  distribution of the source code, even though third parties are not
 *  compelled to copy the source along with the object code.
 *  
 *     4. You may not copy, modify, sublicense, or distribute the Program
 *  except as expressly provided under this License.  Any attempt
 *  otherwise to copy, modify, sublicense or distribute the Program is
 *  void, and will automatically terminate your rights under this License.
 *  However, parties who have received copies, or rights, from you under
 *  this License will not have their licenses terminated so long as such
 *  parties remain in full compliance.
 *
 *    5. You are not required to accept this License, since you have not
 *  signed it.  However, nothing else grants you permission to modify or
 *  distribute the Program or its derivative works.  These actions are
 *  prohibited by law if you do not accept this License.  Therefore, by
 *  modifying or distributing the Program (or any work based on the
 *  Program), you indicate your acceptance of this License to do so, and
 *  all its terms and conditions for copying, distributing or modifying
 *  the Program or works based on it.
 *
 *    6. Each time you redistribute the Program (or any work based on the
 *  Program), the recipient automatically receives a license from the
 *  original licensor to copy, distribute or modify the Program subject to
 *  these terms and conditions.  You may not impose any further
 *  restrictions on the recipients' exercise of the rights granted herein.
 *  You are not responsible for enforcing compliance by third parties to
 *  this License.
 *
 *    7. If, as a consequence of a court judgment or allegation of patent
 *  infringement or for any other reason (not limited to patent issues),
 *  conditions are imposed on you (whether by court order, agreement or
 *  otherwise) that contradict the conditions of this License, they do not
 *  excuse you from the conditions of this License.  If you cannot
 *  distribute so as to satisfy simultaneously your obligations under this
 *  License and any other pertinent obligations, then as a consequence you
 *  may not distribute the Program at all.  For example, if a patent
 *  license would not permit royalty-free redistribution of the Program by
 *  all those who receive copies directly or indirectly through you, then
 *  the only way you could satisfy both it and this License would be to
 *  refrain entirely from distribution of the Program.

 *  If any portion of this section is held invalid or unenforceable under
 *  any particular circumstance, the balance of the section is intended to
 *  apply and the section as a whole is intended to apply in other
 *  circumstances.

 *  It is not the purpose of this section to induce you to infringe any
 *  patents or other property right claims or to contest validity of any
 *  such claims; this section has the sole purpose of protecting the
 *  integrity of the free software distribution system, which is
 *  implemented by public license practices.  Many people have made
 *  generous contributions to the wide range of software distributed
 *  through that system in reliance on consistent application of that
 *  system; it is up to the author/donor to decide if he or she is willing
 *  to distribute software through any other system and a licensee cannot
 *  impose that choice.

 *  This section is intended to make thoroughly clear what is believed to
 *  be a consequence of the rest of this License.
 *  
 *    8. If the distribution and/or use of the Program is restricted in
 *  certain countries either by patents or by copyrighted interfaces, the
 *  original copyright holder who places the Program under this License
 *  may add an explicit geographical distribution limitation excluding
 *  those countries, so that distribution is permitted only in or among
 *  countries not thus excluded.  In such case, this License incorporates
 *  the limitation as if written in the body of this License.
 *
 *    9. The Free Software Foundation may publish revised and/or new versions
 *  of the General Public License from time to time.  Such new versions will
 *  be similar in spirit to the present version, but may differ in detail to
 *  address new problems or concerns.
 *
 *  Each version is given a distinguishing version number.  If the Program
 *  specifies a version number of this License which applies to it and "any
 *  later version", you have the option of following the terms and conditions
 *  either of that version or of any later version published by the Free
 *  Software Foundation.  If the Program does not specify a version number of
 *  this License, you may choose any version ever published by the Free Software
 *  Foundation.

 *    10. If you wish to incorporate parts of the Program into other free
 *  programs whose distribution conditions are different, write to the author
 *  to ask for permission.  For software which is copyrighted by the Free
 *  Software Foundation, write to the Free Software Foundation; we sometimes
 *  make exceptions for this.  Our decision will be guided by the two goals
 *  vof preserving the free status of all derivatives of our free software and
 *  of promoting the sharing and reuse of software generally.
 *
 *  			    NO WARRANTY
 *
 *    11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
 *  FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
 *  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
 *  PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
 *  OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
 *  TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
 *  PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
 *  REPAIR OR CORRECTION.
 *
 *    12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
 *  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
 *  REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
 *  INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
 *  OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
 *  TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
 *  YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
 *  PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGES.
 *
 *  		     END OF TERMS AND CONDITIONS
 *  
 *  	    How to Apply These Terms to Your New Programs
 *    If you develop a new program, and you want it to be of the greatest
 *  possible use to the public, the best way to achieve this is to make it
 *  free software which everyone can redistribute and change under these terms.
 *
 *    To do so, attach the following notices to the program.  It is safest
 *  to attach them to the start of each source file to most effectively
 *  convey the exclusion of warranty; and each file should have at least
 *  the "copyright" line and a pointer to where the full notice is found.
 *
 *      <one line to give the program's name and a brief idea of what it does.>
 *      Copyright (C) <year>  <name of author>
 *
 *      This program is free software; you can redistribute it and/or modify
 *      it under the terms of the GNU General Public License as published by
 *      the Free Software Foundation; either version 2 of the License, or
 *      (at your option) any later version.
 *
 *      This program is distributed in the hope that it will be useful,
 *      but WITHOUT ANY WARRANTY; without even the implied warranty of
 *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *      GNU General Public License for more details.
 *
 *      You should have received a copy of the GNU General Public License
 *      along with this program; if not, write to the Free Software
 *      Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *
 *
 *  Also add information on how to contact you by electronic and paper mail.
 *
 *  If the program is interactive, make it output a short notice like this
 *  when it starts in an interactive mode:
 *
 *      Gnomovision version 69, Copyright (C) year name of author
 *      Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
 *      This is free software, and you are welcome to redistribute it
 *      under certain conditions; type `show c' for details.
 *
 *  The hypothetical commands `show w' and `show c' should show the appropriate
 *  parts of the General Public License.  Of course, the commands you use may
 *  be called something other than `show w' and `show c'; they could even be
 *  mouse-clicks or menu items--whatever suits your program.
 *
 *  You should also get your employer (if you work as a programmer) or your
 *  school, if any, to sign a "copyright disclaimer" for the program, if
 *  necessary.  Here is a sample; alter the names:
 *
 *    Yoyodyne, Inc., hereby disclaims all copyright interest in the program
 *    `Gnomovision' (which makes passes at compilers) written by James Hacker.
 *
 *    <signature of Ty Coon>, 1 April 1989
 *    Ty Coon, President of Vice

 *  This General Public License does not permit incorporating your program into
 *  proprietary programs.  If your program is a subroutine library, you may
 *  consider it more useful to permit linking proprietary applications with the
 *  library.  If this is what you want to do, use the GNU Library General
 *  Public License instead of this License.
 */


package it.aco.mandragora.as.context.impl;

import org.apache.commons.beanutils.BeanUtilsBean;
import org.apache.commons.beanutils.PropertyUtilsBean;
import org.apache.commons.beanutils.ConstructorUtils;
import org.apache.commons.chain.Context;

import java.util.*;
import java.lang.reflect.InvocationTargetException;

import it.aco.mandragora.exception.ApplicationServiceException;
import it.aco.mandragora.exception.ServiceLocatorException;
import it.aco.mandragora.exception.DataAccessException;
import it.aco.mandragora.common.ServiceLocator;
import it.aco.mandragora.common.Utils;
import it.aco.mandragora.common.utils.BeanCollectionUtils;
import it.aco.mandragora.dao.context.ContextDAO;
import it.aco.mandragora.comparator.FieldComparator;
import it.aco.mandragora.comparator.BeanFieldComparator;
import it.aco.mandragora.as.context.ContextApplicationService;


public abstract class BaseContextApplicationService implements ContextApplicationService {


    private static  org.apache.log4j.Category log = org.apache.log4j.Logger.getLogger(BaseContextApplicationService.class.getName());




    protected abstract ContextDAO getContextDAO(Context context)throws ApplicationServiceException;








    public Collection getReferenceCollectionOrRetrieveIfNull(Context context) throws ApplicationServiceException{
        try{
            Object pInstance = context.get("pInstance");
            String pAttributeName =(String) context.get("pAttributeName");

            if (pInstance == null || pAttributeName== null || pAttributeName.trim().equals("")){
                throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseContextApplication.getReferenceCollectionOrRetrieveIfNull(Context context): pInstance can't be null, pAttributeName can't be null, nor empty string nor blank characters string" );
            }
            //PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();   //deleted  by Alessandro on 7-Dec-2008
            //Collection collection= (Collection)propertyUtilsBean.getProperty(pInstance,pAttributeName);  //deleted  by Alessandro on 7-Dec-2008
            //Collection collection= (Collection)Utils.getPropertyIfNotNullOnPath(pInstance,pAttributeName); //added  by Alessandro on 7-Dec-2008
            Collection collection= (Collection)BeanCollectionUtils.getPropertyIfNotNullOnPath(pInstance,pAttributeName); //added  by Alessandro on 7-Dec-2008
            if (collection == null) {
                log.debug("BaseContextApplication.getReferenceCollectionOrRetrieveIfNull : collection is null");
                ContextDAO contextDAO = getContextDAO(context);

                //contextDAO.retrievePathReference(context); deleted by Alessandro on 26-Nov-2008
                contextDAO.retrieveReference(context); //added by Alessandro on 26-Nov-2008

                //collection= (Collection)propertyUtilsBean.getProperty(pInstance,pAttributeName);   /deleted  by Alessandro on 7-Dec-2008
                //collection= (Collection)Utils.getPropertyIfNotNullOnPath(pInstance,pAttributeName);  //added  by Alessandro on 7-Dec-2008
                collection= (Collection)BeanCollectionUtils.getPropertyIfNotNullOnPath(pInstance,pAttributeName);  //added  by Alessandro on 7-Dec-2008
            }
            return collection;
        }catch (IllegalAccessException e) {
            log.error("IllegalAccessException caught in BaseContextApplication.getReferenceCollectionOrRetrieveIfNull(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseContextApplication.getReferenceCollectionOrRetrieveIfNull(Context context): " + e.toString(),e);
        }catch (NoSuchMethodException e) {
            log.error("NoSuchMethodException caught in BaseContextApplication.getReferenceCollectionOrRetrieveIfNull(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseContextApplication.getReferenceCollectionOrRetrieveIfNull(Context context) : " + e.toString(),e);
        }catch (InvocationTargetException e) {
            log.error("InvocationTargetException caught in BaseContextApplication.getReferenceCollectionOrRetrieveIfNull(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseContextApplication.getReferenceCollectionOrRetrieveIfNull(Context context) : " + e.toString(),e);
        }catch (DataAccessException e) {
            log.error("DataAccessException caught in BaseContextApplication.getReferenceCollectionOrRetrieveIfNull(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseContextApplication.getReferenceCollectionOrRetrieveIfNull(Context context) : " + e.toString(),e);
        } catch (Exception e) {
            log.error("Exception caught in BaseContextApplication.getReferenceCollectionOrRetrieveIfNull(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseContextApplication.getReferenceCollectionOrRetrieveIfNull(Context context) : " + e.toString(),e);
        }
    }





    public Collection getReferenceCollectionOrEmptyIfNull(Context context) throws ApplicationServiceException{
        try{
            Collection collection = null;
            Object pInstance= context.get("pInstance");
            String pAttributeName= (String) context.get("pAttributeName");
            Class collectionImplClass = (Class) context.get("collectionImplClass");

            if (pInstance == null || pAttributeName== null || pAttributeName.trim().equals("")){
                throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseContextApplication.getReferenceCollectionOrEmptyIfNull(Context context): pInstance can't be null, pAttributeName can't be null, nor empty string nor blank characters string" );
            }
            PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();
            // start added by Alessandro on 29-Nov-2008
            ContextDAO contextDAO = getContextDAO(context);
            String[] firstAttributeNameAndRemainingPath = Utils.getFirstAttributeNameAndRemainingPath(pAttributeName) ;
            String firstAttributeName = firstAttributeNameAndRemainingPath[0];
            String remainingPath = firstAttributeNameAndRemainingPath[1];
            Object valueObject = pInstance;
            while(!firstAttributeName.trim().equals("")){  // the two break inside the body make the truth of this condition never reached
                if(!remainingPath.trim().equals(""))  {
                    if (Collection.class.isInstance(valueObject)) {
                        throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseContextApplication.getReferenceCollectionOrEmptyIfNull(Context context): The path have to be a walk through only value objects, with no collection on its walk, except for  the last attribute that must be a collection (note that if pAttributeName is a single token it must be a reference to a collection)." );
                    }
                    valueObject = propertyUtilsBean.getProperty(valueObject,firstAttributeName);
                    if(valueObject == null) break;
                } else { // is last token and must be a collection
                    collection= (Collection)propertyUtilsBean.getProperty(valueObject,firstAttributeName);
                    break; // this break force that when the loop ends  firstAttributeName is the last token.
                }
                firstAttributeNameAndRemainingPath = Utils.getFirstAttributeNameAndRemainingPath(remainingPath) ;
                firstAttributeName = firstAttributeNameAndRemainingPath[0];
                remainingPath = firstAttributeNameAndRemainingPath[1];
            }
            if(collection==null) {
                log.debug("getReferenceCollectionOrEmptyIfNull : collection is  null");
                String[] exceptLastTokenAndLastToken = Utils.getExceptLastTokenAndLastToken(pAttributeName);
                Object path = context.get("path");

                if(valueObject==null) {
                    log.debug("getReferenceCollectionOrEmptyIfNull : valueObject is  null");
                    context.put("path",exceptLastTokenAndLastToken[0]);
                    Object valueobjectOrCollection = context.get("valueobjectOrCollection");
                    context.put("valueobjectOrCollection",pInstance);
                    contextDAO.retrieveNullPathReference(context);
                    context.put("valueobjectOrCollection",valueobjectOrCollection);
                }
                // start added  by Alessandro on 6-Dec-2008
                log.debug("getReferenceCollectionOrEmptyIfNull : before Utils.getPropertyIfNotNullOnPath(pInstance,exceptLastTokenAndLastToken[0])   ");
                //valueObject = propertyUtilsBean.getProperty(pInstance,exceptLastTokenAndLastToken[0]); // deleted  by Alessandro on 6-Dec-2008 and deleted on 7-Dec-2008
                //valueObject = Utils.getPropertyIfNotNullOnPath(pInstance,exceptLastTokenAndLastToken[0]); // added  by Alessandro on 7-Dec-2008
                valueObject = BeanCollectionUtils.getPropertyIfNotNullOnPath(pInstance,exceptLastTokenAndLastToken[0]); // added  by Alessandro on 7-Dec-2008
                if(valueObject==null) {
                    return null;
                }
                // end added  by Alessandro on 6-Dec-2008
                if (collectionImplClass == null){
                    context.put("path",pAttributeName);
                    Object realClass = context.get("realClass");
                    context.put("realClass",pInstance.getClass());
                    collectionImplClass = contextDAO.getCollectionClassFromPath(context);
                    context.put("realClass",realClass);
                    log.debug("getReferenceCollectionOrEmptyIfNull : collectionImplClass is  "+collectionImplClass);
                }
                context.put("path",path);
                log.debug("getReferenceCollectionOrEmptyIfNull : definitive collectionImplClass is  "+collectionImplClass);
                collection = (Collection) ConstructorUtils.invokeConstructor(collectionImplClass,null,null) ;
                //valueObject = propertyUtilsBean.getProperty(pInstance,exceptLastTokenAndLastToken[0]);   // deleted by Alessandro on 6-Dec-2008
                log.debug("getReferenceCollectionOrEmptyIfNull : valueObject is  "+valueObject.toString());
                propertyUtilsBean.setProperty(valueObject, exceptLastTokenAndLastToken[1], collection );
            }
            // end added by Alessandro on 29-Nov-2008


            /* deleted   by Alessandro on 29-Nov-2008
            Collection collection= (Collection)propertyUtilsBean.getProperty(pInstance,pAttributeName);
            if (collection == null) {
                ContextDAO contextDAO = getContextDAO(context);
                if (collectionImplClass == null){

                    Object realClass = context.get("realClass");
                    context.put("realClass",pInstance.getClass());
                    collectionImplClass = contextDAO.getCollectionClassFromPath(context);
                    context.put("realClass",realClass);

                }

                String[] exceptLastTokenAndLastToken = Utils.getExceptLastTokenAndLastToken(pAttributeName);


                Object path = context.get("path");
                context.put("path",exceptLastTokenAndLastToken[0]);
                contextDAO.retrieveNullPathReference(context);
                context.put("path",path);


                Object valueObject = propertyUtilsBean.getProperty(pInstance,exceptLastTokenAndLastToken[0]);
                if (valueObject!=null){
                    collection = (Collection) ConstructorUtils.invokeConstructor(collectionImplClass,null,null) ;
                    propertyUtilsBean.setProperty(valueObject, exceptLastTokenAndLastToken[1], collection );
                }
            }
            */
            return collection;
        }catch (IllegalAccessException e) {
            log.error("IllegalAccessException caught in BaseContextApplication.getReferenceCollectionOrEmptyIfNull(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseContextApplication.getReferenceCollectionOrEmptyIfNull(Context context): " + e.toString(),e);
        }catch (InvocationTargetException e) {
            log.error("InvocationTargetException caught in BaseContextApplication.getReferenceCollectionOrEmptyIfNull(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseContextApplication.getReferenceCollectionOrEmptyIfNull(Context context): " + e.toString(),e);
        }catch (NoSuchMethodException e) {
            log.error("NoSuchMethodException caught in BaseContextApplication.getReferenceCollectionOrEmptyIfNull(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseContextApplication.getReferenceCollectionOrEmptyIfNull(Context context): " + e.toString(),e);
        }catch (InstantiationException e) {
            log.error("NoSuchMethodException caught in BaseContextApplication.getReferenceCollectionOrEmptyIfNull(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseContextApplication.getReferenceCollectionOrEmptyIfNull(Context context): " + e.toString(),e);
        }catch (DataAccessException e) {
            log.error("DataAccessException caught in BaseContextApplication.getReferenceCollectionOrEmptyIfNull(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseContextApplication.getReferenceCollectionOrEmptyIfNull(Context context): " + e.toString(),e);
        }catch (Exception e) {
            log.error("Exception caught in BaseContextApplication.getReferenceCollectionOrEmptyIfNull(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseContextApplication.getReferenceCollectionOrEmptyIfNull(Context context): " + e.toString(),e);
        }
    }



    public Collection getInverseForeignKeyNotPKFields(Context context )throws ApplicationServiceException{
        try{
            ContextDAO contextDAO = getContextDAO(context);
            Collection inverseForeignKeyFields;
            inverseForeignKeyFields= contextDAO.getInverseForeignKeyFields(context);
            if (inverseForeignKeyFields!=null){
                String[] pkNames = getPkNames(context);
                if (pkNames!=null && pkNames.length!=0){
                    Iterator iterator = inverseForeignKeyFields.iterator();
                    while (iterator.hasNext()) {
                        String inverseForeignKeyField = (String)iterator.next();
                        for (int i =0; i<pkNames.length; i++){
                            if (inverseForeignKeyField.equals(pkNames[i])) {
                                iterator.remove();
                                break;
                            }
                        }
                    }
                }
            }
            return inverseForeignKeyFields;
        } catch (DataAccessException e) {
            log.error("DataAccessException caught in BaseContextApplication.getInverseForeignKeyNotPKFields(Context context)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.getInverseForeignKeyNotPKFields(Context context)" + e.toString(),e);
        } catch (Exception e) {
            log.error("DataAccessException caught in BaseContextApplication.getInverseForeignKeyNotPKFields(Context context)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.getInverseForeignKeyNotPKFields(Context context)" + e.toString(),e);
        }
    }




    public String[] getPkNotInverseForeignKeyFields(Context context) throws ApplicationServiceException{
        try{

            String[] pkNames = getPkNames(context);
            if(pkNames!=null && pkNames.length!=0){

                ContextDAO contextDAO = getContextDAO(context);
                Collection inverseForeignKeyFields;
                inverseForeignKeyFields = contextDAO.getInverseForeignKeyFields(context);

                if(inverseForeignKeyFields!=null &&!inverseForeignKeyFields.isEmpty()){
                    Vector pkNotInverseForeignKeyFields = new Vector();
                    for (int i =0; i<pkNames.length; i++){
                        boolean found = false;
                        Iterator inverseForeignKeyFieldsIterator = inverseForeignKeyFields.iterator();
                        while (inverseForeignKeyFieldsIterator.hasNext()){
                           String inverseForeignKeyField = (String)  inverseForeignKeyFieldsIterator.next();
                            if (inverseForeignKeyField.equals(pkNames[i])) {
                                found = true;
                                break;
                            }
                        }
                        if (!found)pkNotInverseForeignKeyFields.add(pkNames[i]);
                    }
                    pkNames = (String[]) pkNotInverseForeignKeyFields.toArray(new String[]{});
                }
            }
            return pkNames;
        } catch (DataAccessException e) {
            log.error("DataAccessException caught in BaseContextApplication.getPkNotInverseForeignKeyFields(Context context)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.getPkNotInverseForeignKeyFields(Context context)" + e.toString(),e);
        } catch (Exception e) {
            log.error("Exception caught in BaseContextApplication.getPkNotInverseForeignKeyFields(Context context)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.getPkNotInverseForeignKeyFields(Context context)" + e.toString(),e);
        }
    }



    public String[] getPkNotForeignKeyFields(Context context) throws ApplicationServiceException{
        try{

            Class realClass = (Class) context.get("realClass");
            String pAttributeName = (String)context.get("pAttributeName");


            if (realClass == null ) throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.getPkNotInverseForeignKeyFields(Context context): real class can't be null ");
            if (pAttributeName == null ||pAttributeName.trim().equals("") ) throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.getPkNotInverseForeignKeyFields(Context context): pAttributeName can't be null nor empty or blank characters string");


            String[] exceptLastTokenAndLastToken = Utils.getExceptLastTokenAndLastToken(pAttributeName);
            context.put("pAttributeName",exceptLastTokenAndLastToken[0]);

            String[] pkNames = getPkNames(context);
            context.put("pAttributeName",pAttributeName);

            if(pkNames!=null && pkNames.length!=0){

                ContextDAO contextDAO = getContextDAO(context);
                Collection foreignKeyFields;
                foreignKeyFields = contextDAO.getForeignKeyFields(context);
                if(foreignKeyFields!=null &&!foreignKeyFields.isEmpty()){
                    Vector pkNotForeignKeyFields = new Vector();
                    for (int i =0; i<pkNames.length; i++){
                        boolean found = false;
                        Iterator foreignKeyFieldsFieldsIterator = foreignKeyFields.iterator();
                        while (foreignKeyFieldsFieldsIterator.hasNext()){
                           String foreignKeyField = (String)  foreignKeyFieldsFieldsIterator.next();
                            if (foreignKeyField.equals(pkNames[i])) {
                                found = true;
                                break;
                            }
                        }
                        if (!found)pkNotForeignKeyFields.add(pkNames[i]);
                    }
                    pkNames = (String[]) pkNotForeignKeyFields.toArray(new String[]{});
                }
            }
            return pkNames;
         } catch (DataAccessException e) {
            log.error("DataAccessException caught in BaseContextApplication.getPkNotForeignKeyFields(Context context)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.getPkNotForeignKeyFields(Context context)" + e.toString(),e);
         } catch (Exception e) {
            log.error("Exception caught in BaseContextApplication.getPkNotForeignKeyFields(Context context)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.getPkNotForeignKeyFields(Context context)" + e.toString(),e);
         }
    }






    public String[] getPkNames(Context context) throws ApplicationServiceException{
        try{
            Class realClass = (Class) context.get("realClass");
            String pAttributeName = (String) context.get("pAttributeName");

            if (realClass == null) throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.getPkNames(Context context): realClass can't be null" );
            ContextDAO contextDAO = getContextDAO(context);


            if (pAttributeName==null || pAttributeName.trim().equals("")) return contextDAO.getPkNames(context);
            Object path = context.get("path");
            context.put("path",pAttributeName);
            Class newRealClass = contextDAO.getClassFromPath(context);
            context.put("realClass",newRealClass);
            String[] pkNames = contextDAO.getPkNames(context);
            context.put("path",path);
            context.put("realClass",realClass);
            return pkNames;



        } catch (DataAccessException e) {
            log.error("DataAccessException caught in ApplicationServiceContextDefaultImplgetPkNames(Context context)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.getPkNames(Context context)" + e.toString(),e);
        } catch (Exception e) {
            log.error("Exception caught in ApplicationServiceContextDefaultImplgetPkNames( Context context)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.getPkNames(Context context)" + e.toString(),e);
        }
    }


    /**
     * TODO use DAO.getKeyValues(Object pInstance,String pAttributeName)
     * @param context
     * @return
     * @throws it.aco.mandragora.exception.ApplicationServiceException
     */
    public Object[] getKeyValues(Context context) throws ApplicationServiceException{
        try{

            Object pInstance = context.get("pInstance");
            String pAttributeName = (String) context.get("pAttributeName");

            if (pInstance==null) return null;
            ContextDAO contextDAO = getContextDAO(context);
            if (pAttributeName==null || pAttributeName.trim().equals("")) {
                return contextDAO.getKeyValues(context);
            }
            PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();
            //Object valueObjectToGetKeyValues=propertyUtilsBean.getProperty(pInstance,pAttributeName); // deleted by Alessandro on 7-dec 2008
            //Object valueObjectToGetKeyValues=Utils.getPropertyIfNotNullOnPath(pInstance,pAttributeName); // added by Alessandro on 7-dec 2008
            Object valueObjectToGetKeyValues=BeanCollectionUtils.getPropertyIfNotNullOnPath(pInstance,pAttributeName); // added by Alessandro on 7-dec 2008
            if(valueObjectToGetKeyValues==null) return null;

            context.put("pInstance",valueObjectToGetKeyValues);
            Object[] keyValues = contextDAO.getKeyValues(context);
            context.put("pInstance",pInstance);
            return keyValues;


        } catch (DataAccessException e) {
            log.error("DataAccessException caught in BaseContextApplication.getKeyValues(Context context) " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.getKeyValues(Context context)" + e.toString(),e);
        } catch (IllegalAccessException e) {
            log.error("IllegalAccessException caught in BaseContextApplication.getKeyValues( Context context) " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.getKeyValues(Context context)" + e.toString(),e);
        } catch (InvocationTargetException e) {
            log.error("InvocationTargetException caught in BaseContextApplication.getKeyValues(ontext context) " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.getKeyValues(Context context)" + e.toString(),e);
        } catch (NoSuchMethodException e) {
            log.error("NoSuchMethodException caught in BaseContextApplication.getKeyValues(Context context) " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.getKeyValues(Context context)" + e.toString(),e);
        } catch (Exception e) {
            log.error("Exception caught in BaseContextApplication.getKeyValues(Context context) " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.getKeyValues(Context context)" + e.toString(),e);
        }
    }


    /**
     * TODO change using the DAO.setInverseForeignKeyFields
     * @param context
     * @throws it.aco.mandragora.exception.ApplicationServiceException
     */
    public void setInverseForeignKeyFields(Context context) throws ApplicationServiceException{
        try{
                Object pInstance = context.get("pInstance");
                String pAttributeName = (String) context.get("pAttributeName");

            ContextDAO contextDAO = getContextDAO(context);
            String [] exceptLastTokenAndLastToken = Utils.getExceptLastTokenAndLastToken(pAttributeName);

            Collection inverseForeignKeyFields;
            Object[] keyValues;

            Object realClass =  context.get("realClass");
            context.put("realClass",pInstance.getClass());
            inverseForeignKeyFields = contextDAO.getInverseForeignKeyFields(context);
            context.put("realClass",realClass);
            context.put("pAttributeName",exceptLastTokenAndLastToken[0]);
            keyValues=getKeyValues(context);
            context.put("pAttributeName",pAttributeName);


            if (inverseForeignKeyFields== null||inverseForeignKeyFields.isEmpty()) throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseContextApplication.setInverseForeignKeyFields(Context context):No Foreign Key Fields found" );
            if (keyValues== null||keyValues.length==0) throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseContextApplication.setInverseForeignKeyFields(Context context):No pInstance PKValues found" );
            if (keyValues.length!=inverseForeignKeyFields.size())  throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseContextApplication.setInverseForeignKeyFields(Context context):Foreign Key Fields and pInstance PKValues do not have the same number of elements " );
            PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();
            Collection pAttributeNameCollection =(Collection) propertyUtilsBean.getProperty(pInstance,pAttributeName);
            if(pAttributeNameCollection!=null){

                Iterator pAttributeNameCollectionIterator = pAttributeNameCollection.iterator();
                while (pAttributeNameCollectionIterator.hasNext()){
                    Object pAttributeNameCollectionElement= pAttributeNameCollectionIterator.next();
                    int i=0;
                    Iterator inverseForeignKeyFieldsIterator = inverseForeignKeyFields.iterator();
                    while(inverseForeignKeyFieldsIterator.hasNext()){
                        propertyUtilsBean.setProperty(pAttributeNameCollectionElement,(String)inverseForeignKeyFieldsIterator.next(),keyValues[i]);
                        i++;
                    }
                }
            }
        } catch (DataAccessException e) {
            log.error("DataAccessException caught in BaseContextApplication.setInverseForeignKeyFields(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.setInverseForeignKeyFields(Context context)" + e.toString(),e);
        } catch (IllegalAccessException e) {
            log.error("IllegalAccessException caught in BaseContextApplication.setInverseForeignKeyFields(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.setInverseForeignKeyFields(Context context)" + e.toString(),e);
        } catch (InvocationTargetException e) {
            log.error("InvocationTargetException caught in BaseContextApplication.setInverseForeignKeyFields( Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.setInverseForeignKeyFields(Context context)" + e.toString(),e);
        } catch (NoSuchMethodException e) {
            log.error("NoSuchMethodException caught in BaseContextApplication.setInverseForeignKeyFields(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.setInverseForeignKeyFields(Context context)" + e.toString(),e);
        } catch (Exception e) {
            log.error("Exception caught in BaseContextApplication.setInverseForeignKeyFields(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.setInverseForeignKeyFields(Context context)" + e.toString(),e);
        }
    }


    public void setForeignKeyFields(Context context) throws ApplicationServiceException{
        try{

            Object pInstance = context.get("pInstance");
            String pAttributeName = (String) context.get("pAttributeName");

            if (pInstance == null) throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.setForeignKeyFields(Context context): pInstance can't be null as parameter and in the context as well");
            if(pAttributeName.trim().equals("")) return;
            ContextDAO contextDAO = getContextDAO(context);
            Object[] foreignKeyFieldsValues;
            foreignKeyFieldsValues = getKeyValues(context);

            if (foreignKeyFieldsValues !=null){
                String[] foreignKeyFields;

                Object  realClass= context.get("realClass");
                context.put("realClass",pInstance.getClass());
                foreignKeyFields =(String[]) contextDAO.getForeignKeyFields(context).toArray(new String[]{});
                context.put("realClass",realClass);

                String[] exceptLastTokenAndLastToken =Utils.getExceptLastTokenAndLastToken(pAttributeName);
                PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();
                Object objectToSet;
                if (exceptLastTokenAndLastToken[0].equals("")){
                    objectToSet = pInstance;
                }else{
                    objectToSet = propertyUtilsBean.getProperty(pInstance,exceptLastTokenAndLastToken[0]);
                }
                BeanCollectionUtils.setAttributes(objectToSet, foreignKeyFields, foreignKeyFieldsValues); // there is no need to use the context
            }
        } catch (DataAccessException e) {
            log.error("DataAccessException caught in BaseContextApplication.setForeignKeyFields(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.setForeignKeyFields(Context context)" + e.toString(),e);
        } catch (IllegalAccessException e) {
            log.error("IllegalAccessException caught in BaseContextApplication.setForeignKeyFields(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.setForeignKeyFields(Context context)" + e.toString(),e);
        } catch (InvocationTargetException e) {
            log.error("InvocationTargetException caught in BaseContextApplication.setForeignKeyFields(Object pInstance, String pAttributeName): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.setForeignKeyFields(Context context)" + e.toString(),e);
        } catch (NoSuchMethodException e) {
            log.error("NoSuchMethodException caught in BaseContextApplication.setForeignKeyFields(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.setForeignKeyFields(Context context)" + e.toString(),e);
        } catch (Exception e) {
            log.error("Exception caught in BaseContextApplication.setForeignKeyFields(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.setForeignKeyFields(Context context)" + e.toString(),e);
        }
    }




    public boolean isKeyNotNull(Context context) throws ApplicationServiceException{
        try{


            Object pInstance = context.get("pInstance");
            Collection valueObjectsCollection = (Collection)context.get("valueObjectsCollection");
            if (pInstance==null && valueObjectsCollection==null)throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.isKeyNotNull(Context context): pInstance and valueObjectsCollection not in context" );

            Object realClass = context.get("realClass");
            Object pAttributeName = context.get("pAttributeName");



            if (pInstance!=null){
                boolean isKeyNotNull;
                context.put("realClass",pInstance.getClass());
                context.put("pAttributeName",null);
                String[] pKNames = getPkNames(context);
                context.put("realClass",realClass);
                context.put("pAttributeName",pAttributeName);
                isKeyNotNull = Utils.areAllAttributesValuesNotNull(pInstance,pKNames);
                return isKeyNotNull;
            }

            Iterator iterator = valueObjectsCollection.iterator();//valueObjectsCollection !=null surely
            context.put("pAttributeName",null);
            while (iterator.hasNext()){
                pInstance=iterator.next();
                context.put("realClass",pInstance.getClass());
                String[] pKNames = getPkNames(context);
                if(!Utils.areAllAttributesValuesNotNull(pInstance,pKNames)){
                    context.put("pAttributeName",pAttributeName);
                    context.put("realClass",realClass);
                    return false;
                }
            }
            context.put("pAttributeName",pAttributeName);
            context.put("realClass",realClass);
            return true;
        } catch (Exception e) {
            log.error("Exception caught in BaseContextApplication.isKeyNotNull(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.isKeyNotNull(Context context)" + e.toString(),e);
        }
    }
















    public boolean addToCollection(Context context) throws ApplicationServiceException{
        try{
            Collection valueObjectsCollection=(Collection) context.get("valueObjectsCollection");
            Object pInstance=context.get("pInstance");
            String[] pAttributeNames=(String[]) context.get("pAttributeNames");

            if(valueObjectsCollection == null)  throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseContextApplication.addToCollection(Context context) :valueObjectsCollection can't be null" );
            if(pInstance == null)  throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseContextApplication.addToCollection(Context context) :pInstance can't be null" );
            if (!isInCollection(context)){
                valueObjectsCollection.add(pInstance);
                return true;
            }else{
                return false;
            }
        }catch (Exception e) {
            log.error("Exception caught in BaseContextApplication.addToCollection(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addToCollection(Collection valueObjectsCollection, Object pInstance, String[] pAttributeNames)" + e.toString(),e);
        }
    }




    public boolean addAllToCollection(Context context) throws ApplicationServiceException{
        try{
            Collection valueObjectsCollection = (Collection)  context.get("valueObjectsCollection");
            if(valueObjectsCollection == null) throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addAllToCollection(Context context) : valueObjectsCollection not found in context");

            Collection  valueObjectsCollectionToAdd = (Collection)  context.get("valueObjectsCollectionToAdd");
            if(valueObjectsCollectionToAdd==null || valueObjectsCollectionToAdd.isEmpty()) return false;

            String[] pAttributeNames = (String[]) context.get("pAttributeNames");
            String pAttributeNameMapKey = (String) context.get("pAttributeNameMapKey");
            if(pAttributeNameMapKey!=null){

                Map map = (Map)(context.get("map"));
                valueObjectsCollectionToAdd = Utils.selectWhereFieldIn(valueObjectsCollectionToAdd, pAttributeNameMapKey,  map);
                if(valueObjectsCollectionToAdd==null || valueObjectsCollectionToAdd.isEmpty())return false;
                context.put("pAttributeNames",new String[]{pAttributeNameMapKey});

            }

            boolean added =false;
            Iterator iterator = valueObjectsCollectionToAdd.iterator();  //  valueObjectsCollectionToAdd!=null sure
            Object pInstance = context.get("pInstance");
            while (iterator.hasNext()){
                context.put("pInstance",iterator.next());
                if (addToCollection(context)) added=true;
            }
            context.put("pInstance",pInstance);
            context.put("pAttributeNames",pAttributeNames);
            return added;
        }catch (Exception e) {
            log.error("Exception caught in BaseContextApplication.addAllToCollection(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addAllToCollection(Context context)" + e.toString(),e);
        }
    }





    public boolean removeFromCollection(Context context) throws ApplicationServiceException{
        try{
            boolean removed = false;
            Collection valueObjectsCollection = (Collection) context.get("valueObjectsCollection");
            Object toRemovePInstance = context.get("toRemovePInstance");
            String[] pAttributeNames = (String[]) context.get("pAttributeNames");

            if (valueObjectsCollection==null) return false;
            if(pAttributeNames==null){
                Object realClass = context.get("realClass");
                Object pAttributeName = context.get("pAttributeName");
                context.put("realClass",toRemovePInstance.getClass());
                context.put("pAttributeName",null);
                pAttributeNames = getPkNames(context);
                context.put("realClass",realClass);
                context.put("pAttributeName",pAttributeName);
            }
            Comparator comparator = new FieldComparator(pAttributeNames);
            Object element;
            Iterator iterator = valueObjectsCollection.iterator();
            while (iterator.hasNext()){
                element = iterator.next();
                //if (comparator.compare(toRemovePInstance,element)!=0) {  //deleted by Alessandro on 9-dec-2008
                if (comparator.compare(toRemovePInstance,element)==0) { //added by Alessandro on 9-dec-2008
                    iterator.remove();
                    removed=true;
                }
            }
            return removed;

        }catch (Exception e) {
            log.error("Exception caught in BaseContextApplication.removeFromCollection(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.removeFromCollection(Context context)" + e.toString(),e);
        }
    }



    public boolean removeAllFromCollection(Context context) throws ApplicationServiceException{
        try{
            Collection valueObjectsCollection = (Collection) context.get("valueObjectsCollection");
            Collection valueObjectsCollectionToRemove = (Collection) context.get("valueObjectsCollectionToRemove");
            if(valueObjectsCollectionToRemove == null)  return false;
            //String[] pAttributeNames = (String[]) context.get("pAttributeNames");

            boolean removed = false;
            Object toRemovePInstance = context.get("toRemovePInstance");
            Iterator iterator = valueObjectsCollectionToRemove.iterator();

            while (iterator.hasNext()){
                context.put("toRemovePInstance",iterator.next()) ;
                if (removeFromCollection(context)) removed=true;
            }
            context.put("toRemovePInstance",toRemovePInstance) ;
            return removed;
        }catch (Exception e) {
            log.error("Exception caught in BaseContextApplication.removeAllFromCollection(Context context) : " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.removeAllFromCollection(Context context) " + e.toString(),e);
        }
    }

    // todo to put in Bean Utils Collection
    public boolean isInCollection(Context context) throws ApplicationServiceException{
        try{

            Collection valueObjectsCollection = (Collection) context.get("valueObjectsCollection");
            Object pInstance = context.get("pInstance");
            String[]  pAttributeNames = (String[])  context.get("pAttributeNames");

            if (pInstance==null ) throw new ApplicationServiceException("ApplicationServiceException thrown in  BaseContextApplication.isInCollection(Context context) :pInstance can't be null" );
            if (pAttributeNames == null) {

                Object realClass = context.get("realClass");
                Object pAttributeName = context.get("pAttributeName");
                context.put("realClass",pInstance.getClass());
                context.put("pAttributeName",null);
                pAttributeNames = getPkNames(context);
                context.put("realClass",realClass);
                context.put("pAttributeName",pAttributeName);


            }
            if (valueObjectsCollection==null || valueObjectsCollection.isEmpty()) return false;
            //Comparator comparator = new BeanFieldComparator(pAttributeNames);
            Comparator comparator = new FieldComparator(pAttributeNames);
            ArrayList arrayList = Collections.list(Collections.enumeration(valueObjectsCollection));
            Collections.sort(arrayList,comparator);
            if(Collections.binarySearch(arrayList,pInstance,comparator)<0){
                return false;
            }else{
                return true;
            }
        } catch (Exception e) {
            log.error("Exception caught in BaseContextApplication.isInCollection(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.isInCollection(Context context)" + e.toString(),e);
        }
    }


    public Collection createCollectionWithTreeNodes(Context context) throws ApplicationServiceException{
        try{

            Class collectionImplClass = (Class) context.get("collectionImplClass");
            Class realClass= (Class) context.get("realClass");
            String[] pkNames = (String[]) context.get("pkNames");
            Object pInstance = context.get("pInstance");
            String path =(String )context.get("path");
            String[][] nodeSourcePAttributeNames = (String[][]) context.get("nodeSourcePAttributeNames");
            String[][] nodeTargetPAttributeNames =(String[][]) context.get("nodeTargetPAttributeNames");
            String[] pAttributeNames = (String[]) context.get("pAttributeNames");
            Object[] valuesArray = (Object[]) context.get("valuesArray");

            if (collectionImplClass == null || realClass == null ) throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.createCollectionWithTreeNodes(Context context): collectionImplClass or realClass can't be null" );
            //if (pAttributeName == null || pAttributeName.trim().equals("")) throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.createCollectionWithTreeNodes(Class collectionImplClass, Class realClass, String[] pkNames, Object pInstance, String pAttributeName, String path, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, String[] pAttributeNames,Object[] valuesArray): pAttributeName can't be null nor empty string nor blank characters string" );
            if ((pAttributeNames==null && valuesArray!=null)||(pAttributeNames!=null && valuesArray==null)){
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.createCollectionWithTreeNodes(Context context): parameters pAttributeNames and valuesArray must be both null or both not null" );
            }
            if (pAttributeNames!=null /*valuesArray != null surely*/ && pAttributeNames.length!=valuesArray.length){
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.createCollectionWithTreeNodes(Context context): parameters pAttributeNames and valuesArray must be both null or have the same length" );
            }

            if ((nodeSourcePAttributeNames==null && nodeTargetPAttributeNames!=null)||(nodeSourcePAttributeNames!=null && nodeTargetPAttributeNames==null)){
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.createCollectionWithTreeNodes(Context context): parameters nodeSourcePAttributeNames and nodeTargetPAttributeNames must be both null or both not null" );
            }
            if (nodeSourcePAttributeNames!=null /*nodeTargetPAttributeNames != null surely*/ && nodeSourcePAttributeNames.length!=nodeTargetPAttributeNames.length){
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.createCollectionWithTreeNodes( Context context): parameters nodeSourcePAttributeNames and nodeTargetPAttributeNames must be both null or have the same length" );
            }

            if (pInstance == null) return null;

            String[] oldPkNames=(String[]) context.get("pkNames");
            String oldPath=(String )context.get("path");
            if (path == null ) {
                path="";
                context.put("path",path);
            }
            if (pkNames==null) {


                Object pAttributeName = context.get("pAttributeName");
                context.put("pAttributeName",null);
                pkNames = getPkNames(context);
                context.put("pkNames",pkNames);
                context.put("pAttributeName",pAttributeName);

            }

            Collection  collectionWithTreeNodes = (Collection) ConstructorUtils.invokeConstructor(collectionImplClass,null,null) ;

            //Collection collection, Class collectionItemRealClass, String[] pkNames, Object treeNode, String[] inverseForeignKeyFields,String path, Object[] partialPkValues, Object[] partialSourcePAttributeValues, String[] partialTargetPAttributeNames, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[] pAttributeNames,Object[] valuesArray
            Object collection = context.get("collection");
            Object collectionItemRealClass = context.get("collectionItemRealClass");
            Object treeNode = context.get("treeNode");  // added by Alessandro On 02-dec-2008
            Object inverseForeignKeyFields = context.get("inverseForeignKeyFields");
            Object partialPkValues = context.get("partialPkValues");
            Object partialSourcePAttributeValues = context.get("partialSourcePAttributeValues");
            Object partialTargetPAttributeNames = context.get("partialTargetPAttributeNames");
            Object depth = context.get("depth");
            context.put("collection",collectionWithTreeNodes);
            context.put("collectionItemRealClass",realClass);
            context.put("treeNode",pInstance);  // added by Alessandro On 02-dec-2008
            context.put("inverseForeignKeyFields",null);
            context.put("partialPkValues",null);   // added by Alessandro On 02-dec-2008
            context.put("partialSourcePAttributeValues",null);
            context.put("partialTargetPAttributeNames",null);
            context.put("depth",new Integer(0));

            addToCollectionTreePath(context);

            if(log.isDebugEnabled()) {
                if(collectionWithTreeNodes == null) {
                    log.debug("createCollectionWithTreeNodes: collectionWithTreeNodes is null");
                } else   {
                    log.debug("createCollectionWithTreeNodes: collectionWithTreeNodes.size()= "+collectionWithTreeNodes.size());
                }
            }

            context.put("collection",collection);
            context.put("collectionItemRealClass",collectionItemRealClass);
            context.put("treeNode",treeNode);  // added by Alessandro On 02-dec-2008
            context.put("inverseForeignKeyFields",inverseForeignKeyFields);
            context.put("partialPkValues",partialPkValues);   // added by Alessandro On 02-dec-2008
            context.put("partialSourcePAttributeValues",partialSourcePAttributeValues);
            context.put("partialTargetPAttributeNames",partialTargetPAttributeNames);
            context.put("depth",depth);
            context.put("path",oldPath);
            context.put("pkNames",oldPkNames);




            return collectionWithTreeNodes;
        } catch (NoSuchMethodException e) {
            log.error("NoSuchMethodException caught in BaseContextApplication.createCollectionWithTreeNodes( Context context) : " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.createCollectionWithTreeNodes(Context context) " + e.toString(),e);
        } catch (IllegalAccessException e) {
            log.error("IllegalAccessException caught in BaseContextApplication.createCollectionWithTreeNodes(Context context) : " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.createCollectionWithTreeNodes(Context context) " + e.toString(),e);
        } catch (InvocationTargetException e) {
            log.error("InvocationTargetException caught in BaseContextApplication.createCollectionWithTreeNodes(Context context) : " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.createCollectionWithTreeNodes(Context context) " + e.toString(),e);
        } catch (InstantiationException e) {
            log.error("InstantiationException caught in BaseContextApplication.createCollectionWithTreeNodes(Context context) : " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.createCollectionWithTreeNodes(Context context) " + e.toString(),e);
        }
    }





    /**
     * In the <code>context</code> must be the following keys: </br>
     * <code>"collection"</code></br>
     * <code>"collectionItemRealClass"</code></br>
     * <code>"pkNames"</code></br>
     * <code>"treeNode"</code></br>
     * <code>"inverseForeignKeyFields"</code></br>
     * <code>"path"</code></br>
     * <code>"partialPkValues"</code></br>
     * <code>"partialSourcePAttributeValues"</code></br>
     * <code>"nodeSourcePAttributeNames"</code></br>
     * <code>"partialTargetPAttributeNames"</code></br>
     * <code>"nodeTargetPAttributeNames"</code></br>
     * <code>"depth"</code></br>
     * <code>"pAttributeNames"</code></br>
     * <code>"valuesArray"</code></br>
     * </br>
     * The values of these keys are used for this recursive method in the following way.</br>
     * This is a recursive method that creates a new instance of <code>collectionItemRealClass</code> for each path of the tree from his root to each leaf, and add it to <code>collection</code>.</br>
     * This method do a depth left visit of the tree, the generic node is <code>treeNode</code>, and the first attribute of <code>path</code> (<code>path</code> is a dot separated
     * list of attributes) is an attribute of <code>treeNode</code> that can be a value object (in such case <code>treeNode</code> has just this child) or a collection of value objects, that are all his children.</br>
     * For each path from the root to the leaves, during the recursion, this method builds arrays that represent name of attributes of <code>collectionItemRealClass</code> and  the correspondent values
     * that will be used to set such attributes of the created instance of <code>collectionItemRealClass</code>.</br>
     * The arrays are built in this way: at each recursion (each node) is created a new array that holds all the elements of the correspondent array of his parent , more the specific elements of the node.
     * Three arrays will be built: one holding the primary key values of the instance of <code>collectionItemRealClass</code> to create,
     * one holding the attribute names we want to set of the instance of  <code>collectionItemRealClass</code>, and the last holding the values to use to set such attributes.</br>
     * As we saw, each node on the walk from the root to a leaf add elements to such arrays. When the leaf is reached a new instance of <code>collectionItemRealClass</code> is created,
     * his attributes whose names are in the input parameter <code>pkNames</code> are set with the elements of the built array of primary key values,
     * and the attributes names specified by the elements of the built array of the attributes names will be set
     * with the correspondent elements of the built arrays of values. Moreover the attributes of the created instance of <code>collectionItemRealClass</code> specified by the input parameter
     * <code>pAttributeNames</code> will be set with the correspondent index values of the input parameter <code>valuesArray</code>.</br>
     * Let's see now how the three arrays we talked above are built.</br>
     * </br>
     * The array of the primary key values is built adding to it the primary key values of the current node discarding the inverse foreign keys to his parent, if the current node belongs to a collection
     * of the parent (the first attribute of <code>path</code> of the parent is a collection), and discarding the foreign key to his child, if the link to his child (the first attribute of <code>path</code>) is an attribute holding a value object and not a collection.</br>
     * The array of attributes names is built using the input parameter  <code>nodeTargetPAttributeNames</code>, that is an array of arrays. For a node of depth <code>i</code> (considering the root of depth 0) the elements of the
     * array  <code>nodeTargetPAttributeNames[depth]</code> will be added to the array of the attributes names, if <code>nodeTargetPAttributeNames[depth]</code> is not null. </br>
     * The array of the values to use to set the attributes whose names are specified by the above array of attributes names, is built using the input parameter  <code>nodeSourcePAttributeNames</code>.</br>
     * For a node of depth <code>i</code> (considering the root of depth 0) will be built an array with the values of the attributes of the current node whose names are specified in <code>nodeSourcePAttributeNames[depth]</code>
     * if <code>nodeSourcePAttributeNames[depth]</code> is not null. Than the elements of such built array will be added to the array of values (note that we are talking about the recursively built array and not about the
     * input parameter <code>valuesArray</code>).</br>
     * If a path from a root do not reach the last attribute of <code>path</code>, won't be created the correspondent instance of <code>collectionItemRealClass</code>.</br>
     * </br>
     * The input parameter <code>nodeSourcePAttributeNames</code> and <code>nodeTargetPAttributeNames</code> are both null or both not null otherwise an ApplicationServiceException is thrown.</br>
     * If they are not null must have the same length, that must be the number of token of <code>path</code> more 1 otherwise an ApplicationServiceException is thrown.</br>
     * For each level (depth) of the tree, <code>nodeSourcePAttributeNames[depth]</code> and <code>nodeTargetPAttributeNames[depth]</code> must be bot null or both not null, and
     * if not null must have the same length otherwise an ApplicationServiceException is thrown.</br>
     * When the method reaches a leaf, the built array of primary key values must have reached the same length of <code>pkNames</code> otherwise an ApplicationServiceException is thrown.</br>
     * <code>pAttributeNames</code> and <code>valuesArray</code> have to be both null or both not null, and if they are not null must have the same length otherwise an ApplicationServiceException will be thrown..</br>
     * If one of <code>path</code>, <code>collection</code>, <code>collectionItemRealClass</code>, <code>pkNames</code>  is null, an ApplicationServiceException is thrown.</br>
     * </br>
     * Resuming the values of the specified keys have the following use:</br>
     * <code>collection</code> Collection where the new instances of <code>collectionItemRealClass</code> have to be added to. It can't be null.
     * <code>collectionItemRealClass</code> Class of the instances to create and add to <code>collection</code> .It can't be null.
     * <code>pkNames</code> arrays holding the attribute names of <code>collectionItemRealClass</code> that will be set with the built array of primary key values. It should be the array of primary key fields of <code>collectionItemRealClass</code>. It can't be null.
     * <code>treeNode</code> current node. If null the method return.
     * <code>inverseForeignKeyFields</code> attributes names of the current node that are inverse foreign key to his parent, if the current node (<code>treeNode</code>) belong to a collection of the parent, null otherwise.
     * <code>path</code> dot separated list of attributes that specify a sub tree from <code>treeNode</code>  .It can't be null.
     * <code>partialPkValues</code> array of primary key values from the root of the tree to the current node (<code>treeNode</code>)
     * <code>partialSourcePAttributeValues</code> partial array of values built from the root of the tree to the current node (<code>treeNode</code>)
     * <code>partialTargetPAttributeNames</code> partial array of attributes names from the root of the tree to the current node (<code>treeNode</code>)
     * <code>nodeSourcePAttributeNames</code> array of arrays of attributes names. For a node of a depth, <code>nodeSourcePAttributeNames[depth]</code> is an array holding the attributes names of the node
     *                                  which values have to be added to <code>partialSourcePAttributeValues</code>
     * <code>nodeTargetPAttributeNames</code> array of arrays of attributes names. For a node of a depth, <code>nodeTargetPAttributeNames[depth]</code> elements
     *                                   have to be added to <code>partialTargetPAttributeNames</code>
     * <code>depth</code>  depth  of  he current node (<code>treeNode</code>) in the tree.
     * <code>pAttributeNames</code> names of <code>collectionItemRealClass</code> attributes to populate with values in <code>valuesArray</code>
     * <code>valuesArray</code> values to use to populate <code>collectionItemRealClass</code> attributes in <code>pAttributeNames</code>.
     *
     * @param context must hold the keys which values are the parameters
     * @throws it.aco.mandragora.exception.ApplicationServiceException -
     *  If <code>path</code> is null.</br>
     *  If <code>collection</code> is null.</br>
     *  If <code>collectionItemRealClass</code> is null.</br>
     *  If <code>pkNames</code> is null.</br>
     *  If <code>depth</code> is null.</br>
     *  If <code>pAttributeNames</code>  and <code>valuesArray</code> are not both  null or both not null.</br>
     *  If <code>pAttributeNames</code> and <code>valuesArray</code> are not null and don't have the same length.</br>
     *  If <code>nodeSourcePAttributeNames</code>  and <code>nodeTargetPAttributeNames</code> are not both  null or both not null.</br>
     *  If <code>nodeSourcePAttributeNames</code>  and <code>nodeTargetPAttributeNames</code> are not  null and <code>nodeSourcePAttributeNames[depth]</code>  and <code>nodeTargetPAttributeNames</code>[depth] are not both  null or both not null.</br>
     *  If <code>nodeSourcePAttributeNames[depth]<code> and <code>nodeTargetPAttributeNames[depth]<code> don't have the same length.</br>
     *
     */
    private void addToCollectionTreePath(Context  context)throws ApplicationServiceException{
        log.info("************Entering the BaseContextApplication.addToCollectionTreePath(Context  context)***************");
        try{
            Collection collection = (Collection) context .get("collection");
            log.debug("addToCollectionTreePath : collection = "+collection);
            Class collectionItemRealClass = (Class) context.get("collectionItemRealClass");
            String[] pkNames = (String[]) context.get("pkNames");
            log.debug("addToCollectionTreePath : pkNames = "+pkNames);
            Object treeNode = context.get("treeNode");
            log.debug("addToCollectionTreePath : treeNode = "+treeNode);
            String[] inverseForeignKeyFields =(String[]) context.get("inverseForeignKeyFields");
            String path =(String) context.get("path");
            log.debug("addToCollectionTreePath : path = "+path);
            Object[] partialPkValues=(Object[]) context.get("partialPkValues");
            Object[] partialSourcePAttributeValues = (Object[]) context.get("partialSourcePAttributeValues");
            String[] partialTargetPAttributeNames =(String[]) context.get("partialTargetPAttributeNames");
            String[][] nodeSourcePAttributeNames = (String[][]) context.get("nodeSourcePAttributeNames");
            String[][]  nodeTargetPAttributeNames = (String[][]) context.get("nodeTargetPAttributeNames");
            Integer depth = (Integer) context.get("depth");
            log.debug("addToCollectionTreePath : depth = "+depth);
            String[] pAttributeNames =(String[]) context.get("pAttributeNames");
            Object[] valuesArray= (Object[]) context.get("valuesArray");

            if (path == null) throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addToCollectionTreePath(Context  context) : path can't be null");
            if (collection == null) throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addToCollectionTreePath(Context  context) : collection can't be null");
            if (collectionItemRealClass == null) throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addToCollectionTreePath(Context  context) : collectionItemRealClass can't be null");
            if (pkNames == null) throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addToCollectionTreePath(Context  context) : pkNames can't be null");

            if ((pAttributeNames==null && valuesArray!=null)||(pAttributeNames!=null && valuesArray==null)){
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addToCollectionTreePath(Context  context): parameters pAttributeNames and valuesArray must be both null or both not null" );
            }
            if (pAttributeNames!=null /*valuesArray != null surely*/ && pAttributeNames.length!=valuesArray.length){
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addToCollectionTreePath(Context  context): parameters pAttributeNames and valuesArray must be both null or have the same length" );
            }

            if ((nodeSourcePAttributeNames==null && nodeTargetPAttributeNames!=null)||(nodeSourcePAttributeNames!=null && nodeTargetPAttributeNames==null)){
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addToCollectionTreePath(Context  context): parameters nodeSourcePAttributeNames and nodeTargetPAttributeNames must be both null or both not null" );
            }

            if(nodeSourcePAttributeNames!=null){ /*nodeTargetPAttributeNames != null surely*/
                if((nodeSourcePAttributeNames[depth.intValue()]==null && nodeTargetPAttributeNames[depth.intValue()]!=null)||(nodeSourcePAttributeNames[depth.intValue()]!=null && nodeTargetPAttributeNames[depth.intValue()]==null)){
                    throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addToCollectionTreePath(Context  context): parameters nodeSourcePAttributeNames["+depth.intValue()+"] and nodeTargetPAttributeNames["+depth.intValue()+"] must be both null or both not null" );
                }
                if(nodeSourcePAttributeNames[depth.intValue()]!=null){ /*nodeTargetPAttributeNames[depth.intValue()] != null surely*/
                    if (nodeSourcePAttributeNames[depth.intValue()].length!=nodeTargetPAttributeNames[depth.intValue()].length){
                        throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addToCollectionTreePath(Context  context): if nodeSourcePAttributeNames["+depth.intValue()+"] and nodeTargetPAttributeNames["+depth.intValue()+"] are not null, must have the same length" );
                    }
                }
            }

            if (treeNode!=null) { // if we get a null node path didn't get the bottom, so no item is added to the collection
                                        // this condition should be always true, as it is checked before calling the recursion

                Object[] newPartialSourcePAttributeValues;
                String[] newPartialTargetPAttributeNames ;
                if (nodeSourcePAttributeNames!=null && nodeSourcePAttributeNames[depth.intValue()]!=null) { /*nodeTargetPAttributeNames != null and nodeTargetPAttributeNames[depth.intValue()]!=null surely*/
                    newPartialSourcePAttributeValues = Utils.arrayUnion(partialSourcePAttributeValues,BeanCollectionUtils.getAttributes(treeNode,nodeSourcePAttributeNames[depth.intValue()]));
                    newPartialTargetPAttributeNames = (String[]) Utils.arrayUnion(partialTargetPAttributeNames,nodeTargetPAttributeNames[depth.intValue()]);
                }else{
                    newPartialSourcePAttributeValues=partialSourcePAttributeValues;
                    newPartialTargetPAttributeNames=partialTargetPAttributeNames;
                }

                Object realClass = context.get("realClass");
                Object pAttributeName = context.get("pAttributeName");
                ContextDAO contextDAO = getContextDAO(context);

                if(path.trim().equals("")){// treeNode is a leaf
                    log.debug("addToCollectionTreePath : treeNode is a leaf = ");
                    Object collectionElement = ConstructorUtils.invokeConstructor(collectionItemRealClass,null,null);
                    if (newPartialTargetPAttributeNames!=null) BeanCollectionUtils.setAttributes(collectionElement, newPartialTargetPAttributeNames, newPartialSourcePAttributeValues);
                    if (pAttributeNames!=null) BeanCollectionUtils.setAttributes(collectionElement, pAttributeNames, valuesArray);

                    context.put("realClass",treeNode.getClass());
                    //String[] treeNodePkNotInverseForeignKeyFields =(String[]) Utils.arraySubtract(contextDAO.getPkNames(context),inverseForeignKeyFields);  // deleted by Alessandro on 03-dec-2008
                    String[] treeNodePkNotInverseForeignKeyFields =(String[]) Utils.arraySubtract(contextDAO.getPkNames(context),inverseForeignKeyFields,String.class);  // added by Alessandro on 03-dec-2008
                    context.put("realClass",realClass);

                    Object[] treeNodePkNotInverseForeignKeyValues = BeanCollectionUtils.getAttributes(treeNode,treeNodePkNotInverseForeignKeyFields);
                    Object[] newPartialPkValues = Utils.arrayUnion(partialPkValues,treeNodePkNotInverseForeignKeyValues);

                    BeanCollectionUtils.setAttributes(collectionElement, pkNames, newPartialPkValues);
                    collection.add(collectionElement);

                }else{ // treeNode is not a leaf
                    PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();
                    String[] firstAttributeNameAndRemainingPath = Utils.getFirstAttributeNameAndRemainingPath(path);
                    Object referenceValue = propertyUtilsBean.getProperty(treeNode, firstAttributeNameAndRemainingPath[0]);
                    //if (referenceValue == null) return;
                    if (referenceValue != null) {
                        log.debug("addToCollectionTreePath : referenceValue = "+referenceValue);
                        context.put("realClass",treeNode.getClass());
                        context.put("pAttributeName",firstAttributeNameAndRemainingPath[0]);

                        context.put("path",firstAttributeNameAndRemainingPath[1]);
                        context.put("partialSourcePAttributeValues",newPartialSourcePAttributeValues);
                        context.put("partialTargetPAttributeNames",newPartialTargetPAttributeNames);
                        context.put("depth",new Integer(depth.intValue()+1));

                        if (Collection.class.isInstance(referenceValue)){
                            log.debug("addToCollectionTreePath : referenceValue is a collection ");
                            //String[] treeNodePkNotInverseForeignKeyFields = (String[]) Utils.arraySubtract(contextDAO.getPkNames(context),inverseForeignKeyFields);  // deleted by Alessandro on 03-dec-2008
                            String[] treeNodePkNotInverseForeignKeyFields = (String[]) Utils.arraySubtract(contextDAO.getPkNames(context),inverseForeignKeyFields,String.class);// added by Alessandro on 03-dec-2008

                            // start added by Alessandro on 2-dec-2008
                            String[]  nextInverseForeignKeyFields = null;
                            Collection newInverseForeignKeyFields = contextDAO.getInverseForeignKeyFields(context);
                            if(newInverseForeignKeyFields!=null) {
                                nextInverseForeignKeyFields = (String[]) newInverseForeignKeyFields.toArray(new String[newInverseForeignKeyFields.size()]);
                            }
                            // end added by Alessandro on 2-dec-2008

                            //String[]  nextInverseForeignKeyFields = (String[]) contextDAO.getInverseForeignKeyFields(context).toArray(inverseForeignKeyFields); // deleted by Alessandro on 2-dec-2008


                            Object[] treeNodePkNotInverseForeignKeyValues = BeanCollectionUtils.getAttributes(treeNode,treeNodePkNotInverseForeignKeyFields);// deleted by Alessandro on 2-dec-2008
                            Object[] newPartialPkValues = Utils.arrayUnion(partialPkValues,treeNodePkNotInverseForeignKeyValues);
                            log.debug("addToCollectionTreePath :((Collection)referenceValue).size() =  "+((Collection)referenceValue).size());
                            Iterator referenceValueIterator  = ((Collection)referenceValue).iterator();
                            while (referenceValueIterator.hasNext()){
                                context.put("treeNode",referenceValueIterator.next());
                                context.put("inverseForeignKeyFields",nextInverseForeignKeyFields);
                                context.put("partialPkValues",newPartialPkValues);

                                addToCollectionTreePath(context);
                            }
                        } else{
                            log.debug("addToCollectionTreePath : referenceValue is a Value Object ");
                            String[] treeNodeAttributesNamesToAddToPartialPkValues =  getPkNotForeignKeyFields(context);
                            if (inverseForeignKeyFields!=null && inverseForeignKeyFields.length!=0){
                                //treeNodeAttributesNamesToAddToPartialPkValues = (String[]) Utils.arraySubtract(treeNodeAttributesNamesToAddToPartialPkValues,inverseForeignKeyFields); // deleted by Alessandro on 03-dec-2008
                                treeNodeAttributesNamesToAddToPartialPkValues = (String[]) Utils.arraySubtract(treeNodeAttributesNamesToAddToPartialPkValues,inverseForeignKeyFields,String.class);   // added by Alessandro on 03-dec-2008
                            }
                            Object[] newPartialPkValues = Utils.arrayUnion(partialPkValues,BeanCollectionUtils.getAttributes(treeNode,treeNodeAttributesNamesToAddToPartialPkValues));

                            context.put("treeNode",referenceValue);
                            context.put("inverseForeignKeyFields",null);
                            context.put("partialPkValues",newPartialPkValues);

                            addToCollectionTreePath(context);
                        }
                        context.put("realClass",realClass);
                        context.put("pAttributeName",pAttributeName);

                        context.put("treeNode",treeNode);
                        context.put("inverseForeignKeyFields",inverseForeignKeyFields);
                        context.put("path",path);
                        context.put("partialPkValues",partialPkValues);
                        context.put("partialSourcePAttributeValues",partialSourcePAttributeValues);
                        context.put("partialTargetPAttributeNames",partialTargetPAttributeNames);
                        context.put("depth",depth);
                    }
                }
            }
        } catch (DataAccessException e) {
            log.error("DataAccessException caught in BaseContextApplication.addToCollectionTreePath(Context  context) " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addToCollectionTreePath(Context  context)" + e.toString(),e);
        } catch (NoSuchMethodException e) {
            log.error("NoSuchMethodException caught in BaseContextApplication.addToCollectionTreePath(Context  context) " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addToCollectionTreePath(Context  context)" + e.toString(),e);
        } catch (IllegalAccessException e) {
            log.error("IllegalAccessException caught in BaseContextApplication.addToCollectionTreePath(Context  context) " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addToCollectionTreePath(Context  context)" + e.toString(),e);
        } catch (InvocationTargetException e) {
            log.error("InvocationTargetException caught in BaseContextApplication.addToCollectionTreePath(Context  context) " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addToCollectionTreePath(Context  context)" + e.toString(),e);
        } catch (InstantiationException e) {
            log.error("InstantiationException caught in BaseContextApplication.addToCollectionTreePath(Context  context) " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addToCollectionTreePath(Context  context)" + e.toString(),e);
        } catch (Exception e) {
            log.error("Exception caught in BaseContextApplication.addToCollectionTreePath(Context  context) " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addToCollectionTreePath(Context  context)" + e.toString(),e);
        }
        log.info("************Done with the  BaseContextApplication.addToCollectionTreePath(Context  context) **************");
    }




    public void createValueObjectsTreeWithCollection(Context context) throws ApplicationServiceException{
        try{
            Object depth = context.get("depth");
            context.put("depth", new Integer(0));
            //createValueObjectsTreeWithCollection( null, null, null, null, null, null, null,context);
            createValueObjectsTreeWithCollectionRecursive(context);
            context.put("depth", depth);

        }catch (Exception e) {
            log.error("Exception caught in BaseContextApplication.createValueObjectsTreeWithCollection(Context context)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.createValueObjectsTreeWithCollection(Context context)" + e.toString(),e);
        }
    }




    /**
     * In the <code>context</code> must be the following keys: </br>
     * <code>"valueObjectsCollection"</code></br>
     * <code>"pInstance"</code></br>
     * <code>"path"</code></br>
     * <code>"groupedPkNames"</code></br>
     * <code>"nodePAttributeNames"</code></br>
     * <code>"nodeValuesArray"</code></br>
     * <code>"depth"</code></br>
     * </br>
     *
     *
     * This is a recursive method that at each recursion creates a value object that is a node of a tree of value objects , populating the primary key attributes of the created node
     * with attributes values of items of the collection input parameter <code>valueObjectsCollection</code>.</br>
     * The tree is built with a depth left visit, where the generic node is <code>pInstance</code>, and the first attribute of <code>path</code> (<code>path</code> is a dot separated
     * list of attributes) is an attribute of <code>pInstance</code> that can be a value object (in this case <code>pInstance</code> has just such child) or a collection of value objects,
     * that are all the children of <code>pInstance</code>.</br>
     * In each recursion will be create a child of <code>pInstance</code>.</br>
     * The children of <code>pInstance</code> will be as many as are the distinct sets of values of the attributes, whose names are in <code>groupedPkNames[depth]</code>, of the items of <code>valueObjectsCollection</code>.</br>
     * For each one of such distinct sets will be created a new instance of the  class of the children of <code>pInstance</code> (class that must be specified in the mapping file, i.e repository.xml in Ojb)
     * and his primary key fields will be set with the set of the values that is being processed; moreover the attributes of the new instance named as in <code>nodePAttributeNames[depth]</code> will be set
     * with the corresponding values of  <code>nodeValuesArray[depth]</code>.</br>
     * The length of <code>groupedPkNames[depth]</code> must be the same of the number of the key fields of the node class of the level  <code>depth+1</code> where the root is considered to be
     * of level 0, otherwise an ApplicationServiceException is thrown </br>
     * </br>.
     * If the first attribute of path of <code>pInstance</code>, let's call it <code>firstAttribute</code>, is specified to be a collection in the mapping file (i.e repository.xml in Ojb),
     * such collection will be created,  all the created instances children of <code>pInstance</code> will be added to it and the first attribute of <code>pInstance</code> will be set with this collection, while,
     * if the first attribute of path of <code>pInstance</code>, firstAttribute, is specified to be a value object in the mapping file, there must be only one distinct set of values of the attributes
     * <code>groupedPkNames[depth]</code> in  <code>valueObjectsCollection</code>, otherwise an ApplicationServiceException is thrown, so only one instance of the class of level <code>depth+1</code>
     * will be created, and the first attribute of <code>pInstance</code> will be set with this instance  .</br>
     * If the first attribute of path of <code>pInstance</code> is a collection all the inverse foreign key of the elements of  the collection referring to <code>pInstance</code>
     * will be set with the key values of  <code>pInstance</code>, while if the first attribute of path of <code>pInstance</code> is a value object,
     * the foreign keys of  <code>pInstance</code> referring to such value objects will set with the key values of the value object.</br>
     * In both case this method will be recursively called for each one of the created children of <code>pInstance</code>, passing the child as <code>pInstance</code>, the <code>path</code> with
     * the first attribute excluded, and <code>depth+1</code>; as <code>valueObjectsCollection</code> will be passed the same <code>valueObjectsCollection</code> filtered
     * so to have just the elements that have the attributes groupedPkNames[depth] equals to the key values of the child being passed as <code>pInstance</code> .
     * The recursion will end at the end of <code>path</code> .</br>
     * </br>
     * If <code>valueObjectsCollection</code> is null or empty the method return.</br>
     * If <code>path</code> is empty string or blank characters string the method return.</br>
     * If <code>groupedPkNames</code> is null, as <code>groupedPkNames[depth]</code> will be considered the primary key fields of the class of nodes of level  <code>depth+1</code>
     * where the root is considered to be of level 0; even if groupedPkNames is not null, some <code>groupedPkNames[depth]</code> can be null, and in such case, the  same rule is applied.</br>
     * If <code>groupedPkNames</code> is not null, his length must be greater or equal than the number of tokens of <code>path</code>, otherwise an ApplicationServiceException is thrown;
     * if strictly greater, the ones left over, will be ignored.</br>
     * For each depth <code>groupedPkNames[depth]</code> must be greater or equals than the number of the key fields of the node class of the level  <code>depth+1</code> (the over ones will be ignored)
     * otherwise an ApplicationServiceException is thrown.</br>
     *
     * Resuming the values of the specified keys have the following use:</br>
     *
     * <code>valueObjectsCollection</code> Collection of value objects used to create the tree of value objects. If null or empty the method returns.
     * <code>pInstanc</code>e root of the tree. It can't be null.
     * <code>path</code> dot separated list of attributes, defining the tree with <code>pInstance</code>
     * <code>groupedPkNames</code> array of arrays of attributes names that specifies how to group the <code>valueObjectsCollection</code> item attributes to constitute the primary keys of the nodes of the tree to create.</br>
     * <code>nodePAttributeNames</code>  array of arrays of attributes names of the children of <code>pInstance</code> to create, attributes to populate with values in <code>nodeValuesArray</code>
     * <code>nodeValuesArray</code>  array of arrays of values to use to populate the children of <code>pInstance</code> to create attributes in <code>nodePAttributeNames</code>.
     * <code>depth</code> depth of <code>pInstance</code>
     *
     * @param context if not null must hold the input parameters.</br>
     * @throws it.aco.mandragora.exception.ApplicationServiceException if <code>pInstance</code> or <code>path</code> are null.</br>
     *      If <code>groupedPkNames</code> is not null, and his length is less than the number of tokens of <code>path</code>.</br>
     *      If <code>groupedPkNames</code> is not null and for some depth <code>groupedPkNames[depth]</code> has length less than the number of the key fields of the node class of the level  <code>depth+1</code> where the root is considered to be of level 0.</br>
     *      If <code>nodePAttributeNames</code> and <code>nodeValuesArray</code> are not both null or both not null.</br>
     *      If <code>nodePAttributeNames</code> and <code>nodeValuesArray</code> are both not null and they don't have the same length.</br>
     *      If <code>nodePAttributeNames</code> and <code>nodeValuesArray</code> are both not null, have the same length, but the length is less than the number of tokens of <code>path</code> .</br>
     *      If <code>nodePAttributeNames</code> and <code>nodeValuesArray</code> are both not null, have the same length, that is greater or equals  than the number of tokens of <code>path</code>,
     *      but for some depth, <code>nodePAttributeNames[depth]</code> <code>nodePAttributeNames[depth]</code> are not both null and  not both not null, or if both not null, they don't have  the same length   .</br>
     */
    private void createValueObjectsTreeWithCollectionRecursive(Context context) throws ApplicationServiceException{
        log.info("************Entering the BaseContextApplication.createValueObjectsTreeWithCollectionRecursive(Context context)  ***************");
        try{

            Collection valueObjectsCollection=(Collection) context.get("valueObjectsCollection");
            Object pInstance=context.get("pInstance");
            String path = (String) context.get("path");
            String[][]groupedPkNames = (String[][]) context.get("groupedPkNames");
            String[][]nodePAttributeNames = (String[][]) context.get("nodePAttributeNames");
            Object[][]nodeValuesArray=(Object[][]) context.get("nodeValuesArray");
            Integer depth = (Integer) context.get("depth");
            log.debug("createValueObjectsTreeWithCollectionRecursive : depth = "+depth);

            if (pInstance==null||path==null) throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.createValueObjectsTreeWithCollectionRecursive(Context context) :pInstance can't be null " );
            //if (groupedPkNames==null) throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.createValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, int depth) :pkNames can't be null " );
            //start added by Alessandro on 04-dec-2008
            if ((nodePAttributeNames==null && nodeValuesArray!=null)||(nodePAttributeNames!=null && nodeValuesArray==null)){
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.createValueObjectsTreeWithCollectionRecursive(Context  context): parameters nodePAttributeNames and nodeValuesArray must be both null or both not null" );
            }
            if (nodePAttributeNames!=null /*nodeValuesArray != null surely*/ && nodePAttributeNames.length!=nodeValuesArray.length){
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.createValueObjectsTreeWithCollectionRecursive(Context  context): parameters nodePAttributeNames and nodeValuesArray must be both null or have the same length" );
            }
            //end added by Alessandro on 04-dec-2008
            if (valueObjectsCollection==null || valueObjectsCollection.isEmpty()) return;
            if(path.trim().equals(""))return;

            ContextDAO contextDAO = getContextDAO(context);
            PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();



            String[] firstAttributeNameAndRemainingPath = Utils.getFirstAttributeNameAndRemainingPath(path);

            Class nextCollectionImplClass;
            Class nextNodeClass;
            String[] nextNodePkNames;

            Object realClass= context.get("realClass") ;
            context.put("realClass", pInstance.getClass());
            context.put("path", firstAttributeNameAndRemainingPath[0]);

            nextCollectionImplClass = contextDAO.getCollectionClassFromPath(context);
            nextNodeClass = contextDAO.getClassFromPath(context);
            context.put("realClass",nextNodeClass);
            nextNodePkNames= contextDAO.getPkNames(context);

            context.put("realClass",realClass);
            context.put("path", path);



            String[] pkNamesToMakeDistinctCollection;
            if(groupedPkNames==null || groupedPkNames[depth.intValue()]==null){
                pkNamesToMakeDistinctCollection = nextNodePkNames;
            }else{
                pkNamesToMakeDistinctCollection = groupedPkNames[depth.intValue()];
                if(pkNamesToMakeDistinctCollection.length!=nextNodePkNames.length){
                    throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.createValueObjectsTreeWithCollectionRecursive(Context context): in the depth = "+depth.intValue()+"the pknames["+depth.intValue()+"] has not the same lenght of the number of key fields of the value objects of depth ="+depth.intValue() );
                }
            }

            Collection distinctValueObjectsCollection = Utils.selectDistinct(valueObjectsCollection,pkNamesToMakeDistinctCollection);
            if (distinctValueObjectsCollection == null || distinctValueObjectsCollection.isEmpty()) return;

            boolean firstAttributeIsCollection=false;
            if(nextCollectionImplClass!=null)firstAttributeIsCollection=true;
            if(!firstAttributeIsCollection && distinctValueObjectsCollection.size()>1)throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.createValueObjectsTreeWithCollectionRecursive(Context context): next node is a value object but in the value objects collection there is more than one correspondig element" );
            Collection nextCollection = null;
            if(firstAttributeIsCollection) nextCollection = (Collection) ConstructorUtils.invokeConstructor(nextCollectionImplClass,null,null);
            Iterator distinctValueObjectsCollectionIterator = distinctValueObjectsCollection.iterator();

            Object pAttributeName = null;
            pAttributeName = context.get("pAttributeName");
            while (distinctValueObjectsCollectionIterator.hasNext()){//if pInstance.firstAttributeNameAndRemainingPath[0] is a
                                                                     // value object, surely there will be just one iteration
                                                                     // as distinctValueObjectsCollection.size()=1
                Object distinctValueObjectsCollectionItem = distinctValueObjectsCollectionIterator.next();

                Object[] distinctValueObjectsCollectionItemPkValues = BeanCollectionUtils.getAttributes(distinctValueObjectsCollectionItem,pkNamesToMakeDistinctCollection);

                Object pInstanceChild = ConstructorUtils.invokeConstructor(nextNodeClass,null,null);
                BeanCollectionUtils.setAttributes(pInstanceChild,nextNodePkNames,distinctValueObjectsCollectionItemPkValues);
                // start added by Alessandro on 04-dec-2008
                if (nodePAttributeNames!=null /*nodeValuesArray != null surely*/ ){
                     BeanCollectionUtils.setAttributes(pInstanceChild,nodePAttributeNames[depth.intValue()],nodeValuesArray[depth.intValue()]);
                }
                // end added by Alessandro on 04-dec-2008
                //BeanCollectionUtils.setAttributes(pInstanceChild,nodePAttributeNames[depth.intValue()],nodeValuesArray[depth.intValue()]);//deleted by Alessandro on 04-dec-2008




                // forSubTreeValueObjectsCollection is impossible that is null or empty beacuse distinctValueObjectsCollection is not null and not empty
                if (firstAttributeIsCollection){
                    nextCollection.add(pInstanceChild);

                }else { // there is the only one iteration
                    //if (forSubTreeValueObjectsCollection.size()>1) throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.createValueObjectsTreeWithCollection(Collection  valueObjectsCollection, Object pInstance,String path, String[][] groupedPkNames,  String[][] nodePAttributeNames,Object[][] nodeValuesArray, int depth): next node is a value object but in the value objects collection there is more than one correspondig element" );
                    propertyUtilsBean.setProperty(pInstance,firstAttributeNameAndRemainingPath[0],pInstanceChild);

                    context.put("pInstance",pInstance);
                    context.put("pAttributeName",firstAttributeNameAndRemainingPath[0]);
                    //setForeignKeyFields(null,null,context);

                    setForeignKeyFields(context);
                }
                Collection forSubTreeValueObjectsCollection = Utils.selectWhereFieldsEqualsTo(valueObjectsCollection,pkNamesToMakeDistinctCollection,distinctValueObjectsCollectionItemPkValues);

                context.put("valueObjectsCollection",forSubTreeValueObjectsCollection);
                context.put("pInstance",pInstanceChild);
                context.put("path",firstAttributeNameAndRemainingPath[1]);
                //log.debug("createValueObjectsTreeWithCollectionRecursive:::depth = "+depth);
                //log.debug("createValueObjectsTreeWithCollectionRecursive:::new Integer(depth.intValue()+1) = "+new Integer(depth.intValue()+1));
                context.put("depth",new Integer(depth.intValue()+1));

                //createValueObjectsTreeWithCollection( null, null,null,  null,  null, null,  null,context);


                //createValueObjectsTreeWithCollection(context);         // deleted by Alessandro on 04-dec-2008
                createValueObjectsTreeWithCollectionRecursive(context);  // added by Alessandro on 04-dec-2008
            }

            context.put("valueObjectsCollection",valueObjectsCollection);
            context.put("pInstance",pInstance);
            context.put("path",path);
            context.put("depth",depth);

            if (firstAttributeIsCollection){
                propertyUtilsBean.setProperty(pInstance,firstAttributeNameAndRemainingPath[0],nextCollection);
                context.put("pAttributeName",firstAttributeNameAndRemainingPath[0]);
                //setInverseForeignKeyFields(context);        // deleted by Alessandro on 04-dec-2008
                contextDAO.setInverseForeignKeyFields(context);  // added by Alessandro on 04-dec-2008
            }
            context.put("pAttributeName",pAttributeName);
        }catch (ServiceLocatorException e) {
            log.error("ServiceLocatorException caught in BaseContextApplication.createValueObjectsTreeWithCollectionRecursive(Context context)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.createValueObjectsTreeWithCollectionRecursive(Context context)" + e.toString(),e);
        }catch (DataAccessException e) {
            log.error("DataAccessException caught in BaseContextApplication.createValueObjectsTreeWithCollectionRecursive(Context context)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.createValueObjectsTreeWithCollectionRecursive( Context context)" + e.toString(),e);
        }catch (IllegalAccessException e) {
            log.error("IllegalAccessException caught in BaseContextApplication.createValueObjectsTreeWithCollectionRecursive(Context context)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.createValueObjectsTreeWithCollectionRecursive( Context context)" + e.toString(),e);
        }catch (NoSuchMethodException e) {
            log.error("NoSuchMethodException caught in BaseContextApplication.createValueObjectsTreeWithCollectionRecursive(Context context)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.createValueObjectsTreeWithCollectionRecursive( Context context)" + e.toString(),e);
        }catch (InstantiationException e) {
            log.error("InstantiationException caught in BaseContextApplication.createValueObjectsTreeWithCollectionRecursive( Context context)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.createValueObjectsTreeWithCollectionRecursive( Context context)" + e.toString(),e);
        }catch (InvocationTargetException e) {
            log.error("InvocationTargetException caught in BaseContextApplication.createValueObjectsTreeWithCollectionRecursive(Context context)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.createValueObjectsTreeWithCollectionRecursive( Context context)" + e.toString(),e);
        }catch (Exception e) {
            log.error("Exception caught in BaseContextApplication.createValueObjectsTreeWithCollectionRecursive(Context context)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.createValueObjectsTreeWithCollectionRecursive(Context context)" + e.toString(),e);
        }
        log.info("************Done with the  BaseContextApplication.createValueObjectsTreeWithCollectionRecursive(Context context)**************");
    }



    public void addToValueObjectsTreeWithCollection(Context context) throws ApplicationServiceException{
        try{

            Object depth = context.get("depth");
            context.put("depth", new Integer(0));
            //createValueObjectsTreeWithCollection(context);   deleted by Alessandro on 04-dec-2008

            //addToValueObjectsTreeWithCollection(context);   // deleted by Alessandro on 04-dec-2008
            addToValueObjectsTreeWithCollectionRecursive(context); // added by Alessandro on 04-dec-2008
            context.put("depth", depth);
        }catch (Exception e) {
            log.error("Exception caught in BaseContextApplication.addToValueObjectsTreeWithCollection(Context context)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addToValueObjectsTreeWithCollection(Context context)" + e.toString(),e);
        }
    }




    /**
     *
     * In the <code>context</code> must be the following keys: </br>
     * <code>"valueObjectsCollection"</code></br>
     * <code>"pInstance"</code></br>
     * <code>"path"</code></br>
     * <code>"groupedPkNames"</code></br>
     * <code>"nodePAttributeNames"</code></br>
     * <code>"nodeValuesArray"</code></br>
     * <code>"depth"</code></br>
     * </br>
     *
     *
     * This is a recursive method that at each recursion creates a value object node and add it to a tree of value objects if not yet existing in it, populating the primary key attributes of the created node
     * with attributes values of items of the collection input parameter <code>valueObjectsCollection</code>.</br>
     * The new nodes are added to the tree visiting it with a depth-first left search, where the generic node is <code>pInstance</code>, and the first attribute of <code>path</code> (<code>path</code> is a dot separated
     * list of attributes) is an attribute of <code>pInstance</code> that can be a value object (in this case <code>pInstance</code> has just such child) or a collection of value objects,
     * that are all the children of <code>pInstance</code>.</br>
     * The depth of the node <code>pInstance</code> is specified by the input parameter <code>depth</code>.</br>
     * In a recursion for a node <code>pInstance</code> of a <code>depth</code>, this method gets all the distinct sets of values of the attributes, whose names are in <code>groupedPkNames[depth]</code>, of the items of <code>valueObjectsCollection</code>.</br>
     * If the first attribute of <code>path</code> specifies the name of an attribute of  <code>pInstance</code> that is a value objects, there must be just
     * one distinct set of values, otherwise an ApplicationServiceException is thrown; if such attribute of <code>pInstance</code> is null or the primary keys values
     * of the value object represented by such attribute are not equals to the distinct set of values, the attribute of  <code>pInstance</code> is replaced
     * by a new instance of the class of the attribute that have as primary key values the set of distinct values. Moreover for such new instance the attributes named as in <code>nodePAttributeNames[depth]</code> will be set
     * with the corresponding values of  <code>nodeValuesArray[depth]</code> (of course if they are not null); in both cases the foreign key fields
     * of <code>pInstance</code> referring to the value object child, are set with the primary key values of the same child. (It could be that even if the right
     * child was already existing, the foreign key fields to it were not properly set). </br>
     * If the first attribute of <code>path</code> specifies the name of an attribute of  <code>pInstance</code> that is a collection, if such collection is null
     * a new empty one is created (using the implementation specified in the mapping file, i.e repository.xml for Ojb), and the attribute of  <code>pInstance</code>
     * will be set to it.</br>
     * For each one of the distinct sets of values of the attributes, whose names are in <code>groupedPkNames[depth]</code>, of the items of <code>valueObjectsCollection</code>
     * if in the collection of the children of <code>pInstance</code> is not yet present  a value object which primary key values are  equals to the distinct set of values
     * being processed, such value object will be created (a new instance of the class of the children of <code>pInstance</code>, class that should be mapped
     * in the mapping file, i.e repository.xml for Ojb) with key primary values set to the values of the distinct set of values being processed. Moreover for such new instance the attributes named as in <code>nodePAttributeNames[depth]</code> will be set
     * with the corresponding values of  <code>nodeValuesArray[depth]</code> (of course if they are not null); then the new created instances will be added
     * to the collection of the children of <code>pInstance</code>.</br>
     * For all the children of <code>pInstance</code>, the inverse foreign key field referring to the parent <code>pInstance</code> will be set with the key values
     * of <code>pInstance</code>, this is done for the new added ones and for the already existing children, as it could be that such fields, for the already existing children,
     * were not properly set.</br>
     * For all the the children of <code>pInstance</code>, in both cases that the first attribute of <code>path</code> specifies a value object or a collection,
     * this method will be recursively called passing the child as <code>pInstance</code>, the <code>path</code> with
     * the first attribute excluded, and <code>depth+1</code>; as <code>valueObjectsCollection</code> will be passed the same <code>valueObjectsCollection</code> filtered
     * so to have just the elements that have the attributes groupedPkNames[depth] equals to the key values of the child being passed as <code>pInstance</code> .
     * The recursion will end at the end of <code>path</code>.</br>
     * </br>
     * If <code>valueObjectsCollection</code> is null or empty the method return.</br>
     * If <code>path</code> is empty string or blank characters string the method return.</br>
     * If <code>groupedPkNames</code> is null, as <code>groupedPkNames[depth]</code> will be considered the primary key fields of the class of nodes of level  <code>depth+1</code>
     * where the root is considered to be of level 0; even if groupedPkNames is not null, some <code>groupedPkNames[depth]</code> can be null, and in such case, the  same rule is applied.</br>
     * If <code>groupedPkNames</code> is not null, his length must be greater or equal than the number of tokens of <code>path</code>, otherwise an ApplicationServiceException is thrown;
     * if strictly greater, the ones left over, will be ignored.</br>
     * For each depth <code>groupedPkNames[depth]</code> must be greater or equals than the number of the key fields of the node class of the level  <code>depth+1</code> (the over ones will be ignored)
     * otherwise an ApplicationServiceException is thrown.</br>
     *
     *
     * Resuming the values of the specified keys have the following use:</br>
     *
     * <code>valueObjectsCollection</code>  Collection of value objects used to create the value objects nodes to add to the tree. If null or empty the method returns.
     * <code>pInstance</code> root of the tree. It can't be null.
     * <code>path</code> dot separated list of attributes, defining the tree with <code>pInstance</code>
     * <code>groupedPkNames</code> array of arrays of attributes names that specifies how to group the <code>valueObjectsCollection</code> item attributes to constitute the primary keys of the nodes to add to the the tree if not yet present.</br>
     * <code>nodePAttributeNames</code>  array of arrays of attributes names of the children of <code>pInstance</code> to create and add to the tree, attributes to populate with values in <code>nodeValuesArray</code>
     * <code>nodeValuesArray</code>  array of arrays of values to use to populate the children of <code>pInstance</code> attributes in <code>nodePAttributeNames</code>.
     * <code>depth</code> depth of <code>pInstance</code>
     * @param context if not null must hold the input parameters.</br>
     * @throws it.aco.mandragora.exception.ApplicationServiceException - if <code>pInstance</code> or <code>path</code> are null.</br>
     *      If <code>groupedPkNames</code> is not null, and its length is less than the number of tokens of <code>path</code>.</br>
     *      If <code>groupedPkNames</code> is not null and for some depth <code>groupedPkNames[depth]</code> has length less than the number of the key fields of the node class of the level  <code>depth+1</code> where the root is considered to be of level 0.</br>
     *      If <code>nodePAttributeNames</code> and <code>nodeValuesArray</code> are not both null or both not null.</br>
     *      If <code>nodePAttributeNames</code> and <code>nodeValuesArray</code> are both not null and they don't have the same length.</br>
     *      If <code>nodePAttributeNames</code> and <code>nodeValuesArray</code> are both not null, have the same length, but the length is less than the number of tokens of <code>path</code> .</br>
     *      If <code>nodePAttributeNames</code> and <code>nodeValuesArray</code> are both not null, have the same length, that is greater or equals  than the number of tokens of <code>path</code>,
     *      but for some depth, <code>nodePAttributeNames[depth]</code> <code>nodePAttributeNames[depth]</code> are not both null and  not both not null, or if both not null, they don't have  the same length   .</br>
     */
    private void addToValueObjectsTreeWithCollectionRecursive( Context context) throws ApplicationServiceException{
        try{

            Collection valueObjectsCollection = (Collection) context.get("valueObjectsCollection");
            Object pInstance = context.get("pInstance");
            String path = (String) context.get("path");
            String[][] groupedPkNames = (String[][]) context.get("groupedPkNames");
            String[][] nodePAttributeNames = (String[][]) context.get("nodePAttributeNames");
            Object[][] nodeValuesArray = (Object[][]) context.get("nodeValuesArray");
            Integer depth = (Integer) context.get("depth");


            log.debug("addToValueObjectsTreeWithCollectionRecursive : depth = "+depth);
            log.debug("addToValueObjectsTreeWithCollectionRecursive : pInstance = "+pInstance);

            if (pInstance==null||path==null) throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addToValueObjectsTreeWithCollectionRecursive( Context context) :pInstance can't be null " );
            //start added by Alessandro on 04-dec-2008
            if ((nodePAttributeNames==null && nodeValuesArray!=null)||(nodePAttributeNames!=null && nodeValuesArray==null)){
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addToValueObjectsTreeWithCollectionRecursive(Context  context): parameters nodePAttributeNames and nodeValuesArray must be both null or both not null" );
            }
            if (nodePAttributeNames!=null /*nodeValuesArray != null surely*/ && nodePAttributeNames.length!=nodeValuesArray.length){
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addToValueObjectsTreeWithCollectionRecursive(Context  context): parameters nodePAttributeNames and nodeValuesArray must be both null or have the same length" );
            }
            //end added by Alessandro on 04-dec-2008

            if (valueObjectsCollection==null || valueObjectsCollection.isEmpty()) return;
            if(path.trim().equals(""))return;

            ContextDAO contextDAO = getContextDAO(context);
            PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();

            String[] firstAttributeNameAndRemainingPath = Utils.getFirstAttributeNameAndRemainingPath(path);

            Class nextCollectionImplClass;
            Class nextNodeClass;
            String[] nextNodePkNames;

            Object realClass = context.get("realClass");
            context.put("realClass",pInstance.getClass());
            context.put("path",firstAttributeNameAndRemainingPath[0]);

            nextCollectionImplClass = contextDAO.getCollectionClassFromPath(context);
            nextNodeClass = contextDAO.getClassFromPath(context);
            context.put("realClass",nextNodeClass);
            nextNodePkNames= contextDAO.getPkNames(context);

            context.put("realClass",realClass);
            context.put("path",path);


            String[] pkNamesToMakeDistinctCollection;
            if(groupedPkNames==null || groupedPkNames[depth.intValue()]==null){
                pkNamesToMakeDistinctCollection = nextNodePkNames;
            }else{
                pkNamesToMakeDistinctCollection = groupedPkNames[depth.intValue()];
                if(pkNamesToMakeDistinctCollection.length!=nextNodePkNames.length){
                    throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addToValueObjectsTreeWithCollectionRecursive(Context context): in the depth ="+depth.intValue()+"the pknames[depth] has not the same lenght of the number of key fields of the value objects of depth" );
                }
            }

            Collection distinctValueObjectsCollection = Utils.selectDistinct(valueObjectsCollection,pkNamesToMakeDistinctCollection);
            if (distinctValueObjectsCollection == null || distinctValueObjectsCollection.isEmpty()) return;

            boolean firstAttributeIsCollection=false;
            if(nextCollectionImplClass!=null)firstAttributeIsCollection=true;
            if(!firstAttributeIsCollection && distinctValueObjectsCollection.size()>1)throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addToValueObjectsTreeWithCollectionRecursive(Context context): next node is a value object but in the value objects collection there is more than one correspondig element" );
            Collection nextCollection = null;
            String[] inverseForeignKeyFields = null;
            Object[] pInstancePkValues = null;

            Object pAttributeName = null;
            pAttributeName = context.get("pAttributeName");
            if(firstAttributeIsCollection) {
                nextCollection =(Collection) propertyUtilsBean.getProperty(pInstance,firstAttributeNameAndRemainingPath[0]);
                if (nextCollection == null){
                    nextCollection = (Collection) ConstructorUtils.invokeConstructor(nextCollectionImplClass,null,null);
                    propertyUtilsBean.setProperty(pInstance,firstAttributeNameAndRemainingPath[0],nextCollection);
                }

                //Object realClass = context.get("realClass");
                context.put("realClass",pInstance.getClass());
                context.put("pAttributeName",firstAttributeNameAndRemainingPath[0]);
                // start added by Alessandro on 04-dec-2008
                Collection inverseForeignKeyFieldsCollection = contextDAO.getInverseForeignKeyFields(context);
                if(inverseForeignKeyFieldsCollection!=null) inverseForeignKeyFields=  (String[])inverseForeignKeyFieldsCollection.toArray(new String[]{});
                // end added by Alessandro on 04-dec-2008
                //inverseForeignKeyFields=(String[]) contextDAO.getInverseForeignKeyFields(context).toArray(new String[]{}); //deleted by Alessandro on 04-dec-2008

                context.put("realClass",realClass);
                context.put("pAttributeName",null);

                pInstancePkValues=getKeyValues(context);

                context.put("pAttributeName",firstAttributeNameAndRemainingPath[0]);

            }
            Iterator distinctValueObjectsCollectionIterator = distinctValueObjectsCollection.iterator();
            while (distinctValueObjectsCollectionIterator.hasNext()){//if pInstance.firstAttributeNameAndRemainingPath[0] is a
                                                                     // value object, surely there will be just one iteration
                                                                     // as distinctValueObjectsCollection.size()=1
                Object distinctValueObjectsCollectionItem = distinctValueObjectsCollectionIterator.next();

                Object[] distinctValueObjectsCollectionItemPkValues = BeanCollectionUtils.getAttributes(distinctValueObjectsCollectionItem,pkNamesToMakeDistinctCollection);
                Object pInstanceChild;
                boolean isNewElement = false; //    added by Alessandro on 04-dec-2008
                if (firstAttributeIsCollection){
                    Collection existingPInstanceChildCollection = Utils.selectWhereFieldsEqualsTo(nextCollection,nextNodePkNames,distinctValueObjectsCollectionItemPkValues);
                    //if (!isInCollection(nextCollection,pInstanceChild,new BeanFieldComparator(nextNodePkNames)))
                    if(existingPInstanceChildCollection==null || existingPInstanceChildCollection.isEmpty()){
                        log.debug("addToValueObjectsTreeWithCollectionRecursive :  not in collection = ");
                        isNewElement = true;   //    added by Alessandro on 04-dec-2008
                        pInstanceChild = ConstructorUtils.invokeConstructor(nextNodeClass,null,null);
                        BeanCollectionUtils.setAttributes(pInstanceChild,nextNodePkNames,distinctValueObjectsCollectionItemPkValues);
                        // start added by Alessandro on 04-dec-2008
                        if (nodePAttributeNames!=null /*nodeValuesArray != null surely*/ ){
                             BeanCollectionUtils.setAttributes(pInstanceChild,nodePAttributeNames[depth.intValue()],nodeValuesArray[depth.intValue()]);
                        }
                        // end added by Alessandro on 04-dec-2008
                        //BeanCollectionUtils.setAttributes(pInstanceChild,nodePAttributeNames[depth.intValue()],nodeValuesArray[depth.intValue()]); //  deleted by Alessandro on 04-dec-2008
                        nextCollection.add(pInstanceChild);

                    }else{
                        log.debug("addToValueObjectsTreeWithCollectionRecursive :   in collection = ");
                        isNewElement = false;//    added by Alessandro on 04-dec-2008
                        pInstanceChild = existingPInstanceChildCollection.iterator().next();// if it exist more than such element in the children of pInstance, just the first one in
                    }                                                                       // the iteration will be considered.

                    if(inverseForeignKeyFields!=null && inverseForeignKeyFields.length!=0)  { // condition  by Alessandro on 04-dec-2008
                        BeanCollectionUtils.setAttributes(pInstanceChild,inverseForeignKeyFields,pInstancePkValues);//Inverse Foreign key fields are set even if pIstanceChild was already existing, preventig the case that the value object
                                                                                              // was existing in the collection, but with the Inverse Foreign key fields not set.
                    }
                }else { // there is the only one iteration
                    Object existingPInstanceChild = propertyUtilsBean.getProperty(pInstance,firstAttributeNameAndRemainingPath[0]);
                    //if (existingPInstanceChild==null){
                    if (existingPInstanceChild==null || (new BeanFieldComparator(nextNodePkNames,existingPInstanceChild.getClass())).compare(existingPInstanceChild,distinctValueObjectsCollectionItemPkValues)!=0){
                        isNewElement = true;   //    added by Alessandro on 04-dec-2008
                        pInstanceChild = ConstructorUtils.invokeConstructor(nextNodeClass,null,null);
                        BeanCollectionUtils.setAttributes(pInstanceChild,nextNodePkNames,distinctValueObjectsCollectionItemPkValues);
                        // start added by Alessandro on 04-dec-2008
                        if (nodePAttributeNames!=null /*nodeValuesArray != null surely*/ ){
                             BeanCollectionUtils.setAttributes(pInstanceChild,nodePAttributeNames[depth.intValue()],nodeValuesArray[depth.intValue()]);
                        }
                        // end added by Alessandro on 04-dec-2008
                        //BeanCollectionUtils.setAttributes(pInstanceChild,nodePAttributeNames[depth.intValue()],nodeValuesArray[depth.intValue()]); //  deleted by Alessandro on 04-dec-2008
                        propertyUtilsBean.setProperty(pInstance,firstAttributeNameAndRemainingPath[0],pInstanceChild);
                    } else {
                        isNewElement = false;//    added by Alessandro on 04-dec-2008
                        pInstanceChild = existingPInstanceChild ;
                    }

                    context.put("pInstance",pInstance);
                    context.put("pAttributeName",firstAttributeNameAndRemainingPath[0]);

                    setForeignKeyFields(context); //Foreign key fields are set even if pIstanceChild was already existing, preventig the case that the value object
                                                                                          // was existing , but not the Foreign key fields.
                }
                Collection forSubTreeValueObjectsCollection = Utils.selectWhereFieldsEqualsTo(valueObjectsCollection,pkNamesToMakeDistinctCollection,distinctValueObjectsCollectionItemPkValues);

                context.put("valueObjectsCollection",forSubTreeValueObjectsCollection);
                context.put("pInstance",pInstanceChild);
                context.put("path",firstAttributeNameAndRemainingPath[1]);
                context.put("depth", new Integer(depth.intValue()+1));
                //start added by Alessandro on 04-dec-2008
                if(isNewElement)    {
                    createValueObjectsTreeWithCollectionRecursive(context);
                }else {
                    addToValueObjectsTreeWithCollectionRecursive(context);
                }
                //end added by Alessandro on 04-dec-2008
                //createValueObjectsTreeWithCollection(context); //deleted by Alessandro on 04-dec-2008

            }

            context.put("pAttributeName",pAttributeName);
            context.put("valueObjectsCollection",valueObjectsCollection);
            context.put("pInstance",pInstance);
            context.put("path",path);
            context.put("depth", depth);

        }catch (ServiceLocatorException e) {
            log.error("ServiceLocatorException caught in BaseContextApplication.addToValueObjectsTreeWithCollectionRecursive(Context context)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addToValueObjectsTreeWithCollectionRecursive(Context context)" + e.toString(),e);
        } catch (DataAccessException e) {
            log.error("DataAccessException caught in BaseContextApplication.addToValueObjectsTreeWithCollectionRecursive(Context context)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addToValueObjectsTreeWithCollectionRecursive( Context context)" + e.toString(),e);
        }catch (NoSuchMethodException e) {
            log.error("NoSuchMethodException caught in BaseContextApplication.addToValueObjectsTreeWithCollectionRecursive(Context context)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addToValueObjectsTreeWithCollectionRecursive(Context context)" + e.toString(),e);
        } catch (IllegalAccessException e) {
            log.error("IllegalAccessException caught in BaseContextApplication.addToValueObjectsTreeWithCollectionRecursive(Context context)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addToValueObjectsTreeWithCollectionRecursive(Context context)" + e.toString(),e);
        }catch (InvocationTargetException e) {
            log.error("InvocationTargetException caught in BaseContextApplication.addToValueObjectsTreeWithCollectionRecursive(Context context)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addToValueObjectsTreeWithCollectionRecursive(Context context)" + e.toString(),e);
        }catch (InstantiationException e) {
            log.error("InstantiationException caught in BaseContextApplication.addToValueObjectsTreeWithCollectionRecursive(Context context)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addToValueObjectsTreeWithCollectionRecursive( Context context)" + e.toString(),e);
        }catch (Exception e) {
            log.error("Exception caught in BaseContextApplication.addToValueObjectsTreeWithCollectionRecursive(Context context)" + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addToValueObjectsTreeWithCollectionRecursive( Context context)" + e.toString(),e);
        }
    }


    public void retrieveAllNullReferencesInCollection(Context context) throws ApplicationServiceException{
        try{

            Collection valueObjectsCollection = (Collection) context.get("valueObjectsCollection");

            if (valueObjectsCollection == null) return;
            ContextDAO contextDAO = getContextDAO(context);
            Iterator iterator = valueObjectsCollection.iterator();

            Object  pInstance = context.get("pInstance");
            while (iterator.hasNext()){
                context.put("pInstance",iterator.next());
                contextDAO.retrieveAllNullReferences(context);
            }
            context.put("pInstance",pInstance);


        }catch (DataAccessException e) {
            log.error("DataAccessException caught in BaseContextApplication.retrieveAllNullReferencesInCollection(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.retrieveAllNullReferencesInCollection(Context context)" + e.toString(),e);
        }catch (Exception e) {
            log.error("Exception caught in BaseContextApplication.retrieveAllNullReferencesInCollection(Collection valueObjectsCollection): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.retrieveAllNullReferencesInCollection(Context context)" + e.toString(),e);
        }
    }



    public Collection  createRelationshipCollection(Context context)throws ApplicationServiceException{
        try{
            ContextDAO contextDAO = getContextDAO(context);
            Class realClass = (Class) context.get("realClass");
            Object[] keyValues = (Object[]) context.get("keyValues");
            String collectionName = (String)context.get("collectionName");
            String pAttributeName = (String)context.get("pAttributeName");
            Collection valueObjectsCollection = (Collection) context.get("valueObjectsCollection");
            String[] pAttributeNames =(String[]) context.get("pAttributeNames");
            Object[] valuesArray =(Object[]) context.get("valuesArray");

            Object path = context.get("path");
            context.put("path",collectionName+"."+pAttributeName);

            Class relatedObjectClass = contextDAO.getClassFromPath(context);
            if (valueObjectsCollection==null) {
                Object templateVO = context.get("templateVO");
                context.put("templateVO",ConstructorUtils.invokeConstructor(relatedObjectClass,null,null));
                valueObjectsCollection = contextDAO.findCollectionByTemplate(context);
                context.put("templateVO",templateVO);
            }


            context.put("path",collectionName);

            Class relationShipClass = contextDAO.getCollectionClassFromPath(context);
            Class relationShipItemClass = contextDAO.getClassFromPath(context);

            context.put("path",path);

            Object oneToN = context.get("oneToN");
            Object mToOne = context.get("mToOne");
            context.put("oneToN",collectionName);
            context.put("mToOne",pAttributeName);

            String[] fksToItemClassInDecomposedRelationship = (String[]) contextDAO.getFksToItemClassInDecomposedRelationship(context).toArray(new String[]{});

            context.put("oneToN",oneToN);
            context.put("mToOne", mToOne);

            context.put("realClass",relatedObjectClass) ;
            context.put("pAttributeName",null) ;

            String[] relatedObjectClassPkNames = getPkNames(context);

            context.put("realClass",realClass) ;


            Collection relationShipCollection = BeanCollectionUtils.createCollectionWithCollectionElements(relationShipClass,valueObjectsCollection,relationShipItemClass,relatedObjectClassPkNames,fksToItemClassInDecomposedRelationship,pAttributeNames,valuesArray);
            BeanCollectionUtils.setAttributes(relationShipCollection, pAttributeName, valueObjectsCollection);

            context.put("pAttributeName",collectionName) ;


            // start added by Alessandro on 06-dec-2008
            String[] inverseForeignKeyFields = null;
            Collection  inverseForeignKeyFieldsCollection = contextDAO.getInverseForeignKeyFields(context);
            if(inverseForeignKeyFieldsCollection!=null && !inverseForeignKeyFieldsCollection.isEmpty()) {
                inverseForeignKeyFields =(String[]) inverseForeignKeyFieldsCollection.toArray(new String[]{});
                BeanCollectionUtils.setAttributes(relationShipCollection,inverseForeignKeyFields, keyValues);
            }
            // end added by Alessandro on 06-dec-2008
            //String[] inverseForeignKeyFields =(String[]) contextDAO.getInverseForeignKeyFields(context).toArray(new String[]{});  //deleted by Alessandro on 06-dec-2008

            context.put("pAttributeName",pAttributeName) ;

            //BeanCollectionUtils.setAttributes(relationShipCollection,inverseForeignKeyFields, keyValues); //deleted by Alessandro on 06-dec-2008

            return relationShipCollection;

        }catch (DataAccessException e) {
            log.error("DataAccessException caught in BaseContextApplication.createRelationshipCollection(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.createRelationshipCollection(Context context)" + e.toString(),e);
        }catch (Exception e) {
            log.error("Exception caught in BaseContextApplication.createRelationshipCollection(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.createRelationshipCollection(Context context)" + e.toString(),e);
        }
    }




    private boolean addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, Collection nodeSourcePAttributeNamesCollection, Collection nodeTargetPAttributeNamesCollection, Collection nodePAttributeNamesCollection, Collection nodeValuesArrayCollection, Context context)throws ApplicationServiceException{
        try{
            if(context!=null){
                //sourceRootVO = context.get("sourceRootVO");
                //targetRootVO = context.get("targetRootVO");
                //sourceTreePath = (String) context.get("sourceTreePath");
                //targetTreePath = (String) context.get("targetTreePath");
                nodeSourcePAttributeNamesCollection = (Collection) context.get("nodeSourcePAttributeNamesCollection");
                nodeTargetPAttributeNamesCollection = (Collection) context.get("nodeTargetPAttributeNamesCollection");
                nodePAttributeNamesCollection = (Collection) context.get("nodePAttributeNamesCollection");
                nodeValuesArrayCollection = (Collection) context.get("nodeValuesArrayCollection");
            }


            if (nodeSourcePAttributeNamesCollection==null) nodeSourcePAttributeNamesCollection = nodeTargetPAttributeNamesCollection;
            if (nodeTargetPAttributeNamesCollection==null) nodeTargetPAttributeNamesCollection = nodeSourcePAttributeNamesCollection;

            String[][] nodeSourcePAttributeNames = null;
            String[][] nodeTargetPAttributeNames = null;
            if (nodeSourcePAttributeNamesCollection!=null){//nodeTargetPAttributeNamesCollection!=null too
                log.debug("nodeSourcePAttributeNamesCollection!=null");
                //nodeSourcePAttributeNames = (String[][]) nodeSourcePAttributeNamesCollection.toArray(new String[]{});// deleted by Alessandro on 14-dec-2008
                //nodeTargetPAttributeNames = (String[][]) nodeTargetPAttributeNamesCollection.toArray(new String[]{}); // deleted by Alessandro on 14-dec-2008
                // start added by Alessandro on 14-dec-2008
                nodeSourcePAttributeNames = new String[nodeSourcePAttributeNamesCollection.size()][];
                Iterator nodeSourcePAttributeNamesCollectionIterator = nodeSourcePAttributeNamesCollection.iterator();
                int k=0;
                while(nodeSourcePAttributeNamesCollectionIterator.hasNext()) {
                    nodeSourcePAttributeNames[k] = (String[])nodeSourcePAttributeNamesCollectionIterator.next();
                    k++;
                }
                nodeTargetPAttributeNames = new String[nodeTargetPAttributeNamesCollection.size()][];
                Iterator nodeTargetPAttributeNamesCollectionIterator = nodeTargetPAttributeNamesCollection.iterator();
                k=0;
                while(nodeTargetPAttributeNamesCollectionIterator.hasNext()) {
                    nodeTargetPAttributeNames[k] = (String[])nodeTargetPAttributeNamesCollectionIterator.next();
                    k++;
                }
                // end added by Alessandro on 14-dec-2008

            }

            String[][] nodePAttributeNames = null;
            //if (nodePAttributeNamesCollection!=null) nodePAttributeNames =  (String[][]) nodePAttributeNamesCollection.toArray(new String[]{});// deleted by Alessandro on 14-dec-2008
            // start added by Alessandro on 14-dec-2008
            if (nodePAttributeNamesCollection!=null) {
                nodePAttributeNames = new String[nodePAttributeNamesCollection.size()][];
                Iterator nodePAttributeNamesCollectionIterator = nodePAttributeNamesCollection.iterator();
                int k=0;
                while(nodePAttributeNamesCollectionIterator.hasNext()) {
                    nodePAttributeNames[k] = (String[])nodePAttributeNamesCollectionIterator.next();
                    k++;
                }
            }
            // end added by Alessandro on 14-dec-2008
            Object[][] nodeValuesArray = null;
            //if (nodeValuesArray!=null) nodeValuesArray = (Object[][]) nodeValuesArrayCollection.toArray(new Object[]{});  // deleted by Alessandro on 14-dec-2008
            // start added by Alessandro on 14-dec-2008
            if (nodeValuesArrayCollection!=null) {
                nodeValuesArray = new Object[nodeValuesArrayCollection.size()][];
                Iterator nodeValuesArrayCollectionIterator = nodeValuesArrayCollection.iterator();
                int k=0;
                while(nodeValuesArrayCollectionIterator.hasNext()) {
                    nodeValuesArray[k] = (Object[])nodeValuesArrayCollectionIterator.next();
                    k++;
                }
            }
            // end added by Alessandro on 14-dec-2008

            Object oldNodeSourcePAttributeNames = context.get("nodeSourcePAttributeNames");
            Object oldNodeTargetPAttributeNames = context.get("nodeTargetPAttributeNames");
            Object oldNodePAttributeNames = context.get("nodePAttributeNames");
            Object oldNodeValuesArray = context.get("nodeValuesArray");
            if(context!=null){
                context.put("nodeSourcePAttributeNames",nodeSourcePAttributeNames);
                context.put("nodeTargetPAttributeNames",nodeTargetPAttributeNames);
                context.put("nodePAttributeNames",nodePAttributeNames);
                context.put("nodeValuesArray",nodeValuesArray);
            }
            boolean added = addTreeToTree( sourceRootVO,  targetRootVO,  sourceTreePath,  targetTreePath, nodeSourcePAttributeNames,  nodeTargetPAttributeNames,  nodePAttributeNames, nodeValuesArray,context);
            if(context!=null){
                context.put("nodeSourcePAttributeNames",oldNodeSourcePAttributeNames);
                context.put("nodeTargetPAttributeNames",oldNodeTargetPAttributeNames);
                context.put("nodePAttributeNames",oldNodePAttributeNames);
                context.put("nodeValuesArray",oldNodeValuesArray);
            }

            return added;
        }catch (Exception e) {
            log.error("Exception caught in BaseContextApplication.addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, Collection nodeSourcePAttributeNamesCollection, Collection nodeTargetPAttributeNamesCollection, Collection nodePAttributeNamesCollection, Collection nodeValuesArrayCollection, Context context): " + e.toString());
            throw new ApplicationServiceException("NoSuchMethodException thrown in BaseContextApplication.addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, Collection nodeSourcePAttributeNamesCollection, Collection nodeTargetPAttributeNamesCollection, Collection nodePAttributeNamesCollection, Collection nodeValuesArrayCollection, Context context)" + e.toString(),e);
        }
    }




    private boolean addTreeToTree( Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, String[][] nodePAttributeNames, Object[][] nodeValuesArray, Context context) throws ApplicationServiceException{
        try{
            ContextDAO contextDAO = getContextDAO(context);
            Object oldContextDao = null;
            Object depth = null;
            if(context!=null){
                oldContextDao = context.get("contextDAO");
                depth = context.get("depth");
                context.put("contextDAO", contextDAO);
                context.put("depth",new Integer(0));

            }
            boolean added = addTreeToTreeRecursive(context);
            if(context!=null){
                context.put("contextDAO",oldContextDao);
                context.put("depth",depth);
            }
            return added;
        }catch (Exception e) {
            log.error("Exception caught in BaseContextApplication.addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, String[][] nodePAttributeNames, Object[][] nodeValuesArray, Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addTreeToTree(Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, String[][] nodePAttributeNames, Object[][] nodeValuesArray, Context context)" + e.toString(),e);
        }
    }



    private boolean  addTreeToTree(Object sourceRootVO, Object targetRootVO,Collection sourceTreePaths,Collection targetTreePaths, Collection treeNodeSourcePAttributeNames, Collection treeNodeTargetPAttributeNames, Collection treeNodePAttributeNames, Collection treeNodeValuesArray, Context context) throws ApplicationServiceException{
        try{
            if(context!=null){
                sourceRootVO = context.get("sourceRootVO");
                targetRootVO = context.get("targetRootVO");
                sourceTreePaths = (Collection) context.get("sourceTreePaths");
                targetTreePaths = (Collection) context.get("targetTreePaths");
                treeNodeSourcePAttributeNames = (Collection) context.get("treeNodeSourcePAttributeNames");
                treeNodeTargetPAttributeNames = (Collection) context.get("treeNodeTargetPAttributeNames");
                treeNodePAttributeNames = (Collection) context.get("treeNodePAttributeNames");
                treeNodeValuesArray = (Collection) context.get("treeNodeValuesArray");
            }


            boolean added = false;
            if (treeNodeSourcePAttributeNames==null) treeNodeSourcePAttributeNames = treeNodeTargetPAttributeNames;
            if (treeNodeTargetPAttributeNames==null) treeNodeTargetPAttributeNames = treeNodeSourcePAttributeNames;


            /* sourceTreePath and targetTreePaths can't be null*/
            if(sourceTreePaths==null || targetTreePaths==null) {
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addTreeToTree(Object sourceRootVO, Object targetRootVO,Collection sourceTreePaths,Collection targetTreePaths, Collection treeNodeSourcePAttributeNames,Collection treeNodeTargetPAttributeNames, Collection treeNodePAttributeNames, Collection treeNodeValuesArray, Context context ) : sourceTreePath and targetTreePaths can't be null" );
            }

            /*if not null sourceTreePath and targetTreePaths must have the same size*/
            if(sourceTreePaths.size()!=targetTreePaths.size()) throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addTreeToTree(Object sourceRootVO, Object targetRootVO,Collection sourceTreePaths,Collection targetTreePaths, Collection treeNodeSourcePAttributeNames,Collection treeNodeTargetPAttributeNames, Collection treeNodePAttributeNames, Collection treeNodeValuesArray, Context context ) :if not null sourceTreePath and targetTreePaths must have the same size" );

            /*if not null treeNodeSourcePAttributeNames and treeNodeTargetPAttributeNames must have the same size*/
            if(treeNodeSourcePAttributeNames!=null /* && treeNodeTargetPAttributeNames!=null*/ && treeNodeSourcePAttributeNames.size()!=treeNodeTargetPAttributeNames.size()){
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addTreeToTree(Object sourceRootVO, Object targetRootVO,Collection sourceTreePaths,Collection targetTreePaths, Collection treeNodeSourcePAttributeNames,Collection treeNodeTargetPAttributeNames, Collection treeNodePAttributeNames, Collection treeNodeValuesArray, Context context ) :if not null treeNodeSourcePAttributeNames and treeNodeTargetPAttributeNames must the same have size" );
            }

            /*if not null treeNodeSourcePAttributeNames and treeNodeTargetPAttributeNames must have  the same size of sourceTreePath and targetTreePaths*/
            if (treeNodeSourcePAttributeNames!=null /* && treeNodeTargetPAttributeNames!=null*/ && treeNodeSourcePAttributeNames.size()!=sourceTreePaths.size()){
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addTreeToTree(Object sourceRootVO, Object targetRootVO,Collection sourceTreePaths,Collection targetTreePaths, Collection treeNodeSourcePAttributeNames,Collection treeNodeTargetPAttributeNames, Collection treeNodePAttributeNames, Collection treeNodeValuesArray, Context context ) :if not null treeNodeSourcePAttributeNames and treeNodeTargetPAttributeNames must have the same size of sourceTreePath and targetTreePaths" );
            }

            /*treeNodePAttributeNames and treeNodeValuesArray must be both null or both not null*/
            if ((treeNodePAttributeNames==null && treeNodeValuesArray!=null )||(treeNodePAttributeNames!=null &&treeNodeValuesArray==null)  ){
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addTreeToTree(Object sourceRootVO, Object targetRootVO,Collection sourceTreePaths,Collection targetTreePaths, Collection treeNodeSourcePAttributeNames,Collection treeNodeTargetPAttributeNames, Collection treeNodePAttributeNames, Collection treeNodeValuesArray, Context context ) :treeNodePAttributeNames and  treeNodeValuesArray must be both null or both not null" );
            }

            /*if not null treeNodePAttributeNames and  treeNodeValuesArray must have  the same size*/
            if (treeNodePAttributeNames!=null /*&& treeNodeValuesArray!=null */ && treeNodePAttributeNames.size()!=treeNodeValuesArray.size()){
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addTreeToTree(Object sourceRootVO, Object targetRootVO,Collection sourceTreePaths,Collection targetTreePaths, Collection treeNodeSourcePAttributeNames,Collection treeNodeTargetPAttributeNames, Collection treeNodePAttributeNames, Collection treeNodeValuesArray, Context context ) : if not null treeNodePAttributeNames and  treeNodeValuesArray must have the same size" );
            }

            /*if not null treeNodePAttributeNames and  treeNodeValuesArray must have the same size of sourceTreePath and targetTreePaths*/
            if (treeNodePAttributeNames!=null /*&& treeNodeValuesArray!=null */ && treeNodePAttributeNames.size()!=sourceTreePaths.size()){
                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addTreeToTree(Object sourceRootVO, Object targetRootVO,Collection sourceTreePaths,Collection targetTreePaths, Collection treeNodeSourcePAttributeNames,Collection treeNodeTargetPAttributeNames, Collection treeNodePAttributeNames, Collection treeNodeValuesArray, Context context ) : if not null treeNodePAttributeNames and  treeNodeValuesArray must have the same size of sourceTreePath and targetTreePaths" );
            }

            Iterator sourceTreePathsIterator = sourceTreePaths.iterator();
            Iterator targetTreesPathsIterator= targetTreePaths.iterator();

            Iterator treeNodeSourcePAttributeNamesIterator = null;
            Iterator treeNodeTargetPAttributeNamesIterator = null;
            if(treeNodeSourcePAttributeNames!=null ){ // treeNodeTargetPAttributeNames!=null too
                treeNodeSourcePAttributeNamesIterator = treeNodeSourcePAttributeNames.iterator();
                treeNodeTargetPAttributeNamesIterator = treeNodeTargetPAttributeNames.iterator();
            }

            Iterator treeNodePAttributeNamesIterator=null;
            Iterator treeNodeValuesArrayIterator=null;
            if(treeNodePAttributeNames!=null){// treeNodeValuesArray!=null too
                treeNodePAttributeNamesIterator = treeNodePAttributeNames.iterator();
                treeNodeValuesArrayIterator =  treeNodeValuesArray.iterator();
            }


            Object oldSourceTreePath = null;
            Object oldTargetTreePath= null;

            Object oldNodeSourcePAttributeNames= null;
            Object oldNodeTargetPAttributeNames= null;
            Object oldNodePAttributeNames= null;
            Object oldNodeValuesArray= null;

            Object oldNodeSourcePAttributeNamesCollection= null;
            Object oldNodeTargetPAttributeNamesCollection= null;
            Object oldNodePAttributeNamesCollection= null;
            Object oldNodeValuesArrayCollection= null;
            /*
            //added by Alessandro on 12-dec-2008
            Object oldNodeSourcePAttributeNamesArray= null;
            Object oldNodeTargetPAttributeNamesArray= null;
            Object oldNodePAttributeNamesArray= null;
            Object oldNodeValuesArrayArray= null;
            //added by Alessandro on 12-dec-2008
            */

            if(context!=null){
                oldSourceTreePath = context.get("sourceTreePath");
                oldTargetTreePath = context.get("targetTreePath");

                oldNodeSourcePAttributeNames = context.get("nodeSourcePAttributeNames");
                oldNodeTargetPAttributeNames = context.get("nodeTargetPAttributeNames");
                oldNodePAttributeNames = context.get("nodePAttributeNames");
                oldNodeValuesArray = context.get("nodeValuesArray");

                oldNodeSourcePAttributeNamesCollection = context.get("nodeSourcePAttributeNamesCollection");
                oldNodeTargetPAttributeNamesCollection = context.get("nodeTargetPAttributeNamesCollection");
                oldNodePAttributeNamesCollection = context.get("nodePAttributeNamesCollection");
                oldNodeValuesArrayCollection = context.get("nodeValuesArrayCollection");
                /*
                //added by Alessandro on 13-dec-2008
                oldNodeSourcePAttributeNamesArray = context.get("nodeSourcePAttributeNamesArray");
                oldNodeTargetPAttributeNamesArray = context.get("nodeTargetPAttributeNamesArray");
                oldNodePAttributeNamesArray = context.get("nodePAttributeNamesArray");
                oldNodeValuesArrayArray = context.get("nodeValuesArrayArray");
                //added by Alessandro on 13-dec-2008
                */

            }
            String sourceTreePath;
            String targetTreePath;
            while (sourceTreePathsIterator.hasNext()){ //targetTreesPathsIterator must have next too.

                sourceTreePath = (String) sourceTreePathsIterator.next();
                targetTreePath = (String) targetTreesPathsIterator.next();


                Object  nodeSourcePAttributeNames = null;
                Object  nodeTargetPAttributeNames = null;

                if (treeNodeSourcePAttributeNamesIterator != null){  //treeNodeTargetPAttributeNamesIterator !=null too and both  must have a next
                    nodeSourcePAttributeNames =  treeNodeSourcePAttributeNamesIterator.next();
                    nodeTargetPAttributeNames =  treeNodeTargetPAttributeNamesIterator.next();
                }

                Object  nodePAttributeNames = null;
                Object nodeValuesArray=null;
                if (treeNodePAttributeNamesIterator!=null){ //treeNodeValuesArrayIterator!=null too and both  must have a next
                    nodePAttributeNames= treeNodePAttributeNamesIterator.next();
                    nodeValuesArray=  treeNodeValuesArrayIterator.next();
                }
                boolean localAdded = false;

                if (nodeSourcePAttributeNames==null) nodeSourcePAttributeNames = nodeTargetPAttributeNames;
                if (nodeTargetPAttributeNames==null) nodeTargetPAttributeNames = nodeSourcePAttributeNames;

                if ((nodePAttributeNames!=null && nodeValuesArray==null) ||(nodePAttributeNames==null && nodeValuesArray!=null)){
                    throw new ApplicationServiceException("BaseContextApplication.addTreeToTree(Object sourceRootVO, Object targetRootVO,Collection sourceTreePaths,Collection targetTreePaths, Collection treeNodeSourcePAttributeNames, Collection treeNodeTargetPAttributeNames, Collection treeNodePAttributeNames, Collection treeNodeValuesArray, Context context ) :  elements of the same position of the two colletions treeNodePAttributeNames and treeNodeValuesArray must be both null or both not null");
                }

                if(context!=null){
                    context.put("sourceTreePath",sourceTreePath);
                    context.put("targetTreePath",targetTreePath);
                }

                if (nodeSourcePAttributeNames!=null){//nodeSourcePAttributeNames!=null && nodeTargetPAttributeNames!=null
                    log.debug("nodeSourcePAttributeNames!=null");
                    log.debug("nodeSourcePAttributeNames.getClass ="+nodeSourcePAttributeNames.getClass());
                    log.debug("nodeTargetPAttributeNames.getClass ="+nodeTargetPAttributeNames.getClass());
                    if (Collection.class.isInstance(nodeSourcePAttributeNames) && Collection.class.isInstance(nodeTargetPAttributeNames)){
                        log.debug("nodeSourcePAttributeNames and nodeTargetPAttributeNames are Collection");
                        Collection nodeSourcePAttributeNamesCollection = (Collection) nodeSourcePAttributeNames;
                        Collection nodeTargetPAttributeNamesCollection = (Collection) nodeTargetPAttributeNames;
                        if(context!=null){
                            context.put("nodeSourcePAttributeNamesCollection",nodeSourcePAttributeNamesCollection);
                            context.put("nodeTargetPAttributeNamesCollection",nodeTargetPAttributeNamesCollection);
                        }
                        if (nodePAttributeNames!=null){//nodeSourcePAttributeNames!=null && nodeTargetPAttributeNames!=null && nodePAttributeNames!=null && nodeValuesArray!=null
                            log.debug("nodePAttributeNames!=null");
                            if (Collection.class.isInstance(nodePAttributeNames) && Collection.class.isInstance(nodeValuesArray)){
                                Collection nodePAttributeNamesCollection = (Collection) nodePAttributeNames;
                                Collection nodeValuesArrayCollection = (Collection) nodeValuesArray;

                                if(context!=null){
                                    context.put("nodePAttributeNamesCollection",nodePAttributeNamesCollection);
                                    context.put("nodeValuesArrayCollection",nodeValuesArrayCollection);
                                }
                                localAdded = addTreeToTree(sourceRootVO,  targetRootVO,sourceTreePath,targetTreePath, nodeSourcePAttributeNamesCollection, nodeTargetPAttributeNamesCollection, nodePAttributeNamesCollection, nodeValuesArrayCollection,context);
                            }else{
                                if(context!=null){
                                    context.put("sourceTreePath",oldSourceTreePath);
                                    context.put("targetTreePath",oldTargetTreePath);

                                    context.put("nodeSourcePAttributeNames",oldNodeSourcePAttributeNames);
                                    context.put("nodeTargetPAttributeNames",oldNodeTargetPAttributeNames);
                                    context.put("nodePAttributeNames",oldNodePAttributeNames);
                                    context.put("nodeValuesArray",oldNodeValuesArray);

                                    context.put("nodeSourcePAttributeNamesCollection",oldNodeSourcePAttributeNamesCollection);
                                    context.put("nodeTargetPAttributeNamesCollection",oldNodeTargetPAttributeNamesCollection);
                                    context.put("nodePAttributeNamesCollection",oldNodePAttributeNamesCollection);
                                    context.put("nodeValuesArrayCollection",oldNodeValuesArrayCollection);
                                    /*
                                    //start added by Alessandro on 13-dec-2008
                                    context.put("nodeSourcePAttributeNamesArray",oldNodeSourcePAttributeNamesArray);
                                    context.put("nodeTargetPAttributeNamesArray",oldNodeTargetPAttributeNamesArray);
                                    context.put("nodePAttributeNamesArray",oldNodePAttributeNamesArray);
                                    context.put("nodeValuesArrayArray",oldNodeValuesArrayArray);
                                    //end added by Alessandro on 13-dec-2008
                                    */
                                }
                                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addTreeToTree(Object sourceRootVO, Object targetRootVO,Collection sourceTreePaths,Collection targetTreePaths, Collection treeNodeSourcePAttributeNames,Collection treeNodeTargetPAttributeNames, Collection treeNodePAttributeNames, Collection treeNodeValuesArray, Context context ) : the not null elements of the same position of the for colletions treeNodeSourcePAttributeNames, treeNodeTargetPAttributeNames, treeNodePAttributeNames and treeNodeValuesArray must be all Collection or all String[][]" );
                            }
                        }else{//nodeSourcePAttributeNames!=null && nodeTargetPAttributeNames!=null && nodePAttributeNames==null && nodeValuesArray!==null
                            if(context!=null){
                                    context.put("nodePAttributeNamesCollection",null);
                                    context.put("nodeValuesArrayCollection",null);
                                }
                            localAdded = addTreeToTree(sourceRootVO,  targetRootVO,sourceTreePath,targetTreePath, nodeSourcePAttributeNamesCollection, nodeTargetPAttributeNamesCollection, null, null,context);
                        }
                    //}else if (String[][].class.isInstance(nodeSourcePAttributeNames) && String[][].class.isInstance(nodeTargetPAttributeNames)){ //  deleted by Alessandro on 12-dec-2008
                    }else if (nodeSourcePAttributeNames.getClass().toString().equals("class [[Ljava.lang.String;") && nodeTargetPAttributeNames.getClass().toString().equals("class [[Ljava.lang.String;")){  //  added by Alessandro on 12-dec-2008
                        log.debug("nodeSourcePAttributeNames and nodeTargetPAttributeNames are String[][]");
                        /*
                        //start added by Alessandro on 13-dec-2008
                        String[][] nodeSourcePAttributeNamesArray = (String[][]) nodeSourcePAttributeNames;
                        String[][] nodeTargetPAttributeNamesArray = (String[][]) nodeTargetPAttributeNames;
                        if(context!=null){
                            context.put("nodeSourcePAttributeNamesArray",nodeSourcePAttributeNamesArray);
                            context.put("nodeTargetPAttributeNamesArray",nodeTargetPAttributeNamesArray);
                        }
                        //end added by Alessandro on 13-dec-2008
                        */

                        if(context!=null){
                            context.put("nodeSourcePAttributeNames",(String[][])nodeSourcePAttributeNames);
                            //context.put("nodeTargetPAttributeNames",(String[][])nodeTargetPAttributeNames); //  deleted by Alessandro on 13-dec-2008
                            context.put("nodeTargetPAttributeNames",(Object[][])nodeTargetPAttributeNames);//added by Alessandro on 13-dec-2008
                        }
                        if (nodePAttributeNames!=null){//nodeSourcePAttributeNames!=null && nodeTargetPAttributeNames!=null && nodePAttributeNames!=null && nodeValuesArray!=null
                            log.debug("nodePAttributeNames!=null");
                            log.debug("nodePAttributeNames.getClass ="+nodePAttributeNames.getClass());
                            log.debug("nodeValuesArray.getClass ="+nodeValuesArray.getClass());
                            log.debug("Object[][].class is"+Object[][].class);
                            //if (String[][].class.isInstance(nodePAttributeNames) && String[][].class.isInstance(nodeValuesArray)){  //  deleted by Alessandro on 12-dec-2008
                            if (nodePAttributeNames.getClass().toString().equals("class [[Ljava.lang.String;") && nodeValuesArray.getClass().toString().equals("class [[Ljava.lang.Object;")){  //  added by Alessandro on 12-dec-2008
                                log.debug("nodePAttributeNames is String[][] and nodeValuesArray is Object[][]");
                                /*
                                //start added by Alessandro on 13-dec-2008
                                String[][] nodePAttributeNamesArray = (String[][]) nodePAttributeNames;
                                Object[][] nodeValuesArrayArray = (Object[][]) nodeValuesArray;
                                if(context!=null){
                                    context.put("nodePAttributeNamesArray",nodePAttributeNamesArray);
                                    context.put("nodeValuesArrayArray",nodeValuesArrayArray);
                                }
                                //end added by Alessandro on 13-dec-2008
                                */

                                if(context!=null){
                                    context.put("nodePAttributeNames",(String[][])nodePAttributeNames);
                                    //context.put("nodeValuesArray",(String[][])nodeValuesArray);    //  deleted  by Alessandro on 13-dec-2008
                                    context.put("nodeValuesArray",(Object[][])nodeValuesArray);    //  added  by Alessandro on 13-dec-2008
                                }

                                //localAdded = addTreeToTree(sourceRootVO,  targetRootVO,sourceTreePath,targetTreePath, (String[][])nodeSourcePAttributeNames, (String[][])nodeTargetPAttributeNames, (String[][])nodePAttributeNames, (String[][])nodeValuesArray,context); //  deleted by Alessandro on 12-dec-2008
                                localAdded = addTreeToTree(sourceRootVO,  targetRootVO,sourceTreePath,targetTreePath, (String[][])nodeSourcePAttributeNames, (String[][])nodeTargetPAttributeNames, (String[][])nodePAttributeNames, (Object[][])nodeValuesArray,context); //  added by Alessandro on 12-dec-2008
                            }else{
                                if(context!=null){
                                    context.put("sourceTreePath",oldSourceTreePath);
                                    context.put("targetTreePath",oldTargetTreePath);

                                    context.put("nodeSourcePAttributeNames",oldNodeSourcePAttributeNames);
                                    context.put("nodeTargetPAttributeNames",oldNodeTargetPAttributeNames);
                                    context.put("nodePAttributeNames",oldNodePAttributeNames);
                                    context.put("nodeValuesArray",oldNodeValuesArray);

                                    context.put("nodeSourcePAttributeNamesCollection",oldNodeSourcePAttributeNamesCollection);
                                    context.put("nodeTargetPAttributeNamesCollection",oldNodeTargetPAttributeNamesCollection);
                                    context.put("nodePAttributeNamesCollection",oldNodePAttributeNamesCollection);
                                    context.put("nodeValuesArrayCollection",oldNodeValuesArrayCollection);
                                    /*
                                    //start added by Alessandro on 13-dec-2008
                                    context.put("nodeSourcePAttributeNamesArray",oldNodeSourcePAttributeNamesArray);
                                    context.put("nodeTargetPAttributeNamesArray",oldNodeTargetPAttributeNamesArray);
                                    context.put("nodePAttributeNamesArray",oldNodePAttributeNamesArray);
                                    context.put("nodeValuesArrayArray",oldNodeValuesArrayArray);
                                    //end added by Alessandro on 13-dec-2008
                                    */
                                }
                                throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addTreeToTree(Object sourceRootVO, Object targetRootVO,Collection sourceTreePaths,Collection targetTreePaths, Collection treeNodeSourcePAttributeNames,Collection treeNodeTargetPAttributeNames, Collection treeNodePAttributeNames, Collection treeNodeValuesArray, Context context ) : the not null elements of the same position of the for colletions treeNodeSourcePAttributeNames, treeNodeTargetPAttributeNames, treeNodePAttributeNames and treeNodeValuesArray must be all Collection or all String[][]" );
                            }
                        }else{//nodeSourcePAttributeNames!=null && nodeTargetPAttributeNames!=null && nodePAttributeNames==null && nodeValuesArray!==null
                            if(context!=null){

                                context.put("nodePAttributeNames",null);
                                context.put("nodeValuesArray",null);
                                /*
                                //start added by Alessandro on 13-dec-2008
                                context.put("nodePAttributeNamesArray",null);
                                context.put("nodeValuesArrayArray",null);
                                //end added by Alessandro on 13-dec-2008
                                */
                            }
                            //localAdded = addTreeToTree(sourceRootVO,  targetRootVO,sourceTreePath,targetTreePath, (String[][])nodeSourcePAttributeNames, (String[][])nodeTargetPAttributeNames, null, null,context);//deleted  by Alessandro on 13-dec-2008
                            localAdded = addTreeToTree(sourceRootVO,  targetRootVO,sourceTreePath,targetTreePath, (String[][])nodeSourcePAttributeNames, (String[][])nodeTargetPAttributeNames, null, null,context); //added  by Alessandro on 13-dec-2008
                        }
                    } else{
                        log.debug("nodeSourcePAttributeNames and nodeTargetPAttributeNames are not both String[][] and no both Collection");
                        if(context!=null){
                            context.put("sourceTreePath",oldSourceTreePath);
                            context.put("targetTreePath",oldTargetTreePath);

                            context.put("nodeSourcePAttributeNames",oldNodeSourcePAttributeNames);
                            context.put("nodeTargetPAttributeNames",oldNodeTargetPAttributeNames);
                            context.put("nodePAttributeNames",oldNodePAttributeNames);
                            context.put("nodeValuesArray",oldNodeValuesArray);

                            context.put("nodeSourcePAttributeNamesCollection",oldNodeSourcePAttributeNamesCollection);
                            context.put("nodeTargetPAttributeNamesCollection",oldNodeTargetPAttributeNamesCollection);
                            context.put("nodePAttributeNamesCollection",oldNodePAttributeNamesCollection);
                            context.put("nodeValuesArrayCollection",oldNodeValuesArrayCollection);
                            /*
                            //start added by Alessandro on 13-dec-2008
                            context.put("nodeSourcePAttributeNamesArray",oldNodeSourcePAttributeNamesArray);
                            context.put("nodeTargetPAttributeNamesArray",oldNodeTargetPAttributeNamesArray);
                            context.put("nodePAttributeNamesArray",oldNodePAttributeNamesArray);
                            context.put("nodeValuesArrayArray",oldNodeValuesArrayArray);
                            //end added by Alessandro on 13-dec-2008
                            */
                        }
                        throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addTreeToTree(Object sourceRootVO, Object targetRootVO,Collection sourceTreePaths,Collection targetTreePaths, Collection treeNodeSourcePAttributeNames,Collection treeNodeTargetPAttributeNames, Collection treeNodePAttributeNames, Collection treeNodeValuesArray, Context context ) : the not null elements of the same position of the for colletions treeNodeSourcePAttributeNames, treeNodeTargetPAttributeNames, treeNodePAttributeNames and treeNodeValuesArray must be all Collection or all String[][]" );
                    }
                }else{//nodeSourcePAttributeNames==null && nodeTargetPAttributeNames==null
                    log.debug("nodeSourcePAttributeNames==null && nodeTargetPAttributeNames==null");

                    context.put("nodeSourcePAttributeNamesCollection",null);
                    context.put("nodeTargetPAttributeNamesCollection",null);
                    /*
                    //start added by Alessandro on 13-dec-2008
                    context.put("nodeSourcePAttributeNamesArray",null);
                    context.put("nodeTargetPAttributeNamesArray",null);
                    //end added by Alessandro on 13-dec-2008
                    */
                    context.put("nodeSourcePAttributeNames",null);
                    context.put("nodeTargetPAttributeNames",null);

                    if (nodePAttributeNames!=null){//nodeSourcePAttributeNames==null && nodeTargetPAttributeNames==null && nodePAttributeNames!=null && nodeValuesArray!=null
                        log.debug("nodePAttributeNames!=null");
                        log.debug("nodePAttributeNames.getClass ="+nodePAttributeNames.getClass());
                        log.debug("nodeValuesArray.getClass ="+nodeValuesArray.getClass());

                        if (Collection.class.isInstance(nodePAttributeNames) && Collection.class.isInstance(nodeValuesArray)){
                            log.debug("nodePAttributeNames  && nodeValuesArray are collection ");
                            Collection nodePAttributeNamesCollection = (Collection) nodePAttributeNames;
                            Collection nodeValuesArrayCollection = (Collection) nodeValuesArray;

                            if(context!=null){
                                context.put("nodePAttributeNamesCollection",nodePAttributeNamesCollection);
                                context.put("nodeValuesArrayCollection",nodeValuesArrayCollection);
                            }
                            localAdded = addTreeToTree(sourceRootVO,  targetRootVO,sourceTreePath,targetTreePath, null, null, nodePAttributeNamesCollection, nodeValuesArrayCollection,context);
                        //}else if (String[][].class.isInstance(nodePAttributeNames) && String[][].class.isInstance(nodeValuesArray)){ //  deleted by Alessandro on 12-dec-2008
                        }else if (nodePAttributeNames.getClass().toString().equals("class [[Ljava.lang.String;") && nodeValuesArray.getClass().toString().equals("class [[Ljava.lang.Object;")){ //  added by Alessandro on 12-dec-2008
                            log.debug("nodePAttributeNames is  String[][] && nodeValuesArray is Object[][]");
                            /*
                            //start added by Alessandro on 13-dec-2008
                            String[][] nodePAttributeNamesArray = (String[][]) nodePAttributeNames;
                            Object[][] nodeValuesArrayArray = (Object[][]) nodeValuesArray;
                            if(context!=null){
                                context.put("nodePAttributeNamesArray",nodePAttributeNamesArray);
                                context.put("nodeValuesArrayArray",nodeValuesArrayArray);
                            }
                            //end  added by Alessandro on 13-dec-2008
                            */

                            if(context!=null){
                                context.put("nodePAttributeNames",(String[][])nodePAttributeNames);
                                //context.put("nodeValuesArray",(String[][])nodeValuesArray);//deleted by Alessandro on 13-dec-2008
                                context.put("nodeValuesArray",(Object[][])nodeValuesArray);//added by Alessandro on 13-dec-2008
                            }
                            //localAdded = addTreeToTree(sourceRootVO,  targetRootVO,sourceTreePath,targetTreePath, null, null, (String[][])nodePAttributeNames, (String[][])nodeValuesArray,context);  //  deleted by Alessandro on 12-dec-2008
                            localAdded = addTreeToTree(sourceRootVO,  targetRootVO,sourceTreePath,targetTreePath, null, null, (String[][])nodePAttributeNames, (Object[][])nodeValuesArray,context); //  added by Alessandro on 12-dec-2008
                        }else{
                            if(context!=null){
                                context.put("sourceTreePath",oldSourceTreePath);
                                context.put("targetTreePath",oldTargetTreePath);

                                context.put("nodeSourcePAttributeNames",oldNodeSourcePAttributeNames);
                                context.put("nodeTargetPAttributeNames",oldNodeTargetPAttributeNames);
                                context.put("nodePAttributeNames",oldNodePAttributeNames);
                                context.put("nodeValuesArray",oldNodeValuesArray);

                                context.put("nodeSourcePAttributeNamesCollection",oldNodeSourcePAttributeNamesCollection);
                                context.put("nodeTargetPAttributeNamesCollection",oldNodeTargetPAttributeNamesCollection);
                                context.put("nodePAttributeNamesCollection",oldNodePAttributeNamesCollection);
                                context.put("nodeValuesArrayCollection",oldNodeValuesArrayCollection);
                                /*
                                //start added by Alessandro on 13-dec-2008
                                context.put("nodeSourcePAttributeNamesArray",oldNodeSourcePAttributeNamesArray);
                                context.put("nodeTargetPAttributeNamesArray",oldNodeTargetPAttributeNamesArray);
                                context.put("nodePAttributeNamesArray",oldNodePAttributeNamesArray);
                                context.put("nodeValuesArrayArray",oldNodeValuesArrayArray);
                                //end added by Alessandro on 13-dec-2008
                                */
                            }
                            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addTreeToTree(Object sourceRootVO, Object targetRootVO,Collection sourceTreePaths,Collection targetTreePaths, Collection treeNodeSourcePAttributeNames,Collection treeNodeTargetPAttributeNames, Collection treeNodePAttributeNames, Collection treeNodeValuesArray, Context context ) : the not null elements of the same position of the for colletions treeNodeSourcePAttributeNames, treeNodeTargetPAttributeNames, treeNodePAttributeNames and treeNodeValuesArray must be all Collection or all String[][]" );
                        }
                    }else{//nodeSourcePAttributeNames==null && nodeTargetPAttributeNames==null && nodePAttributeNames==null && nodeValuesArray!==null
                        if(context!=null){

                            context.put("nodeSourcePAttributeNames",null);
                            context.put("nodeTargetPAttributeNames",null);
                            context.put("nodePAttributeNames",null);
                            context.put("nodeValuesArray",null);

                            context.put("nodeSourcePAttributeNamesCollection",null);
                            context.put("nodeTargetPAttributeNamesCollection",null);
                            context.put("nodePAttributeNamesCollection",null);
                            context.put("nodeValuesArrayCollection",null);
                            /*
                            //start added by Alessandro on 13-dec-2008
                            context.put("nodeSourcePAttributeNamesArray",null);
                            context.put("nodeTargetPAttributeNamesArray",null);
                            context.put("nodePAttributeNamesArray",null);
                            context.put("nodeValuesArrayArray",null);
                            //end added by Alessandro on 13-dec-2008
                            */
                        }
                        //localAdded = addTreeToTree(sourceRootVO,  targetRootVO,sourceTreePath,targetTreePath, (String[][])null, (String[][])null, (String[][])null, (String[][])null,context); //  deleted by Alessandro on 12-dec-2008
                        localAdded = addTreeToTree(sourceRootVO,  targetRootVO,sourceTreePath,targetTreePath, (String[][])null, (String[][])null, (String[][])null, (Object[][])null,context);//  added by Alessandro on 12-dec-2008
                    }
                }

                added=added||localAdded;

            }
            if(context!=null){
                context.put("sourceTreePath",oldSourceTreePath);
                context.put("targetTreePath",oldTargetTreePath);

                context.put("nodeSourcePAttributeNames",oldNodeSourcePAttributeNames);
                context.put("nodeTargetPAttributeNames",oldNodeTargetPAttributeNames);
                context.put("nodePAttributeNames",oldNodePAttributeNames);
                context.put("nodeValuesArray",oldNodeValuesArray);

                context.put("nodeSourcePAttributeNamesCollection",oldNodeSourcePAttributeNamesCollection);
                context.put("nodeTargetPAttributeNamesCollection",oldNodeTargetPAttributeNamesCollection);
                context.put("nodePAttributeNamesCollection",oldNodePAttributeNamesCollection);
                context.put("nodeValuesArrayCollection",oldNodeValuesArrayCollection);
                /*
                //start added by Alessandro on 13-dec-2008
                context.put("nodeSourcePAttributeNamesArray",oldNodeSourcePAttributeNamesArray);
                context.put("nodeTargetPAttributeNamesArray",oldNodeTargetPAttributeNamesArray);
                context.put("nodePAttributeNamesArray",oldNodePAttributeNamesArray);
                context.put("nodeValuesArrayArray",oldNodeValuesArrayArray);
                //end added by Alessandro on 13-dec-2008
                */
            }
            return added;
        }catch (Exception e) {
            log.error("Exception caught in BaseContextApplication.addTreeToTree(Object sourceRootVO, Object targetRootVO,Collection sourceTreePaths,Collection targetTreePaths, Collection treeNodeSourcePAttributeNames,Collection treeNodeTargetPAttributeNames, Collection treeNodePAttributeNames, Collection treeNodeValuesArray, Context context ): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addTreeToTree(Object sourceRootVO, Object targetRootVO,Collection sourceTreePaths,Collection targetTreePaths, Collection treeNodeSourcePAttributeNames,Collection treeNodeTargetPAttributeNames, Collection treeNodePAttributeNames, Collection treeNodeValuesArray, Context context )" + e.toString(),e);
        }
    }



    public boolean addTreeToTree(Context context) throws ApplicationServiceException{
        try{
            Collection  sourceTreePaths = (Collection) context.get("sourceTreePaths") ;
            Collection  targetTreePaths = (Collection) context.get("targetTreePaths") ;
            if(sourceTreePaths !=null && targetTreePaths!=null){
                return addTreeToTree(null, null,sourceTreePaths,targetTreePaths,null, null, null, null, context);// sourceTreePaths and targetTreePaths won't be used but specify which method signature has to be called
            }

            String sourceTreePath = (String) context.get("sourceTreePath");
            String targetTreePath = (String) context.get("targetTreePath");

            if(sourceTreePath !=null && targetTreePath!=null){
                Collection nodeSourcePAttributeNamesCollection = (Collection) context.get("nodeSourcePAttributeNamesCollection");
                Collection nodeTargetPAttributeNamesCollection = (Collection) context.get("nodeTargetPAttributeNamesCollection");
                Collection nodePAttributeNamesCollection = (Collection) context.get("nodePAttributeNamesCollection");
                Collection nodeValuesArrayCollection = (Collection) context.get("nodeValuesArrayCollection");
                if(nodeSourcePAttributeNamesCollection!=null || nodeTargetPAttributeNamesCollection!=null ||(nodePAttributeNamesCollection!=null && nodeValuesArrayCollection!=null)){
                    return addTreeToTree(null, null,sourceTreePath,targetTreePath,nodeSourcePAttributeNamesCollection, nodeTargetPAttributeNamesCollection, nodePAttributeNamesCollection, nodeValuesArrayCollection, context);// sourceTreePaths, targetTreePaths,nodeSourcePAttributeNamesCollection, nodeTargetPAttributeNamesCollection, nodePAttributeNamesCollection, nodeValuesArrayCollection, won't be used but specify which method signature has to be called
                }

                String[][] nodeSourcePAttributeNames = (String[][]) context.get("nodeSourcePAttributeNames");
                String[][] nodeTargetPAttributeNames = (String[][]) context.get("nodeTargetPAttributeNames");
                String[][] nodePAttributeNames = (String[][]) context.get("nodePAttributeNames");
                Object[][] nodeValuesArray = (Object[][]) context.get("nodeValuesArray");
                if(nodeSourcePAttributeNames!=null || nodeTargetPAttributeNames!=null ||(nodePAttributeNames!=null && nodeValuesArray!=null)){
                    return addTreeToTree(null, null,sourceTreePath,targetTreePath,nodeSourcePAttributeNames, nodeTargetPAttributeNames, nodePAttributeNames, nodeValuesArray, context);  // sourceTreePaths ,targetTreePaths,nodeSourcePAttributeNames, nodeTargetPAttributeNames, nodePAttributeNames, nodeValuesArray, won't be used but specify which method signature has to be called
                }
                if(nodePAttributeNamesCollection!=null || nodeValuesArrayCollection!=null || nodePAttributeNames!=null || nodeValuesArray!=null){
                    throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addTreeToTree(Context context): nodePAttributeNamesCollection and nodeValuesArrayCollection must  be both null or both not null, OR , nodePAttributeNames and nodeValuesArray must  be both null or both not null" );
                }
                return addTreeToTree(null, null,sourceTreePath,targetTreePath,nodeSourcePAttributeNames, nodeTargetPAttributeNames, nodePAttributeNames, nodeValuesArray, context);//nodeSourcePAttributeNames, nodeTargetPAttributeNames, nodePAttributeNames, nodeValuesArray are all null
            }
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addTreeToTree(Context context):sourceTreePaths and targetTreePaths must be both not null,  or ,sourceTreePath targetTreePath must be both not null" );


        }catch (Exception e) {
            log.error("Exception caught in BaseContextApplication.addTreeToTree(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addTreeToTree(Context context)" + e.toString(),e);
        }
    }



    /**
     * In the <code>context</code> must be the following keys: </br>
     * <code>"sourceRootVO"</code></br>
     * <code>"targetRootVO"</code></br>
     * <code>"sourceTreePath"</code></br>
     * <code>"targetTreePath"</code></br>
     * <code>"nodeSourcePAttributeNames"</code></br>
     * <code>"nodeTargetPAttributeNames"</code></br>
     * <code>"depth"</code></br>
     * <code>"nodePAttributeNames"</code></br>
     * <code>"nodeValuesArray"</code></br>
     * <code>"contextDao"</code></br>
     * </br>
     *
     *

     * If the first attribute of the dot separated list of attributes <code>sourceTreePath</code>, and the first attribute of the dot separated list of attributes <code>targetTreePath</code>
     * are respectively collections of  <code>sourceRootVO</code> and <code>targetRootVO</code>,  for each element of the collection held by <code>sourceRootVO</code>
     * this method will create a new instance of the class of the elements of the collection held by  <code>targetRootVO</code> (if such collection is not existing will be created an empty one, using the
     * collection implementation class specified in the mapping file for it), and for such created instance its attributes <code>nodeTargetPAttributeNames[depth]</code>
     * will be populated with the attributes <code>nodeSourcePAttributeNames[depth]</code> of the element being processed,  its  attributes <code>nodePAttributeNames[depth]</code>
     * will be populateed with <code>nodeValuesArray[depth]</code>, and its foreign fields to  <code>targetRootVO</code> will be populated with the key values of <code>targetRootVO</code>.</br>
     * The new created instance will be compared with the elements of the collection held by <code>targetRootVO</code> by its key values, and if no matching element is found it will be added to it,
     * and this method will be recursively called, where the new  <code>sourceRootVO</code> and <code>targetRootVO</code> will be the element being processed of the collection held by by <code>sourceRootVO</code> and the
     * new created instance; the new <code>sourceTreePath</code> and <code>targetTreePath</code> will be the same input parameter, but from the second attribute; the new <code>depth</code> will be
     * the same increased by 1, and the remaining parameters are unchanged. If in the comparison between the new created instance and the elements of the collection held by <code>targetRootVO</code> a matching element is found,
     * the method will be recursively called in the same above way, with the difference that the new <code>targetRootVO</code> won't be the created instance, but the found matching element.</br>
     * It will be returned true if the new instance is added or the recursive call returns true, false otherwise.</br>
     * </br>
     * If the first attribute of the dot separated list of attributes <code>sourceTreePath</code> and the first attribute of the dot separated list of attributes <code>targetTreePath</code>
     * are respectively value objects of  <code>sourceRootVO</code> and <code>targetRootVO</code>, if the value object held by <code>sourceRootVO</code> is not null and
     * the value object held by <code>targetRootVO</code> is null, this method will create a new instance of the class of the value object held by <code>targetRootVO</code> ,
     * and for such created instance its attributes <code>nodeTargetPAttributeNames[depth]</code>
     * will be populated with the attributes <code>nodeSourcePAttributeNames[depth]</code> of the value object held by <code>sourceRootVO</code>,  its  attributes <code>nodePAttributeNames[depth]</code>
     * will be populatee with <code>nodeValuesArray[depth]</code>, and this new instance will be used to set the first attribute of the dot separated list of attributes <code>targetTreePath</code>
     * of <code>targetRootVO</code>, and the foreign keys fields of <code>targetRootVO</code> to such value object will be set with the key values of the new instance.</br>
     * If the value object held by <code>sourceRootVO</code> is not null, this method will be recursively called, in the same way described above, but where the new <code>sourceRootVO</code> and <code>targetRootVO</code>
     * will be the two value objects respectively held by them (for the value object held by targetRootVO it could be the new instanced one).</br>
     * It will be returned true if the value object held by <code>targetRootVO</code> has been set with the new instance or if the recursion returns true, false otherwise.
     * </br>
     * The recursion ends when <code>sourceTreePath</code> and  <code>targetTreePath</code> are empty strings.</br>
     * </br>
     * If <code>nodeSourcePAttributeNames</code> and  <code>nodeTargetPAttributeNames</code> are both null, the relative operations are not performed; if just one of them is null, it will assume the value of the other one.
     * For example if <code>nodeSourcePAttributeNames</code> is null and <code>nodeTargetPAttributeNames</code> is not null, <code>nodeSourcePAttributeNames</code> will have the value of <code>nodeTargetPAttributeNames</code> (and viceversa).</br>
     * If <code>nodeSourcePAttributeNames</code> and  <code>nodeTargetPAttributeNames</code> are not null, for each <code>depth</code>
     * if <code>nodeSourcePAttributeNames[depth]</code> and  <code>nodeTargetPAttributeNames[depth]</code> are both null, the relative operations are not performed; if just one of them is null, it will assume the value of the other one.
     * If <code>nodePAttributeNames</code> and  <code>nodeValuesArray</code> are both null, the relative operations are not performed; if they are not null for each <code>depth</code>
     * if <code>nodePAttributeNames[depth]</code> and  <code>nodeValuesArray[depth]</code> are both null, the relative operations are not performed;
     * </br>
     *
     * Resuming the values of the specified keys have the following use:</br>
     *
     * <code>sourceRootVO</code>  Root of the source tree. It can't be null.
     * <code>targetRootVO</code>  Root of the target tree. It can't be null.
     * <code>sourceTreePath</code>  dot separated list of attributes defining the source tree. It can't be null.
     * <code>targetTreePath</code>  dot separated list of attributes defining the target tree. It can't be null.
     * <code>nodeSourcePAttributeNames</code>     <code>nodeSourcePAttributeNames[depth]</code> are the attributes names of the children of <code>sourceRootVO</code> used to populate
     *              the <code>nodeTargetPAttributeNames[depth]</code> attributes of the relative instances to add to the children of <code>targetRootVO</code>.
     * <code>nodeTargetPAttributeNames</code>   <code>nodeTargetPAttributeNames[depth]</code> are the attributes names of the created instances to add to the children <code>targetRootVO</code>
     *              to be populated with attributes <code>nodeSourcePAttributeNames[depth]</code> of the children of <code>sourceRootVO</code>.
     * <code>depth</code>  depth of the tree being processed
     * <code>nodePAttributeNames</code>  <code>nodePAttributeNames[depth]</code> are the attributes of the created instance to add to the target tree, to be populated with <code>nodeValuesArray[depth]</code>.
     * <code>nodeValuesArray </code> <code>nodeValuesArray[depth]</code> are used to populate the attributes <code>nodePAttributeNames[depth]</code> of the created instances.
     * <code>contextDAO</code>  ContextDAO instance to access the media store
     * @param context if not null must hold the input parameters.</br>
     * @return true is something is added to the tree rapresented by the two input parameter <code>targetRootVO</code> and <code>targetTreePath</code>, false otherwise.
     * @throws it.aco.mandragora.exception.ApplicationServiceException  -
     *      If  <code>sourceRootVO</code> or <code>targetRootVO</code> or <code>sourceTreePath</code> or <code>targetTreePath</code> are null.</br>
     *      If  <code>sourceTreePath</code> and <code>targetTreePath</code> are not both empty strings or not both not empty strings.</br>
     *      If  <code>nodeSourcePAttributeNames</code> and  <code>nodeTargetPAttributeNames</code> are not null, and don't have the same length.</br>
     *      If  <code>nodeSourcePAttributeNames</code> and  <code>nodeTargetPAttributeNames</code> are not null, and <code>nodeSourcePAttributeNames[depth]</code> and <code>nodeTargetPAttributeNames[depth]</code> are not null but don't have the same length.</br>
     *      If  <code>nodePAttributeNames</code> and  <code>nodeValuesArray</code> are not both null or both both not null.</br>
     *      If  <code>nodePAttributeNames</code> and <code>nodeValuesArray</code> are not null, and don't have the same length.</br>
     *      If  <code>nodePAttributeNames</code> and  <code>nodeValuesArray</code> are not null, and <code>nodePAttributeNames[depth]</code> and <code>nodeValuesArray[depth]</code> are not null but don't have the same length.</br>
     *      If  <code>nodePAttributeNames</code>,   <code>nodeValuesArray</code>,  <code>nodeSourcePAttributeNames</code> and  <code>nodeTargetPAttributeNames</code> are not null, and don't have all the same length.</br>
     *      If the first attribute of the dot separated list of attributes <code>sourceTreePath</code>, and the first attribute of the dot separated list of attributes <code>targetTreePath</code> are not both collection or both value objects.</br>
     */
    private boolean addTreeToTreeRecursive(Context context)throws ApplicationServiceException{
        try{

            Object sourceRootVO = context.get("sourceRootVO");
            Object targetRootVO = context.get("targetRootVO");
            String sourceTreePath = (String) context.get("sourceTreePath");
            String targetTreePath = (String) context.get("targetTreePath");
            String[][] nodeSourcePAttributeNames = (String[][]) context.get("nodeSourcePAttributeNames");
            String[][] nodeTargetPAttributeNames = (String[][]) context.get("nodeTargetPAttributeNames");
            Integer depth = (Integer) context.get("depth");
            String[][] nodePAttributeNames = (String[][]) context.get("nodePAttributeNames");
            Object[][] nodeValuesArray = (Object[][]) context.get("nodeValuesArray");
            ContextDAO contextDAO = (ContextDAO) context.get("contextDAO");


            log.debug("addTreeToTreeRecursive(Context context) : sourceRootVO = "+sourceRootVO);
            log.debug("addTreeToTreeRecursive(Context context) : targetRootVO = "+targetRootVO);
            log.debug("addTreeToTreeRecursive(Context context) : sourceTreePath = "+sourceTreePath);
            log.debug("addTreeToTreeRecursive(Context context) : targetTreePath = "+targetTreePath);
            log.debug("addTreeToTreeRecursive(Context context) : depth = "+depth);

            if(sourceTreePath.equals("")&&targetTreePath.equals("")) return false;

            boolean added = false;

            if (nodeSourcePAttributeNames==null) {
                log.debug("nodeSourcePAttributeNames == null");
                nodeSourcePAttributeNames = nodeTargetPAttributeNames;
                context.put("nodeSourcePAttributeNames",nodeTargetPAttributeNames);
            }
            if (nodeTargetPAttributeNames==null) {
                log.debug("nodeTargetPAttributeNames == null");
                nodeTargetPAttributeNames = nodeSourcePAttributeNames;
                context.put("nodeTargetPAttributeNames",nodeSourcePAttributeNames);
            }
            log.debug("nodeSourcePAttributeNames is  : "+nodeSourcePAttributeNames);
            log.debug("nodeTargetPAttributeNames is  : "+nodeTargetPAttributeNames);

            /**************************** begin parameters integrity control**************************************************************/
            /* sourceRootVO, targetRootVO, sourceTreePath, targetTreePath can't be null */
            if (sourceRootVO==null || targetRootVO==null ||sourceTreePath==null || targetTreePath==null ){
                throw new ApplicationServiceException("BaseContextApplication.addTreeToTreeRecursive(Context context): sourceRootVO, targetRootVO, sourceTreePath, targetTreePath can't be null ");
            }

            /*sourceTree and targetTree must be both empty or both not empty*/
            if((!sourceTreePath.equals("")&&targetTreePath.equals(""))||(sourceTreePath.equals("")&&!targetTreePath.equals(""))){
                throw new ApplicationServiceException("BaseContextApplication.addTreeToTreeRecursive(Context context):  sourceTreePath and targetTreePath must be both empty or both not empty");
            }

            /*if nodeSourcePAttributeNames and  nodeTargetPAttributeNames are not null, must have the same length*/
            if (nodeSourcePAttributeNames!=null /*&& nodeTargetPAttributeNames!=null*/ && nodeSourcePAttributeNames.length != nodeTargetPAttributeNames.length){
                throw new ApplicationServiceException("BaseContextApplication.addTreeToTreeRecursive(Context context): if nodeSourcePAttributeNames and  nodeTargetPAttributeNames are not null, must have the same length");
            }

            /*if nodeSourcePAttributeNames and  nodeTargetPAttributeNames are not null, and nodeSourcePAttributeNames[depth] and nodeTargetPAttributeNames[depth] are not null must have the same length");*/
            if (nodeSourcePAttributeNames!=null /*&& nodeTargetPAttributeNames!=null*/ && nodeSourcePAttributeNames[depth.intValue()]!=null && nodeTargetPAttributeNames[depth.intValue()]!=null && nodeSourcePAttributeNames[depth.intValue()].length!=nodeTargetPAttributeNames[depth.intValue()].length){
                throw new ApplicationServiceException("BaseContextApplication.addTreeToTreeRecursive(Context context): if nodeSourcePAttributeNames and  nodeTargetPAttributeNames are not null, and nodeSourcePAttributeNames["+depth.intValue()+"] and nodeTargetPAttributeNames["+depth.intValue()+"] are not null must have the same length");
            }

            /*nodePAttributeNames and nodeValuesArray must be both null or both not null*/
            if ((nodePAttributeNames!=null && nodeValuesArray==null) ||(nodePAttributeNames==null && nodeValuesArray!=null)){
                throw new ApplicationServiceException("BaseContextApplication.addTreeToTreeRecursive(Context context):  nodePAttributeNames and nodeValuesArray must be both null or both not null");
            }

            /*if nodePAttributeNames and nodeValuesArray are not null, they must have the same length */
            if (nodePAttributeNames!=null /*&& nodeValuesArray!=null*/ && nodePAttributeNames.length != nodeValuesArray.length){
                throw new ApplicationServiceException("BaseContextApplication.addTreeToTreeRecursive(Context context): if nodePAttributeNames and nodeValuesArray are not null, they must have the same length");
            }

            /* if nodePAttributeNames,  nodeValuesArray, nodeSourcePAttributeNames and nodeTargetPAttributeNames are not null, the must have all the same length*/
            if (nodePAttributeNames!=null /*&& nodeValuesArray!=null*/ && nodeSourcePAttributeNames!=null /*&& nodeTargetPAttributeNames!=null*/ && nodePAttributeNames.length!=nodeSourcePAttributeNames.length){
                throw new ApplicationServiceException("BaseContextApplication.addTreeToTreeRecursive(Context context): if nodePAttributeNames,  nodeValuesArray, nodeSourcePAttributeNames and nodeTargetPAttributeNames are not null, the must have all the same length");
            }


            /**************************** end parameters integrity control**************************************************************/


            //DAO dao = ServiceLocator.getInstance().getContextDAO(DAOFactoryClass,DAOClass);
            PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();

            String[] sourceTreeFirstAttributeNameAndRemainingPath =  Utils.getFirstAttributeNameAndRemainingPath(sourceTreePath);
            String[] targetTreeFirstAttributeNameAndRemainingPath =  Utils.getFirstAttributeNameAndRemainingPath(targetTreePath);


            Class sourceCollectionClass;
            Class targetCollectionClass;
            Class targetCollectionElementClass;


            Object realClass = context.get("realClass");
            Object path = context.get("path");
            context.put("realClass",sourceRootVO.getClass());
            context.put("path",sourceTreeFirstAttributeNameAndRemainingPath[0]);

            sourceCollectionClass = contextDAO.getCollectionClassFromPath(context);

            context.put("realClass",targetRootVO.getClass());
            context.put("path",targetTreeFirstAttributeNameAndRemainingPath[0]);

            targetCollectionClass = contextDAO.getCollectionClassFromPath(context);
            targetCollectionElementClass= contextDAO.getClassFromPath(context);

            context.put("realClass",realClass);
            context.put("path",path);






            /*sourceRootVO and targetRootVO must have first attribute both as collection or both valueobject*/
            if ((sourceCollectionClass == null && targetCollectionClass!=null)||(sourceCollectionClass != null && targetCollectionClass==null)){
                log.debug("addTreeToTreeRecursive(Context context) : sourceCollectionClass = "+sourceCollectionClass);
                log.debug("addTreeToTreeRecursive(Context context) : targetCollectionClass = "+targetCollectionClass);
                throw new ApplicationServiceException("BaseContextApplication.addTreeToTreeRecursive(Context context): sourceRootVO and targetRootVO must have first attribute both as collection or both valueobject");
            }




            Object pAttributeName = null ;
            Object pInstance = null;

            realClass = context.get("realClass");
            pAttributeName = context.get("pAttributeName");
            pInstance = context.get("pInstance");

            if (sourceCollectionClass != null){// targetCollectionClass!= null too
                                               // sourceRootVO.firstAttributeNameSourceTree and targetRootVO.firstAttributeNameTargetTree are collection
                log.debug("addTreeToTreeRecursive(Context context): sourceRootVO.firstAttribute  and targetRootVO.firstAttribute are collection");
                Collection sourceCollection=(Collection) propertyUtilsBean.getProperty(sourceRootVO,sourceTreeFirstAttributeNameAndRemainingPath[0]);

                //String[] inverseForeignKeyFields; deleted on 12-dec-2008


                /* deleted by Alessandro  on 13-dec-2008
                context.put("realClass",sourceRootVO.getClass());
                context.put("pAttributeName",sourceTreeFirstAttributeNameAndRemainingPath[0]);
                context.put("pInstance",sourceRootVO);
                */
                //start added      by Alessandro  on 13-dec-2008
                context.put("realClass",targetRootVO.getClass());
                context.put("pAttributeName",targetTreeFirstAttributeNameAndRemainingPath[0]);
                context.put("pInstance",targetRootVO);
                //end added      by Alessandro  on 13-dec-2008

                // start added by Alessandro on 12-dec-2008
                String[] inverseForeignKeyFields = null;
                Collection  inverseForeignKeyFieldsCollection = contextDAO.getInverseForeignKeyFields(context);
                if(inverseForeignKeyFieldsCollection!=null && !inverseForeignKeyFieldsCollection.isEmpty()) {
                    inverseForeignKeyFields =(String[]) inverseForeignKeyFieldsCollection.toArray(new String[]{});
                }
                // end added by Alessandro on 12-dec-2008

                //inverseForeignKeyFields =(String[])  contextDAO.getInverseForeignKeyFields(context).toArray(new String[]{}); deleted on 12-dec-2008
                //context.put("realClass",realClass);
                context.put("pAttributeName",null);


                //Object[] sourceRootVOKeyValues = getKeyValues(context);  //deleted by Alessandro  on 13-dec-2008
                Object[] targetRootVOKeyValues = getKeyValues(context); //added by Alessandro  on 13-dec-2008


                if (sourceCollection!=null){


                    //context.put("pInstance",targetRootVO); deleted by Alessandro  on 13-dec-2008
                    context.put("pAttributeName",targetTreeFirstAttributeNameAndRemainingPath[0]);

                    Collection targetCollection = getReferenceCollectionOrEmptyIfNull(context ); // I don't mind which is the collectionImplClass

                    Object valueObjectsCollection = null;
                    Object pAttributeNames = null;

                    valueObjectsCollection = context.get("valueObjectsCollection");
                    pAttributeNames = context.get("pAttributeNames");


                    Iterator sourceCollectionIterator =  sourceCollection.iterator();
                    while (sourceCollectionIterator.hasNext()){
                        Object sourceCollectionElement = sourceCollectionIterator.next();
                        Object targetCollectionElement = targetCollectionElementClass.newInstance();
                        /*deleted by Alessandro on 14-dec-2008
                        BeanCollectionUtils.setAttributes(sourceCollectionElement,nodeSourcePAttributeNames[depth.intValue()],targetCollectionElement,nodeTargetPAttributeNames[depth.intValue()]);
                        BeanCollectionUtils.setAttributes(targetCollectionElement,nodePAttributeNames[depth.intValue()],nodeValuesArray[depth.intValue()]);
                        */
                        //   start added by Alessandro on 13-dec-2008
                        if(nodeSourcePAttributeNames!=null){  // surely  nodeTargetPAttributeNames!=null too
                            log.debug("setting nodeTargetPAttributeNames["+depth+"] with nodeSourcePAttributeNames["+depth+"]");
                            BeanCollectionUtils.setAttributes(sourceCollectionElement,nodeSourcePAttributeNames[depth.intValue()],targetCollectionElement,nodeTargetPAttributeNames[depth.intValue()]);
                        }
                        if(nodePAttributeNames!=null){   // surely  nodeValuesArray!=null too
                            log.debug("setting nodePAttributeNames["+depth+"] with nodeValuesArray["+depth+"]");
                            BeanCollectionUtils.setAttributes(targetCollectionElement,nodePAttributeNames[depth.intValue()],nodeValuesArray[depth.intValue()]);
                        }
                        //   end added by Alessandro on 13-dec-2008
                        //BeanCollectionUtils.setAttributes(targetCollectionElement,inverseForeignKeyFields,sourceRootVOKeyValues);  //deleted by Alessandro on 12-dec-2008
                        //if(inverseForeignKeyFields!=null)BeanCollectionUtils.setAttributes(targetCollectionElement,inverseForeignKeyFields,sourceRootVOKeyValues);//added by Alessandro on 12-dec-2008 deleted   13-dec-2008
                        if(inverseForeignKeyFields!=null)BeanCollectionUtils.setAttributes(targetCollectionElement,inverseForeignKeyFields,targetRootVOKeyValues);//added by Alessandro on 13-dec-2008

                        log.debug("addTreeToTreeRecursive(Context context):sourceCollectionElement : "+sourceCollectionElement);
                        log.debug("addTreeToTreeRecursive(Context context):targetFormatSourceCollectionElement : "+targetCollectionElement);
                        boolean localAdded;

                        context.put("pInstance",targetCollectionElement) ;
                        context.put("valueObjectsCollection",targetCollection);
                        context.put("pAttributeNames",null);

                        context.put("sourceRootVO",sourceCollectionElement);
                        context.put("sourceTreePath",sourceTreeFirstAttributeNameAndRemainingPath[1]);
                        context.put("targetTreePath",targetTreeFirstAttributeNameAndRemainingPath[1]);
                        context.put("depth",new Integer(depth.intValue()+1));

                        localAdded=addToCollection(context);

                        //if (addToCollection(targetCollection,targetCollectionElement,null)){
                        // Object sourceRootVO, Object targetRootVO, String sourceTreePath, String targetTreePath, String[][] nodeSourcePAttributeNames, String[][]  nodeTargetPAttributeNames, Integer depth, String[][] nodePAttributeNames, Object[][] nodeValuesArray, DAO dao, Context context
                        if (localAdded){
                            context.put("targetRootVO",targetCollectionElement);

                            added = true;
                            addTreeToTreeRecursive(context);
                        }else{
                            String[] targetCollectionElementPkNames;
                            Object[] targetCollectionElementKeyValues;

                            context.put("realClass",targetCollectionElementClass);
                            targetCollectionElementPkNames= contextDAO.getPkNames(context);
                            targetCollectionElementKeyValues = contextDAO.getKeyValues(context);

                            Object newTargetRootVO = Utils.selectWhereFieldsEqualsTo((Collection) propertyUtilsBean.getProperty(targetRootVO,targetTreeFirstAttributeNameAndRemainingPath[0]),targetCollectionElementPkNames,targetCollectionElementKeyValues).iterator().next();
                            context.put("targetRootVO",newTargetRootVO);

                            //added = addTreeToTreeRecursive(context);  // deleted by Alessandro on 14-dec-2008
                            added = addTreeToTreeRecursive(context)||added; // added by Alessandro on 14-dec-2008
                        }
                    }
                    context.put("valueObjectsCollection",valueObjectsCollection);
                    context.put("pAttributeNames",pAttributeNames);
                }
            }else{ //sourceRootVO.firstAttributeNameSourceTree and targetRootVO.firstAttributeNameTargetTree are NOT collection
                log.debug("addTreeToTreeRecursive( Context context): sourceRootVO.firstAttributeNameSourceTree and targetRootVO.firstAttributeNameTargetTree are NOT collection");

                Object sourceCollectionElement = propertyUtilsBean.getProperty(sourceRootVO,sourceTreeFirstAttributeNameAndRemainingPath[0]);
                if(sourceCollectionElement!=null){

                    Object targetCollectionElement = propertyUtilsBean.getProperty(targetRootVO,targetTreeFirstAttributeNameAndRemainingPath[0]);
                    if (targetCollectionElement==null){
                        log.debug("targetCollectionElement == null");
                        targetCollectionElement = targetCollectionElementClass.newInstance();
                        propertyUtilsBean.setProperty(targetRootVO,targetTreeFirstAttributeNameAndRemainingPath[0],targetCollectionElement);
                        //   start added by Alessandro on 13-dec-2008
                        if(nodeSourcePAttributeNames!=null){  // surely  nodeTargetPAttributeNames!=null too
                            BeanCollectionUtils.setAttributes(sourceCollectionElement,nodeSourcePAttributeNames[depth.intValue()],targetCollectionElement,nodeTargetPAttributeNames[depth.intValue()]);
                        }
                        if(nodePAttributeNames!=null){   // surely  nodeValuesArray!=null too
                            BeanCollectionUtils.setAttributes(targetCollectionElement,nodePAttributeNames[depth.intValue()],nodeValuesArray[depth.intValue()]);
                        }
                        //   end added by Alessandro on 13-dec-2008
                        /* deleted by Alessandro on 13-dec-2008
                        BeanCollectionUtils.setAttributes(sourceCollectionElement,nodeSourcePAttributeNames[depth.intValue()],targetCollectionElement,nodeTargetPAttributeNames[depth.intValue()]);
                        BeanCollectionUtils.setAttributes(targetCollectionElement,nodePAttributeNames[depth.intValue()],nodeValuesArray[depth.intValue()]);
                        */
                        context.put("pInstance",targetRootVO);
                        context.put("pAttributeName",targetTreeFirstAttributeNameAndRemainingPath[0]);

                        setForeignKeyFields(context);
                        added=true;
                    }


                    context.put("sourceRootVO",sourceCollectionElement);
                    context.put("targetRootVO",targetCollectionElement);
                    context.put("sourceTreePath",sourceTreeFirstAttributeNameAndRemainingPath[1]);
                    context.put("targetTreePath",targetTreeFirstAttributeNameAndRemainingPath[1]);
                    context.put("depth",new Integer(depth.intValue()+1));

                    //added = added || addTreeToTreeRecursive(context);   // deleted by alessandro colantoni on 13-dec-2008
                    added = addTreeToTreeRecursive(context) || added;  // added by alessandro colantoni on 13-dec-2008
                }
            }

            context.put("realClass",realClass);
            context.put("pAttributeName",pAttributeName);
            context.put("pInstance",pInstance);

            context.put("sourceRootVO",sourceRootVO);
            context.put("targetRootVO",targetRootVO);
            context.put("sourceTreePath",sourceTreePath);
            context.put("targetTreePath",targetTreePath);
            context.put("depth",depth);


            return added;
        } catch (ServiceLocatorException e) {
            log.error("ServiceLocatorException caught in BaseContextApplication.addTreeToTreeRecursive( Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addTreeToTreeRecursive(Context context)" + e.toString(),e);
        }catch (DataAccessException e) {
            log.error("DataAccessrException caught in BaseContextApplication.addTreeToTreeRecursive(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addTreeToTreeRecursive(Context context)" + e.toString(),e);
        } catch (IllegalAccessException e) {
            log.error("IllegalAccessException caught in BaseContextApplication.addTreeToTreeRecursive(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addTreeToTreeRecursive(Context context)" + e.toString(),e);
        }catch (InvocationTargetException e) {
            log.error("InvocationTargetException caught in BaseContextApplication.addTreeToTreeRecursive(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addTreeToTreeRecursive(Context context)" + e.toString(),e);
        }catch (NoSuchMethodException e) {
            log.error("NoSuchMethodException caught in BaseContextApplication.addTreeToTreeRecursive(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addTreeToTreeRecursive(Context context)" + e.toString(),e);
        }catch (InstantiationException e) {
            log.error("InstantiationException caught in BaseContextApplication.addTreeToTreeRecursive(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addTreeToTreeRecursive(Context context)" + e.toString(),e);
        } catch (Exception e) {
            log.error("Exception caught in BaseContextApplication.addTreeToTreeRecursive(Context context): " + e.toString());
            throw new ApplicationServiceException("ApplicationServiceException thrown in BaseContextApplication.addTreeToTreeRecursive(Context context)" + e.toString(),e);
        }
    }






}