
/* ====================================================================
 *		      GNU GENERAL PUBLIC LICENSE
 *		         Version 2, June 1991
 *
 *    Copyright (C) 1989, 1991 Free Software Foundation, Inc.
 *                        51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *    Everyone is permitted to copy and distribute verbatim copies
 *  of this license document, but changing it is not allowed.
 *
 *  			    Preamble
 *
 *    The licenses for most software are designed to take away your
 *  freedom to share and change it.  By contrast, the GNU General Public
 *  License is intended to guarantee your freedom to share and change free
 *  software--to make sure the software is free for all its users.  This
 *  General Public License applies to most of the Free Software
 *  Foundation's software and to any other program whose authors commit to
 *  using it.  (Some other Free Software Foundation software is covered by
 *  the GNU Library General Public License instead.)  You can apply it to
 *  your programs, too.
 *
 *    When we speak of free software, we are referring to freedom, not
 *  price.  Our General Public Licenses are designed to make sure that you
 *  have the freedom to distribute copies of free software (and charge for
 *  this service if you wish), that you receive source code or can get it
 *  if you want it, that you can change the software or use pieces of it
 *  in new free programs; and that you know you can do these things.
 *
 *     To protect your rights, we need to make restrictions that forbid
 *  anyone to deny you these rights or to ask you to surrender the rights.
 *  These restrictions translate to certain responsibilities for you if you
 *  distribute copies of the software, or if you modify it.
 *
 *     For example, if you distribute copies of such a program, whether
 *  gratis or for a fee, you must give the recipients all the rights that
 *  you have.  You must make sure that they, too, receive or can get the
 *  source code.  And you must show them these terms so they know their
 *  rights.
 *
 *     We protect your rights with two steps: (1) copyright the software, and
 *  (2) offer you this license which gives you legal permission to copy,
 *  distribute and/or modify the software.
 *
 *     Also, for each author's protection and ours, we want to make certain
 *  that everyone understands that there is no warranty for this free
 *  software.  If the software is modified by someone else and passed on, we
 *  want its recipients to know that what they have is not the original, so
 *  that any problems introduced by others will not reflect on the original
 *  authors' reputations.
 *
 *     Finally, any free program is threatened constantly by software
 *  patents.  We wish to avoid the danger that redistributors of a free
 *  program will individually obtain patent licenses, in effect making the
 *  program proprietary.  To prevent this, we have made it clear that any
 *  patent must be licensed for everyone's free use or not licensed at all.
 *
 *     The precise terms and conditions for copying, distribution and
 *  modification follow.
 *
 *	                	    GNU GENERAL PUBLIC LICENSE
 *       TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
 *
 *     0. This License applies to any program or other work which contains
 *  a notice placed by the copyright holder saying it may be distributed
 *  under the terms of this General Public License.  The "Program", below,
 *  refers to any such program or work, and a "work based on the Program"
 *  means either the Program or any derivative work under copyright law:
 *  that is to say, a work containing the Program or a portion of it,
 *  either verbatim or with modifications and/or translated into another
 *  language.  (Hereinafter, translation is included without limitation in
 *  the term "modification".)  Each licensee is addressed as "you".
 *
 *     Activities other than copying, distribution and modification are not
 *  covered by this License; they are outside its scope.  The act of
 *  running the Program is not restricted, and the output from the Program
 *  is covered only if its contents constitute a work based on the
 *  Program (independent of having been made by running the Program).
 *  Whether that is true depends on what the Program does.
 *
 *     1. You may copy and distribute verbatim copies of the Program's
 *  source code as you receive it, in any medium, provided that you
 *  conspicuously and appropriately publish on each copy an appropriate
 *  copyright notice and disclaimer of warranty; keep intact all the
 *  notices that refer to this License and to the absence of any warranty;
 *  and give any other recipients of the Program a copy of this License
 *  along with the Program.
 *
 *  You may charge a fee for the physical act of transferring a copy, and
 *  you may at your option offer warranty protection in exchange for a fee.
 *
 *     2. You may modify your copy or copies of the Program or any portion
 *  of it, thus forming a work based on the Program, and copy and
 *  distribute such modifications or work under the terms of Section 1
 *  above, provided that you also meet all of these conditions:
 *
 *        a) You must cause the modified files to carry prominent notices
 *     stating that you changed the files and the date of any change.
 *
 *        b) You must cause any work that you distribute or publish, that in
 *     whole or in part contains or is derived from the Program or any
 *     part thereof, to be licensed as a whole at no charge to all third
 *     parties under the terms of this License.
 *
 *        c) If the modified program normally reads commands interactively
 *     when run, you must cause it, when started running for such
 *     interactive use in the most ordinary way, to print or display an
 *     announcement including an appropriate copyright notice and a
 *     notice that there is no warranty (or else, saying that you provide
 *     a warranty) and that users may redistribute the program under
 *     these conditions, and telling the user how to view a copy of this
 *     License.  (Exception: if the Program itself is interactive but
 *     does not normally print such an announcement, your work based on
 *     the Program is not required to print an announcement.)
 *
 *     These requirements apply to the modified work as a whole.  If
 *  identifiable sections of that work are not derived from the Program,
 *  and can be reasonably considered independent and separate works in
 *  themselves, then this License, and its terms, do not apply to those
 *  sections when you distribute them as separate works.  But when you
 *  distribute the same sections as part of a whole which is a work based
 *  on the Program, the distribution of the whole must be on the terms of
 *  this License, whose permissions for other licensees extend to the
 *  entire whole, and thus to each and every part regardless of who wrote it.
 *
 *     Thus, it is not the intent of this section to claim rights or contest
 *  your rights to work written entirely by you; rather, the intent is to
 *  exercise the right to control the distribution of derivative or
 *  collective works based on the Program.
 *
 *     In addition, mere aggregation of another work not based on the Program
 *  with the Program (or with a work based on the Program) on a volume of
 *  a storage or distribution medium does not bring the other work under
 *  the scope of this License.
 *
 *      3. You may copy and distribute the Program (or a work based on it,
 *  under Section 2) in object code or executable form under the terms of
 *  Sections 1 and 2 above provided that you also do one of the following:
 *
 *        a) Accompany it with the complete corresponding machine-readable
 *     source code, which must be distributed under the terms of Sections
 *     1 and 2 above on a medium customarily used for software interchange; or,
 *
 *        b) Accompany it with a written offer, valid for at least three
 *     years, to give any third party, for a charge no more than your
 *     cost of physically performing source distribution, a complete
 *     machine-readable copy of the corresponding source code, to be
 *     distributed under the terms of Sections 1 and 2 above on a medium
 *     customarily used for software interchange; or,
 *
 *        c) Accompany it with the information you received as to the offer
 *     to distribute corresponding source code.  (This alternative is
 *     allowed only for noncommercial distribution and only if you
 *     received the program in object code or executable form with such
 *     an offer, in accord with Subsection b above.)
 *
 *  The source code for a work means the preferred form of the work for
 *  making modifications to it.  For an executable work, complete source
 *  code means all the source code for all modules it contains, plus any
 *  associated interface definition files, plus the scripts used to
 *  control compilation and installation of the executable.  However, as a
 *  special exception, the source code distributed need not include
 *  anything that is normally distributed (in either source or binary
 *  form) with the major components (compiler, kernel, and so on) of the
 *  operating system on which the executable runs, unless that component
 *  itself accompanies the executable.
 *
 *  If distribution of executable or object code is made by offering
 *  access to copy from a designated place, then offering equivalent
 *  access to copy the source code from the same place counts as
 *  distribution of the source code, even though third parties are not
 *  compelled to copy the source along with the object code.
 *
 *     4. You may not copy, modify, sublicense, or distribute the Program
 *  except as expressly provided under this License.  Any attempt
 *  otherwise to copy, modify, sublicense or distribute the Program is
 *  void, and will automatically terminate your rights under this License.
 *  However, parties who have received copies, or rights, from you under
 *  this License will not have their licenses terminated so long as such
 *  parties remain in full compliance.
 *
 *    5. You are not required to accept this License, since you have not
 *  signed it.  However, nothing else grants you permission to modify or
 *  distribute the Program or its derivative works.  These actions are
 *  prohibited by law if you do not accept this License.  Therefore, by
 *  modifying or distributing the Program (or any work based on the
 *  Program), you indicate your acceptance of this License to do so, and
 *  all its terms and conditions for copying, distributing or modifying
 *  the Program or works based on it.
 *
 *    6. Each time you redistribute the Program (or any work based on the
 *  Program), the recipient automatically receives a license from the
 *  original licensor to copy, distribute or modify the Program subject to
 *  these terms and conditions.  You may not impose any further
 *  restrictions on the recipients' exercise of the rights granted herein.
 *  You are not responsible for enforcing compliance by third parties to
 *  this License.
 *
 *    7. If, as a consequence of a court judgment or allegation of patent
 *  infringement or for any other reason (not limited to patent issues),
 *  conditions are imposed on you (whether by court order, agreement or
 *  otherwise) that contradict the conditions of this License, they do not
 *  excuse you from the conditions of this License.  If you cannot
 *  distribute so as to satisfy simultaneously your obligations under this
 *  License and any other pertinent obligations, then as a consequence you
 *  may not distribute the Program at all.  For example, if a patent
 *  license would not permit royalty-free redistribution of the Program by
 *  all those who receive copies directly or indirectly through you, then
 *  the only way you could satisfy both it and this License would be to
 *  refrain entirely from distribution of the Program.

 *  If any portion of this section is held invalid or unenforceable under
 *  any particular circumstance, the balance of the section is intended to
 *  apply and the section as a whole is intended to apply in other
 *  circumstances.

 *  It is not the purpose of this section to induce you to infringe any
 *  patents or other property right claims or to contest validity of any
 *  such claims; this section has the sole purpose of protecting the
 *  integrity of the free software distribution system, which is
 *  implemented by public license practices.  Many people have made
 *  generous contributions to the wide range of software distributed
 *  through that system in reliance on consistent application of that
 *  system; it is up to the author/donor to decide if he or she is willing
 *  to distribute software through any other system and a licensee cannot
 *  impose that choice.

 *  This section is intended to make thoroughly clear what is believed to
 *  be a consequence of the rest of this License.
 *
 *    8. If the distribution and/or use of the Program is restricted in
 *  certain countries either by patents or by copyrighted interfaces, the
 *  original copyright holder who places the Program under this License
 *  may add an explicit geographical distribution limitation excluding
 *  those countries, so that distribution is permitted only in or among
 *  countries not thus excluded.  In such case, this License incorporates
 *  the limitation as if written in the body of this License.
 *
 *    9. The Free Software Foundation may publish revised and/or new versions
 *  of the General Public License from time to time.  Such new versions will
 *  be similar in spirit to the present version, but may differ in detail to
 *  address new problems or concerns.
 *
 *  Each version is given a distinguishing version number.  If the Program
 *  specifies a version number of this License which applies to it and "any
 *  later version", you have the option of following the terms and conditions
 *  either of that version or of any later version published by the Free
 *  Software Foundation.  If the Program does not specify a version number of
 *  this License, you may choose any version ever published by the Free Software
 *  Foundation.

 *    10. If you wish to incorporate parts of the Program into other free
 *  programs whose distribution conditions are different, write to the author
 *  to ask for permission.  For software which is copyrighted by the Free
 *  Software Foundation, write to the Free Software Foundation; we sometimes
 *  make exceptions for this.  Our decision will be guided by the two goals
 *  vof preserving the free status of all derivatives of our free software and
 *  of promoting the sharing and reuse of software generally.
 *
 *  			    NO WARRANTY
 *
 *    11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
 *  FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
 *  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
 *  PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
 *  OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
 *  TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
 *  PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
 *  REPAIR OR CORRECTION.
 *
 *    12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
 *  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
 *  REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
 *  INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
 *  OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
 *  TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
 *  YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
 *  PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGES.
 *
 *  		     END OF TERMS AND CONDITIONS
 *
 *  	    How to Apply These Terms to Your New Programs
 *    If you develop a new program, and you want it to be of the greatest
 *  possible use to the public, the best way to achieve this is to make it
 *  free software which everyone can redistribute and change under these terms.
 *
 *    To do so, attach the following notices to the program.  It is safest
 *  to attach them to the start of each source file to most effectively
 *  convey the exclusion of warranty; and each file should have at least
 *  the "copyright" line and a pointer to where the full notice is found.
 *
 *      <one line to give the program's name and a brief idea of what it does.>
 *      Copyright (C) <year>  <name of author>
 *
 *      This program is free software; you can redistribute it and/or modify
 *      it under the terms of the GNU General Public License as published by
 *      the Free Software Foundation; either version 2 of the License, or
 *      (at your option) any later version.
 *
 *      This program is distributed in the hope that it will be useful,
 *      but WITHOUT ANY WARRANTY; without even the implied warranty of
 *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *      GNU General Public License for more details.
 *
 *      You should have received a copy of the GNU General Public License
 *      along with this program; if not, write to the Free Software
 *      Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *
 *
 *  Also add information on how to contact you by electronic and paper mail.
 *
 *  If the program is interactive, make it output a short notice like this
 *  when it starts in an interactive mode:
 *
 *      Gnomovision version 69, Copyright (C) year name of author
 *      Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
 *      This is free software, and you are welcome to redistribute it
 *      under certain conditions; type `show c' for details.
 *
 *  The hypothetical commands `show w' and `show c' should show the appropriate
 *  parts of the General Public License.  Of course, the commands you use may
 *  be called something other than `show w' and `show c'; they could even be
 *  mouse-clicks or menu items--whatever suits your program.
 *
 *  You should also get your employer (if you work as a programmer) or your
 *  school, if any, to sign a "copyright disclaimer" for the program, if
 *  necessary.  Here is a sample; alter the names:
 *
 *    Yoyodyne, Inc., hereby disclaims all copyright interest in the program
 *    `Gnomovision' (which makes passes at compilers) written by James Hacker.
 *
 *    <signature of Ty Coon>, 1 April 1989
 *    Ty Coon, President of Vice

 *  This General Public License does not permit incorporating your program into
 *  proprietary programs.  If your program is a subroutine library, you may
 *  consider it more useful to permit linking proprietary applications with the
 *  library.  If this is what you want to do, use the GNU Library General
 *  Public License instead of this License.

*/

package it.aco.mandragora.dao;

import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import java.util.Vector;

import it.aco.mandragora.exception.DataAccessException;
import it.aco.mandragora.exception.DataOptimisticLockException;
import it.aco.mandragora.query.LogicCondition;

/**
 * The methods of this interface are the responsible ones of accessing the Media
 * Store and perform the requested operations. <br>
 * How a connection to the Media Store is established and managed, how the Media
 * store is accessed, and how the the transaction isolation is managed depends
 * on the concrete implementation.<br>
 *
 * @author Alessandro Colantoni
 */
public interface DAO {

    /**
     * Returns the instance of the class <code>realClass</code> whose key fields
     * have the values in <code>pkValues</code>. <br/>
     * For example if I have a class <code>UserRol</code> that has as primary
     * key the fields <code>usercode</code> and <code>rolcode</code>, invoking:
     * <br/>
     * <code>findByPrimaryKey(UserRol.class ,new String[]{"Antonio","manager"})</code>
     * <br/>
     * returns UserRol object with usercode ="Antonio" and rolcode="manager".
     * <br/>
     * Note that the primary key field names are not directly specified by any
     * of the input parameters of this method.<br/>
     * They should be specified by some configuration file (i.e. the
     * repository.xml file in the case of Ojb).<br/>
     * How the <code>pkValues<code> are associated to the primary key fields
     * depends on the implementation detail.
     *
     * @param realClass
     *            real class of the object to be returned
     * @param pkValues
     *            array of the values that primary key fields must have
     * @return the instance of realClass whose primary key fields values are
     *         pkValues
     * @throws DataAccessException
     *             for any trouble
     */
    public Object findByPrimaryKey(Class realClass, Object[] pkValues) throws DataAccessException;

    /**
     * This method returns the instance of the class <code>realClass</code> that
     * has the values of his primary key fields specified by the input array
     * parameter <code>pkValues</code>.<br/>
     * The primary key fields of the class <code>realClass</code> must be the
     * ones specified by the input array parameter <code>pkFieldNames</code>.
     * The association between the values of the array <code>pkValues</code> and
     * the primary keys <code>pkFieldNames</code> is by the order the arrays, so
     * that <code>pkValues[i]</code> is the value of the primary key field whose
     * name is <code>pkFieldNames[i]</code>. </br>
     *
     * For example if I have a class <code>UserRol</code> that has as primary
     * key the fields <code>usercode</code> and <code>rolcode</code>, invoking:
     * <br/>
     * <code>findByPrimaryKey(UserRol.class, new String[]{"usercode","rolcode"}) ,new String[]{"Antonio","manager"})</code>
     * <br/>
     * returns the UserRol instance with usercode ="Antonio" and
     * rolcode="manager". <br/>
     *
     * See {@link #findByPrimaryKey(Class realClass,Object[] pkValues)}
     *
     * @param realClass
     *            realClass real class of the object to be returned
     * @param pkFieldNames
     *            array containing the names of the fields that act as key. The
     *            fields in this array must be a key.
     * @param pkValues
     *            array of array of the values that key fields (in fieldName)
     *            must have
     * @return the instance of realClass whose primary key fields values are
     *         pkValues
     * @throws DataAccessException
     *             for any trouble
     */
    public Object findByPrimaryKey(Class realClass, String[] pkFieldNames, Object[] pkValues) throws DataAccessException;

    /**
     * Acts as {@link #findByPrimaryKey(Class realClass,Object[] pkValues)}
     * where the key is just one field
     *
     * @param realClass
     *            realClass realClass real class of the object to be returned
     * @param pkValue
     *            value of the key of the real class
     * @return the instance of realClass whose key has values pkValue
     * @throws DataAccessException
     *             for any trouble
     */
    public Object findByPrimaryKey(Class realClass, java.lang.Object pkValue) throws DataAccessException;

    /**
     * This method has the same behavior of
     * {@link #findCollectionByTemplate(Object templateVO)}, except that it
     * returns just the first element of the collection that would be retrieved
     * by {@link #findCollectionByTemplate(Object templateVO)}</br>
     * So this method returns an instance of the same class of
     * <code>templateVO</code>, whose not null fields in
     * <code>templateVO</code>, have the same value.<br/>
     * . The object returned is the first one matching this condition
     *
     * @param templateVO
     *            Object whose fields not null have to match in the returned
     *            object
     * @return the first object according to <code>templateVO</code>
     * @throws DataAccessException
     *             for any trouble
     */
    public Object findObjectByTemplate(Object templateVO) throws DataAccessException;

    public Object findObjectByQueryString(String queryString, Map parameters) throws DataAccessException;

    public Object findObjectByQueryString(String queryString) throws DataAccessException;

    public Object findObjectByQueryString(String queryString, String parameterName, Object parameterValue) throws DataAccessException;

    public Collection findCollectionByQueryString(String queryString) throws DataAccessException;

    public Collection findCollectionByQueryString(String queryString, Map parameters, Integer firstResult, Integer maxResults) throws DataAccessException;

    public Collection findCollectionByQueryString(String queryString, Map parameters) throws DataAccessException;

    public Collection findCollectionByNativeQueryString(String queryString) throws DataAccessException;

    public Collection findCollectionByNativeQueryString(String queryString, String parameterName, Object parameterValue) throws DataAccessException;

    public Collection findCollectionByNativeQueryString(String queryString, Map parameters) throws DataAccessException;

    /**
     * Returns a collection of objects of the same class of
     * <code>templateVO</code>, whose not null fields in
     * <code>templateVO</code>, have the same value.<br/>
     * For example if we have a class <code>Car</code> with many fields, two of
     * which are <code>color</code> and <code>engine</code>, if we do :<br/>
     * car = new Car();<br/>
     * car.setColor("red");<br/>
     * car.setEngine("mercedes");<br/>
     * findCollectionByTemplate(car); Will be returned all cars whose color is
     * red an whose engine is mercedes.
     *
     * @param templateVO
     *            Object whose fields not null have to match in the returned
     *            objects
     * @return a collection of objects according to templateVO not null field
     *         values.
     * @throws DataAccessException
     *             for any trouble
     */
    public Collection findCollectionByTemplate(Object templateVO) throws DataAccessException;

    /**
     * This methods acts as {@link #findCollectionByTemplate(Object templateVO)}
     * with the only difference that the result collection is ordered by
     * <code>orderingField</code>.</br>
     * If the input parameter <code>asc</code> is null or true the order will be
     * ascending, otherwise descending.
     *
     * @param templateVO
     *            object whose fields not null have to match in the returned
     *            objects
     * @param orderingField
     *            Field against which will be performed the ordered
     * @param asc
     *            Specifies if the ordering should be ascending or descending
     *            (if the parameter is null the order will be ascending)
     * @return a collection of objects according to <code>templateVO</code> not
     *         null field values, ordered by <code>orderingField</code>
     * @throws DataAccessException
     *             for any trouble
     */
    public Collection findCollectionByTemplate(Object templateVO, String orderingField, Boolean asc) throws DataAccessException;

    /**
     * Looks for all instances of <code>realClass</code> whose fields in the
     * array <code>nullFields</code> are null.</br>
     * Strings could be a path to the fields of other directly or indirectly
     * related classes too. </br>
     * <br/>
     *
     * @param realClass
     *            Class which instances have to looked for
     * @param nullFields
     *            Array of field names that have to be null in the search
     * @return The collection of all instances of <code>realClass</code>
     *         realClass whose fields in the array <code>nullFields</code> are
     *         null
     * @throws DataAccessException
     *             -If <code>realClass</code> or <code>nullFields</code> are
     *             null. </br>
     */
    public Collection findCollectionByNullFields(Class realClass, String[] nullFields) throws DataAccessException;

    /* inicio added por alessandro el 17-03-2013 */
    public Object findObjectByLogicCondition(java.lang.Class realClass, LogicCondition logicCondition) throws DataAccessException;

    public Object findObjectByLogicCondition(String[] selectFields, java.lang.Class realClass, LogicCondition logicCondition) throws DataAccessException;

    public Object findObjectByLogicCondition(String[] selectFields, java.lang.Class realClass, LogicCondition logicCondition, String orderBy) throws DataAccessException;

    public Object findObjectByLogicCondition(java.lang.Class realClass, LogicCondition logicCondition, String orderBy) throws DataAccessException;

    /* fin added por alessandro el 17-03-2013 */

    /**
     * Looks for all instances of <code>realClass</code> that satisfy the
     * <code>logicCondition</code></br>
     * For example
     * <code>findCollectionByLogicCondition(Employee.class,new LogicSqlCondition("age","<=",new Integer(35),"AND", new LogicSqlCondition("salary",">=", new Integer(40000))))</code></br>
     * returns all instance of Employee where age<=35 and salary >= 40000 </br>
     *
     * @param realClass
     *            Class which instances have to looked for
     * @param logicCondition
     *            condition that must be satisfied
     * @return The collection of all instances of class realClass that satisfy
     *         the <code>logicCondition</code>
     * @throws DataAccessException
     *             -If <code>realClass</code> or <code>logicCondition</code> are
     *             null. </br>
     */
    public Collection findCollectionByLogicCondition(Class realClass, LogicCondition logicCondition) throws DataAccessException;

    /**
     * This method Looks for all instances of <code>realClass</code> that
     * satisfy the <code>logicCondition</code>, but returns the collection
     * ordered by the attribute <code>orderingField</code> , in the ascending or
     * descending way depending of if the parameter <code>asc</code> is true or
     * false, and in the collection returned there will be just the elements
     * between <code>startAtIndex</code> and <code>endAtIndex</code>
     * (included).</br>
     * If <code>orderingField</code> is null, or empty or blank string, no order
     * is applied. </br>
     * If <code>asc</code> is null it will be considered as true. </br>
     * If <code>startAtIndex</code> is null it will be ignored. </br>
     * If <code>endAtIndex</code> is null it will be ignored. </br>
     * </br>
     *
     * @param realClass
     *            Class which instances have to looked for
     * @param logicCondition
     *            condition that must be satisfied
     * @param orderingField
     *            attribute by which the ordering has to be applied. If null no
     *            ordering is applied.</br>
     * @param asc
     *            if true or null ascending order is applied. If not null and
     *            false descending is applied
     * @param startAtIndex
     *            Start index of the mathing instances that have to be returned
     *            in the collection
     * @param endAtIndex
     *            end index of the mathing instances that have to be returned in
     *            the collection
     * @return The collection of all instances of class realClass that satisfy
     *         the <code>logicCondition</code>, from the element
     *         <code>startAtIndex</code> to the elements at
     *         <code>endAtIndex</code>
     * @throws DataAccessException
     *             -If <code>realClass</code> or <code>logicCondition</code> are
     *             null. </br>
     */
    public Collection findCollectionByLogicCondition(Class realClass, LogicCondition logicCondition, String orderingField, Boolean asc, Integer startAtIndex, Integer endAtIndex)
	    throws DataAccessException;

    public Collection findCollectionByLogicCondition(java.lang.Class realClass, LogicCondition logicCondition, String orderBy) throws DataAccessException;

    public Collection findCollectionByLogicCondition(String[] selectFields, java.lang.Class realClass, LogicCondition logicCondition) throws DataAccessException;

    public Collection findCollectionByLogicCondition(Boolean distinct, String[] selectFields, java.lang.Class realClass, LogicCondition logicCondition, String orderBy) throws DataAccessException;

    public Collection findCollectionByLogicCondition(String[] selectFields, java.lang.Class realClass, LogicCondition logicCondition, String orderBy) throws DataAccessException;

    /**
     * @deprecated use
     *             {@link #findCollectionByLogicCondition(Class realClass,LogicCondition logicCondition,String orderingField, Boolean asc,Integer startAtIndex, Integer endAtIndex)}
     */
    @Deprecated
    public Collection findLimitedOrderedCollectionByLogicCondition(Class realClass, LogicCondition logicCondition, String orderingField, boolean asc, int startAtIndex, int endAtIndex)
	    throws DataAccessException;

    /**
     * This method returns all instance of <code>realClass</code>, which field
     * <code>pAttributeName</code> assumes one of the values contained in
     * <code>valuesCollection</code>.</br>
     * If <code>valuesCollection</code> is null or empty, a null is returned .
     *
     * @param realClass
     *            Class which instances have to looked for
     * @param pAttributeName
     *            field that has to be compared with
     *            <code>valuesCollection</code>
     * @param valuesCollection
     *            values to be compared with <code>pAttributeName</code>
     * @return all instances of <code>realClass</code>, which field
     *         <code>pAttributeName</code> have one of the values contained in
     *         <code>valuesCollection</code>
     * @throws DataAccessException
     *             - If <code>realClass</code> is null or
     *             <code>pAttributeName</code> is null or empty or blank
     *             characters string
     */
    public Collection findCollectionByOrValues(Class realClass, String pAttributeName, Collection valuesCollection) throws DataAccessException;

    /**
     * Looks for all instaces of <code>realClass</code> which has each field in
     * <code>pAttributeNames</code> not equals to the correspondent value in
     * <code>valuesArray</code>.</br>
     * In other words must be verified the condition:
     * (<code>pAttributeNames[i]!=valuesArray[i]</code>).</br>
     * If arrays are empty all instances will be returned.
     *
     * @param realClass
     *            Class which instances have to looked for
     * @param pAttributeNames
     *            fields to be compared
     * @param valuesArray
     *            values to be compared
     * @return all instances of realClass where
     *         <code>properties[i]!=values[i]</code> for all i.
     * @throws DataAccessException
     *             for any trouble
     */
    public Collection findCollectionByFieldsNotEqualsToValues(Class realClass, String[] pAttributeNames, Object[] valuesArray) throws DataAccessException;

    /**
     * Returns a collection of instances of <code>realClass</code> which satisfy
     * <code>pAttributeNames[i] operators[i] valuesArray[i]</code> for each
     * i</br>
     * Example: <code>color = "red" and price "<=" 10000</code></br>
     * NOTE!! Operators supported must be
     * <code>==,=,<=,>=,<,>,!=,<></code>.</br>
     * If arrays are empty all instances are returned. </br>
     *
     * @param realClass
     *            Class which instances have to looked for
     * @param pAttributeNames
     *            fields to be compared
     * @param operators
     *            operators to use to compare
     * @param valuesArray
     *            values to be compared
     * @return a collection of instances of realClass which satisfy
     *         <code>pAttributeNames[i] operators[i] valuesArray[i]</code> for
     *         each i
     * @throws DataAccessException
     *             for any trouble
     */
    public Collection findCollectionByAndFieldsOperatorValues(Class realClass, String[] pAttributeNames, String[] operators, Object[] valuesArray) throws DataAccessException;

    /**
     * Returns a collection of instances of <code>realClass</code> which satisfy
     * AND OR conditions.</br>
     * The condition is the AND of
     * <code>pAttributeNames[i] operators[i] valuesMatrix[j][i]</code> for each
     * i, in OR for each j.</br>
     * <p>
     * Example: suppose <code>valuesMatrix</code> is a 2X2 matrix where
     * valuesMatrix[0][0]=0,valuesMatrix[0][1]=1,valuesMatrix[1][0]=10,valuesMatrix[1][1]=11</br>
     * suppose pAttributeNames={"property0", "property1"} and suppose
     * operators={"<",">"}</br>
     * the consition is (property0<0 and property1 >1)or (property0<10 and
     * property1>11)</br>
     * Operators supported must be <code>==,=,<=,>=,<,>,!=,<></code></br>
     * Note!! Arrays must be not Null!!
     *
     * @param realClass
     *            Class which instances have to looked for
     * @param pAttributeNames
     *            fields to be compared
     * @param operators
     *            operators to use to compare
     * @param valuesMatrix
     *            matrix of values to be compared
     * @return a collection of instances of <code>realClass</code> which satisfy
     *         and AND OR conditions.
     * @throws DataAccessException
     *             for any trouble
     */
    public Collection findCollectionByArrayOfFieldsOperatorsMatrixAndOrValues(Class realClass, String[] pAttributeNames, String[] operators, Object[][] valuesMatrix) throws DataAccessException;

    /**
     * Looks for all instances of <code>realClass</code> which value of field
     * <code>pAttributeName</code> is equal to one contained in
     * <code>valuesCollection</code>.
     *
     * @param realClass
     *            Class which instances have to looked for
     * @param pAttributeName
     *            field whose value has to be in <code>values</code>
     * @param valuesCollection
     *            collection in which the value of <code>pAttributeName</code>
     *            has to be searched
     * @return all instances of <code>realClass</code> which
     *         <code>valuesCollection</code> of field pAttributeName is equal to
     *         one contained in <code>values</code>.
     * @throws DataAccessException
     *             for any trouble
     */
    public Collection findCollectionByFieldInCollection(Class realClass, String pAttributeName, Collection valuesCollection) throws DataAccessException;

    /**
     * Looks for all instances of <code>realClass</code> that holds
     * <code>value</code> in one of fields in <code>pAttributeNames</code></br>
     * Matching instances must satisfy:</br>
     * <code>instance.pAttributeNames[i] Like %value%</code> for at list one
     * i.</br>
     * </br>
     *
     * @param realClass
     *            Class which instances have to be looked for
     * @param pAttributeNames
     *            fields in which <code>value</code> has to be searched
     * @param value
     *            value to search in <code>pAttributeNames</code>
     * @return all instances of <code>realClass</code> that satisfy
     *         <code>instance.pAttributeNames[i] Like %value%</code> for at list
     *         one i.
     * @throws DataAccessException
     *             - If <code>realClass</code> or <code>pAttributeNames</code>
     *             are null.</br>
     */
    public Collection searchValueInFields(Class realClass, String[] pAttributeNames, Object value) throws DataAccessException;

    /**
     * This method returns a collection of instances of the class of the items
     * of the collection <code>pInstance.pAttributeName</code> that are stored
     * in the media store and related to the same <code>pInstance</code>, but
     * that are not present in the collection
     * <code>pInstance.pAttributeName</code></br>
     * </br>
     *
     * @param pInstance
     *            value object which items related to in the media store have to
     *            be returned in the collection.
     * @param pAttributeName
     *            name of the attribute holding the collection which item class
     *            intances, related to <code>pInstance</code>, have to be
     *            returned, if not present in the same collection.
     * @return the collection of instances of the item class of
     *         <code>pInstance.pAttributeName</code> related to
     *         <code>pInstance</code> in the media store, but not present in the
     *         collection <code>pInstance.pAttributeName</code>.
     * @throws DataAccessException
     *             if <code>pInstance</code> is null or
     *             <code>pAttributeName</code> is null or empty or blank
     *             characters string.
     */
    public Collection getCollectionOfStoredItemsNotInBean(Object pInstance, String pAttributeName) throws DataAccessException;

    /**
     * This method returns a collection of instances of the class of the items
     * of the collection <code>pInstance.pAttributeName</code> that are stored
     * in the media store and related to the same <code>pInstance</code>.</br>
     * </br>
     *
     * @param pInstance
     *            value object which items related to in the media store have to
     *            be returned in the collection.
     * @param pAttributeName
     *            name of the attribute holding the collection which item class
     *            intances, related to <code>pInstance</code>, have to be
     *            returned
     * @return the collection of instances of the item class of
     *         <code>pInstance.pAttributeName</code> related to
     *         <code>pInstance</code> in the media store.
     * @throws DataAccessException
     *             - if <code>pInstance</code> is null or
     *             <code>pAttributeName</code> is null or empty or blank
     *             characters string.
     */
    public Collection getStoredCollection(Object pInstance, String pAttributeName) throws DataAccessException;

    /**
     * Report queries are used to retrieve row data, not 'real' business
     * objects.</br>
     * A row is an array of Object. With these queries you can define what
     * attributes of an object (instance of the class <code>realClass</code>)
     * you want to have in the row.</br>
     * The attribute names may also contain path expressions like
     * 'owner.address.street'.</br>
     * </br>
     *
     * @param realClass
     *            class wich attribute you want to retrieve, or where the path
     *            expression must start from
     * @param logicCondition
     *            logic condition that specify which rows have to be retrieved
     * @param pAttributeNames
     *            array of the attribute to retrieve
     * @param groupBy
     *            It must be an array that specifies the attributes that are
     *            used in the group by clause.</br>
     *            If this parameter is null or is a 0 length array, the group by
     *            clause will not be applied.
     * @return this method returns an Iterator over a Collection of Object[n] of
     *         the attributes
     * @throws DataAccessException
     *             - if <code>realClass</code> or <code>logicCondition</code>
     *             are null, or <code>pAttributeNames</code> is null or empty.
     */
    public Iterator getReportQueryIterator(Class realClass, LogicCondition logicCondition, String[] pAttributeNames, String[] groupBy) throws DataAccessException;

    /**
     * Retrieves the specified reference or collection attribute for the given
     * persistent object <code>pInstance</code> . </br>
     *
     * @param pInstance
     *            The persistence object
     * @param pAttributeName
     *            attribute to retrieve
     * @throws DataAccessException
     *             - If <code>pInstance</code> or <code>pAttributeName</code>
     *             are null. </br>
     */
    public void retrieveReference(Object pInstance, String pAttributeName) throws DataAccessException;

    /**
     * This method has the same behavior of as
     * {@link #retrieveReference(Object, String)} with the difference that the
     * operation is performed on all elements of
     * <code>valueObjectsCollection</code>
     *
     * @param valueObjectsCollection
     *            objects for which specified reference will be retrieved
     * @param pAttributeName
     *            specified reference to retrieve
     * @throws DataAccessException
     *             - If <code>valueObjectsCollection</code> or
     *             <code>pAttributeName</code> are null. </br>
     */
    public void retrieveReferenceInCollection(Collection valueObjectsCollection, String pAttributeName) throws DataAccessException;

    /**
     * Retrieves all references and collections of the given object
     * <code>pInstance</code>. </br>
     *
     * @param pInstance
     *            Object in which the retrieve will be performed
     * @throws DataAccessException
     *             - If <code>pInstance</code> is null
     */
    public void retrieveAllReferences(Object pInstance) throws DataAccessException;

    /**
     * This method must have the same behavior of
     * {@link #retrieveAllReferences(Object)} with the difference that the
     * operation is performed on all elements of <code>collection</code> </br>
     *
     * @param valueObjectsCollection
     *            objects for which all references will be retrieved
     * @throws DataAccessException
     *             - If valueObjectsCollection is null.
     */
    public void retrieveAllReferencesInCollection(Collection valueObjectsCollection) throws DataAccessException;

    /**
     * This method retrieves the specified reference or collection attribute for
     * the given persistent object <code>pInstance</code> . if the same
     * reference or collection attribute are null.</br>
     * . In other words the behavior is the same of
     * {@link #retrieveReference(Object pInstance, String pAttributeName)} if
     * <code>pInstance.pAttributeName</code> is null, otherwise no job is done
     * </br>
     *
     * @param pInstance
     *            The persistence object
     * @param pAttributeName
     *            attribute to retrieve
     * @throws DataAccessException
     *             - If <code>pInstance</code> or <code>pAttributeName</code>
     *             are null. </br>
     */
    public void retrieveNullReference(Object pInstance, String pAttributeName) throws DataAccessException;

    /**
     * This method retrieves all the references of the persistence object
     * <code>pInstance</code> that are null.</br>
     * In other words it has the same behavior of
     * {@link #retrieveNullReference(Object pInstance, String pAttributeName)},
     * but for all its references.</br>
     * </br>
     *
     * @param pInstance
     *            Object, which all null references of, will be retrieved.
     * @throws DataAccessException
     *             - If <code>pInstance</code> is null. </br>
     */
    public void retrieveAllNullReferences(Object pInstance) throws DataAccessException;

    /**
     * This method retrieves from the media store the references in objects or
     * collections found following the <code>path</code> starting from
     * <code>valueobjectOrCollection</code> .</br>
     * Suppose you have an author who wrote many books each of which has a
     * publishing house each of which has a manager.</br>
     * If I do:</br>
     * <code>retrievePathReference(author, "books.publisher.manager");</code></br>
     * all books of the author will be retrieved, and for each book his
     * publisher will be retrieved, and for the publisher his manager will be
     * retrieved.</br>
     * You can start from a colleccion instead of an object. ex:</br>
     * <code>retrievePathReference(authors, "books.publisher.manager");</code></br>
     * retrieving will be done for each author of the collection authors. </br>
     * If <code>valueobjectOrCollection</code> is null or <code>path</code> is
     * null or empty or blank characters string, nothing is done.</br>
     *
     * @param valueobjectOrCollection
     *            Starting object or collection
     * @param path
     *            references separated by a dot; example:
     *            <code>book.publisher.manager</code>
     * @throws DataAccessException
     *             for any trouble
     */
    public void retrievePathReference(Object valueobjectOrCollection, String path) throws DataAccessException;

    /**
     * This method has the same behavior of
     * {@link #retrievePathReference(Object valueobjectOrCollection, String path)}
     * with the difference, that following the <code>path</code>, if the value
     * referenced by an attribute is null, such reference will be retrieved from
     * the underlying media store, otherwise not.</br>
     *
     * @param valueobjectOrCollection
     *            Starting object or collection
     * @param path
     *            dot separated list of attributes: example :
     *            <code>book.publisher.manager</code>
     * @throws DataAccessException
     *             for any trouble
     */
    public void retrieveNullPathReference(Object valueobjectOrCollection, String path) throws DataAccessException;

    /**
     * Deletes the object deleteVO from the underlying datastore.</br>
     * The operation is atomic. </br>
     * Connection management and transaction management are fully
     * delegated.</br>
     * User must no care at all!!.</br>
     *
     * @param deleteVO
     *            object to be deleted
     * @throws DataAccessException
     *             if <code>deleteVO</code> is null
     * @throws DataOptimisticLockException
     *             if the optimistic lock fails
     */
    public void delete(Object deleteVO) throws DataAccessException, DataOptimisticLockException;

    /**
     * This method deletes the collection of valueobjects <code>deleteVOs</code>
     * from the underlying datastore.</br>
     * The operation is atomic. </br>
     * Connection management and transaction management are fully
     * delegated.</br>
     * User must no care at all!!.</br>
     *
     * @param deleteVOs
     *            collection of value objects to delete
     * @throws DataAccessException
     * @throws DataOptimisticLockException
     */
    public void deleteCollection(Collection deleteVOs) throws DataAccessException, DataOptimisticLockException;

    public void deleteMToNRelationshipCollection(Object left, String leftFieldName, Collection rightCollection) throws DataAccessException;

    public void deleteItemsNotInCollectionsInPath(Object rootVO, String path, Boolean applyDeletePathCascade, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) throws DataAccessException;

    public void deleteItemsNotInCollectionsInPath(Object rootVO, String path) throws DataAccessException;

    public void deleteItemsNotInCollectionsInPath(Object rootVO, String path, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) throws DataAccessException;

    public void deleteItemsNotInCollectionsInPaths(Object rootVO, Collection paths, Boolean applyDeletePathCascade, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne)
	    throws DataAccessException;

    public void deletePathCascade(Object parentVO, String path, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) throws DataAccessException;

    public void deletePathsCascade(Object parentVO, Collection paths, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) throws DataAccessException;

    /**
     * Inserts the object <code>storeVO</code> in the underlying datastore.</br>
     * The operation is atomic.</br>
     * Connection management and transaction management are fully
     * delegated.</br>
     * User must no care at all!!.
     *
     * @param storeVO
     *            Object to insert in the media store
     * @return The same inserted object
     * @throws DataAccessException
     * @throws DataOptimisticLockException
     */
    public Object insert(Object storeVO) throws DataAccessException, DataOptimisticLockException;

    public Object refresh(Object refreshVO) throws DataAccessException;

    /**
     * This method updates the object <code>storeVO</code> in the underlying
     * datastore.</br>
     * The operation is atomic.</br>
     * Connection management and transaction management are fully
     * delegated.</br>
     * User must no care at all!!.</br>
     *
     * @param storeVO
     *            Object to update
     * @return The same updated object
     * @throws DataAccessException
     * @throws DataOptimisticLockException
     */
    public Object update(Object storeVO) throws DataAccessException, DataOptimisticLockException;

    /**
     * This method updates all objects in the collection storeVOs in an atomic
     * transaction, without user have to carry about connection and transaction
     * management. The collection must be of value objects, and for each of them
     * will this method will act as update or insert depending by if the value
     * object already exists or not in the datastore. The value object of the
     * collection must not necessarily be instance of the same class. <br/>
     *
     * @param storeVOs
     *            objects to be updated or inserted
     * @throws DataAccessException
     * @throws DataOptimisticLockException
     */
    public void updateCollection(Collection storeVOs) throws DataAccessException, DataOptimisticLockException;

    /**
     * Updates the object <code>storeVO</code> and all objects of the collection
     * associated to <code>pAttributeName</code>.</br>
     * <code>pAttributeName</code> has to be the name of a collection
     * properties.</br>
     * It deletes all objects in the datastore not present in the collection
     * specified by <code>pAttributeName</code>.</br>
     * Connection management and transaction management are fully
     * delegated.</br>
     * User must no care at all!!.
     *
     * @param storeVO
     *            The object to update
     * @param pAttributeName
     *            attribute of storeVO specifying a collection
     * @return the same storeVO
     * @throws DataAccessException
     * @throws DataOptimisticLockException
     */
    public Object updateCollectionReference(Object storeVO, String pAttributeName) throws DataAccessException, DataOptimisticLockException;

    /**
     * This method must have the same behavior of
     * {@link #updateCollectionReference(Object storeVO, String pAttributeName)}
     * with the difference that it has done for all references.</br>
     * Connection management and transaction management are fully
     * delegated.</br>
     * User must no care at all!!.
     *
     * @param storeVO
     *            Object to update
     * @return storeVO
     * @throws DataAccessException
     * @throws DataOptimisticLockException
     */
    public Object updateCollectionReferences(Object storeVO) throws DataAccessException, DataOptimisticLockException;

    /**
     * This method has the same behavior of
     * {@link #storePathsCascade(Object storeVO, Collection paths, Boolean pathsHasToBeSorted, Boolean storeVOHasToBeStored)}
     * where the collection <code>paths</code> has just one element that is the
     * input parameter <code>paths</code>, and where
     * <code>pathsHasToBeSorted</code> and <code>storeVOHasToBeStored</code> are
     * both true
     *
     * @param storeVO
     *            root of <code>path</code>
     * @param path
     *            string of separated list of attributes.
     * @throws DataAccessException
     *             for any trouble
     * @throws DataOptimisticLockException
     *             if the optimistic lock fails
     */
    public void storePathCascade(Object storeVO, String path) throws DataAccessException, DataOptimisticLockException;

    /**
     * This method creates or updates the value objects on a tree.</br>
     * The tree is represented by <code>storeVO</code>, that is the value object
     * root, and <code>paths</code>, that is a collection of strings that are
     * the paths of the tree from the root. </br>
     * Each element of <code>paths</code> is a dot separated list of attributes;
     * for example it could be:</br>
     * <code>attribute_1.attribute_2.attribute_3.attribute_4</code></br>
     * We will deal with <code>storeVO</code> as <code>attribute_0</code>. The
     * nodes of level i of the <code>tree</code> are all labeled
     * <code>attribute_i</code>.</br>
     * The generic <code>attribute_i</code> can represent a value object or a
     * collection. The <code>attribute_i</code> must be a property of
     * <code>attribute_i-1</code> if <code>attribute_i-1</code> is a value
     * object, and must be a property of each element
     * of<code>attribute_i-1</code> if <code>attribute_i-1</code> is a
     * collection.</br>
     * So <code>storeVO</code> must have a property named
     * <code>attribute_1</code> that can be a value object or a collection; the
     * value object or each element of the collection must have a property named
     * <code>attribute_2</code> that can be a value object or a collection too.
     * And so on.</br>
     * . Nodes of level i in the <code>tree</code> will be value objects that
     * are the property named <code>attribute_i</code> or all elements ( that
     * are value objects too) of collections that are the property named
     * <code>attribute_i</code>.</br>
     * When called this method do for each elements of <code>trees</code>:</br>
     * 1- Object <code>storeVO</code> will be updated if <code>storeVO</code>
     * exists. If not it will be created.</br>
     * 2- For each elements of <code>paths</code>:</br>
     * 2.1- Each node of level i will be created or updated, and above all it
     * will be related to its father: concretely if the elements of the current
     * level belong to a collection they will be linked to the father, while if
     * are a simple valueobject, its father will be linked to it.</br>
     *
     *
     *
     * @param storeVO
     *            common root of <code>paths</code>
     * @param paths
     *            collection of String. Each element is a dot separated list of
     *            attributes.
     * @param pathsHasToBeSorted
     *            To make the method to work, the collection of String
     *            <code>paths</code> must be ordered. If it is already ordered
     *            set this parameter to false, and t true otherwise
     * @param storeVOHasToBeStored
     *            it establishes if the root <code>storeVO</code> has to be
     *            updated too or not
     * @throws DataAccessException
     *             for any trouble
     * @throws DataOptimisticLockException
     *             if the optimistic lock fails
     */
    public void storePathsCascade(Object storeVO, Collection paths, Boolean pathsHasToBeSorted, Boolean storeVOHasToBeStored) throws DataAccessException, DataOptimisticLockException;

    public Object updateCreateTrees(Object storeVO, Collection<String> trees, Boolean storeVOHasToBeUpdated, Boolean deleteChangedOneToOne, Boolean applyDeletePathCascade,
	    Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) throws DataAccessException, DataOptimisticLockException;

    /**
     *
     * This method has the same behavior of
     * {@link #updateCreateTrees(Object storeVO, Collection trees, Boolean storeVOHasToBeUpdated)},
     * but it gives the possibility to specify if the root <code>storeVO</code>
     * has to be updated too or not, through the input Boolean parameter
     * <code>storeVOHasToBeUpdated</code>.</br>
     *
     * @param storeVO:
     *            common root of trees
     * @param trees:
     *            collection of String. Each element is a dot separeted list of
     *            attributes.
     * @param storeVOHasToBeUpdated
     *            it establishes if the root <code>storeVO</code> has to be
     *            updated too or not
     * @return the same storeVO
     * @throws DataAccessException
     * @throws DataOptimisticLockException
     */
    public Object updateCreateTrees(Object storeVO, Collection trees, Boolean storeVOHasToBeUpdated) throws DataAccessException, DataOptimisticLockException;

    /**
     * This method creates or updates a collection of trees in the underlying
     * media store.</br>
     * All trees have a common root that is <code>storeVO</code>. The structure
     * could be considered as just one tree, but we manage it as a collection of
     * trees to keep it easy.</br>
     * The collection of trees is represented by the input parameter
     * <code>trees</code> that is a collection of String.</br>
     * Each element of <code>trees</code> is a dot separated list of attributes;
     * for example it could be:</br>
     * <code>attribute_1.attribute_2.attribute_3.attribute_4</code></br>
     * We will deal with <code>storeVO</code> as <code>attribute_0</code>. The
     * nodes of level i of a <code>tree</code> are all labeled
     * <code>attribute_i</code>.</br>
     * The generic <code>attribute_i</code> can represent a value object or a
     * collection. The <code>attribute_i</code> must be a property of
     * <code>attribute_i-1</code> if <code>attribute_i-1</code> is a value
     * object, and must be a property of each element
     * of<code>attribute_i-1</code> if <code>attribute_i-1</code> is a
     * collection.</br>
     * So <code>rootVO</code> must have a property named
     * <code>attribute_1</code> that can be a value object or a collection; the
     * value object or each element of the collection must have a property named
     * <code>attribute_2</code> that can be a value object or a collection too.
     * And so on.</br>
     * . Nodes of level i in the <code>tree</code> will be value objects that
     * are the property named <code>attribute_i</code> or all elements ( that
     * are value objects too) of collections that are the property named
     * <code>attribute_i</code>.</br>
     *
     * When called this method do for each elements of <code>trees</code>:</br>
     * 1- Object <code>storeVO</code> will be updated if <code>storeVO</code>
     * exists. If not it will be created.</br>
     * 2- For each elements of <code>trees</code>:</br>
     * 2.1- Each node of level i will be created or updated.</br>
     * 2.2- For each node of level i which <code>attribute_i+1</code> is a
     * collection, it will look in the underlying media store for all
     * objects</br>
     * represented by <code>attribute_i+1</code> related to the node of level i
     * being precesed and not present between his child: the found objects </br>
     * will be deleted from the media store.
     *
     *
     * @param storeVO:
     *            common root of trees
     * @param trees:
     *            collection of String. Each element is a dot separated list of
     *            attributes.
     * @return the same storeVO
     * @throws DataAccessException
     * @throws DataOptimisticLockException
     */
    public Object updateCreateTrees(Object storeVO, Collection trees) throws DataAccessException, DataOptimisticLockException;

    /***************************************/

    /**
     * This method determines which is the class of the value object reachable
     * walking through the <code>path<code> starting from <code>realClass<code>.
     * If <code>path<code> is null, a null is returned.</br>
     * If <code>path<code> is an empty string, or a black characters string the
     * same <code>realClass<code> is returned.</br>
     * If <code>path<code> leads to a collection of value objects, the class of
     * the elements of the collection is returned, and not the implementation
     * class of the collection </br>
     *
     * @param realClass
     *            Class where the <code>path<code> starts from to leave to the
     *            class to return.
     * @param path
     *            dot separated list of attributes that leads form the starting
     *            <code>realClass<code> to the class to return.
     * @return returns the value object class reached walking through the
     *         <code>path<code> starting from <code>realClass<code>
     * @throws DataAccessException
     *             - If <code>realClass<code> is null.</br>
     */
    public Class getClassFromPath(Class realClass, String path) throws DataAccessException;

    public Class getCollectionClassFromPath(Class realClass, String path) throws DataAccessException;

    public Vector getFksToItemClassInDecomposedRelationship(Class realClass, String oneToN, String MToOne) throws DataAccessException;

    public Object[] getKeyValues(Object pInstance) throws DataAccessException;

    public String[] getPkNames(Class realClass) throws DataAccessException;

    public String[] getFksToThisClass(Class realClass, String oneToN) throws DataAccessException;

    /**
     * This method returns the Vector holding all the foreign key attribute
     * names of the class that directly reference the value object that is
     * reached following <code>pAttributeName</code> from
     * <code>realClass</code>.</br>
     * The input parameter <code>pAttributeName</code> can be a direct attribute
     * of the class <code>realClass</code> or a dot separated list of attributes
     * that leaves from the class <code>realClass</code> to the value object
     * reference. </br>
     * If <code>pAttributeName</code> is a direct attribute of
     * <code>realClass</code> the attribute names to return are the one that
     * reference the value object represented by
     * <code>pAttributeName</code>.</br>
     * If <code>pAttributeName</code> is a dot separated list of attributes,
     * starting from <code>realClass</code> these attributes must lead to a
     * value object, and the foreign key attribute names of the last element
     * class on the path, that directly references to such value object, are the
     * ones to be returned.</br>
     * <code>pAttributeName</code> must always (directly or indirectly in the
     * case of dot separated list of attributes) reference a value object and
     * never a collection otherwise a DataAccessException is thrown If
     * <code>realClass</code> is null a DataAccessException is thrown.</br>
     * if <code>pAttributeName</code> is null or empty string or blank
     * characters string a null is returned
     *
     * @param realClass
     *            class holding the reference <code>pAttributeName</code>. It
     *            can't be null
     * @param pAttributeName
     *            attribute name of the value object which references to, have
     *            to be returned. If it is null or empty string or blank
     *            characters string a null is returned
     * @return foreign key field names, of the value object that directly points
     *         to the value object represented by <code>pAttributeName</code>
     * @throws DataAccessException
     *             - If <code>realClass</code> is null
     */
    public Vector getForeignKeyFields(Class realClass, String pAttributeName) throws DataAccessException;

    /**
     * This method returns a Vector holding all the attribute names of the class
     * of the items of the collection represented by
     * <code>pAttributeName</code>, attributes that represents the inverse
     * foreign keys to the main class holding the same collection.</br>
     * <code>pAttributeName</code> can be a direct attribute of the class
     * <code>realClass</code> or a dot separated list of attributes that leaves
     * from the class <code>realClass</code> to the collection whose foreign key
     * fields have to be returned.</br>
     * If <code>pAttributeName</code> is a direct attribute, the main class
     * holding the collection is the same <code>realClass</code>, otherwise the
     * main class will be the one of the penultimate attribute of the dot
     * separated list of attributes. </br>
     *
     * @param realClass
     *            class holding the collection whose foreign key fields have to
     *            be returned, or starting point of the path represented by
     *            <code>pAttributeName</code>, that leaves to such collection.
     * @param pAttributeName
     *            name of the attribute holding the collection whose foreign key
     *            fields have to be returned, or path leading to such collection
     *            from <code>realClass</code>
     * @return A vector holding the inverse foreing keys fields names of the
     *         items of the collection represented by
     *         <code>pAttributeName</code> to its main class.</br>
     * @throws DataAccessException
     *             -If <code>realClass</code> is null or
     *             <code>pAttributeName</code> is null or empty or blank
     *             characters string.</br>
     */
    public Vector getInverseForeignKeyFields(Class realClass, String pAttributeName) throws DataAccessException;

    /**
     *
     * @param pInstance
     * @param pAttributeName
     * @throws DataAccessException
     */
    public void setInverseForeignKeyFields(Object pInstance, String pAttributeName) throws DataAccessException;

    public Collection findCollectionByQueryString(String queryString, String parameterName, Object parameterValue) throws DataAccessException;

    public Collection findCollectionByQueryString(String queryString, Integer firstResult, Integer maxResults) throws DataAccessException;

    public void updateByNativeQueryString(String queryString) throws DataAccessException;

    public void updateByNativeQueryString(String queryString, Map parameters) throws DataAccessException;

    public Object findObjectByNativeQueryString(String queryString, Map parameters) throws DataAccessException;

    public Object findObjectByNativeQueryString(String queryString, String parameterName, Object parameterValue) throws DataAccessException;

}