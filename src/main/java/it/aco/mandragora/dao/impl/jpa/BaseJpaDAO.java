/* ====================================================================
 *		      GNU GENERAL PUBLIC LICENSE
 *		         Version 2, June 1991
 *
 *    Copyright (C) 1989, 1991 Free Software Foundation, Inc.
 *                        51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *    Everyone is permitted to copy and distribute verbatim copies
 *  of this license document, but changing it is not allowed.
 *
 *  			    Preamble
 *
 *    The licenses for most software are designed to take away your
 *  freedom to share and change it.  By contrast, the GNU General Public
 *  License is intended to guarantee your freedom to share and change free
 *  software--to make sure the software is free for all its users.  This
 *  General Public License applies to most of the Free Software
 *  Foundation's software and to any other program whose authors commit to
 *  using it.  (Some other Free Software Foundation software is covered by
 *  the GNU Library General Public License instead.)  You can apply it to
 *  your programs, too.
 *
 *    When we speak of free software, we are referring to freedom, not
 *  price.  Our General Public Licenses are designed to make sure that you
 *  have the freedom to distribute copies of free software (and charge for
 *  this service if you wish), that you receive source code or can get it
 *  if you want it, that you can change the software or use pieces of it
 *  in new free programs; and that you know you can do these things.
 *
 *     To protect your rights, we need to make restrictions that forbid
 *  anyone to deny you these rights or to ask you to surrender the rights.
 *  These restrictions translate to certain responsibilities for you if you
 *  distribute copies of the software, or if you modify it.
 *
 *     For example, if you distribute copies of such a program, whether
 *  gratis or for a fee, you must give the recipients all the rights that
 *  you have.  You must make sure that they, too, receive or can get the
 *  source code.  And you must show them these terms so they know their
 *  rights.
 *
 *     We protect your rights with two steps: (1) copyright the software, and
 *  (2) offer you this license which gives you legal permission to copy,
 *  distribute and/or modify the software.
 *
 *     Also, for each author's protection and ours, we want to make certain
 *  that everyone understands that there is no warranty for this free
 *  software.  If the software is modified by someone else and passed on, we
 *  want its recipients to know that what they have is not the original, so
 *  that any problems introduced by others will not reflect on the original
 *  authors' reputations.
 *
 *     Finally, any free program is threatened constantly by software
 *  patents.  We wish to avoid the danger that redistributors of a free
 *  program will individually obtain patent licenses, in effect making the
 *  program proprietary.  To prevent this, we have made it clear that any
 *  patent must be licensed for everyone's free use or not licensed at all.
 *
 *     The precise terms and conditions for copying, distribution and
 *  modification follow.
 *
 *	                	    GNU GENERAL PUBLIC LICENSE
 *       TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
 *
 *     0. This License applies to any program or other work which contains
 *  a notice placed by the copyright holder saying it may be distributed
 *  under the terms of this General Public License.  The "Program", below,
 *  refers to any such program or work, and a "work based on the Program"
 *  means either the Program or any derivative work under copyright law:
 *  that is to say, a work containing the Program or a portion of it,
 *  either verbatim or with modifications and/or translated into another
 *  language.  (Hereinafter, translation is included without limitation in
 *  the term "modification".)  Each licensee is addressed as "you".
 *
 *     Activities other than copying, distribution and modification are not
 *  covered by this License; they are outside its scope.  The act of
 *  running the Program is not restricted, and the output from the Program
 *  is covered only if its contents constitute a work based on the
 *  Program (independent of having been made by running the Program).
 *  Whether that is true depends on what the Program does.
 *
 *     1. You may copy and distribute verbatim copies of the Program's
 *  source code as you receive it, in any medium, provided that you
 *  conspicuously and appropriately publish on each copy an appropriate
 *  copyright notice and disclaimer of warranty; keep intact all the
 *  notices that refer to this License and to the absence of any warranty;
 *  and give any other recipients of the Program a copy of this License
 *  along with the Program.
 *
 *  You may charge a fee for the physical act of transferring a copy, and
 *  you may at your option offer warranty protection in exchange for a fee.
 *
 *     2. You may modify your copy or copies of the Program or any portion
 *  of it, thus forming a work based on the Program, and copy and
 *  distribute such modifications or work under the terms of Section 1
 *  above, provided that you also meet all of these conditions:
 *
 *        a) You must cause the modified files to carry prominent notices
 *     stating that you changed the files and the date of any change.
 *
 *        b) You must cause any work that you distribute or publish, that in
 *     whole or in part contains or is derived from the Program or any
 *     part thereof, to be licensed as a whole at no charge to all third
 *     parties under the terms of this License.
 *
 *        c) If the modified program normally reads commands interactively
 *     when run, you must cause it, when started running for such
 *     interactive use in the most ordinary way, to print or display an
 *     announcement including an appropriate copyright notice and a
 *     notice that there is no warranty (or else, saying that you provide
 *     a warranty) and that users may redistribute the program under
 *     these conditions, and telling the user how to view a copy of this
 *     License.  (Exception: if the Program itself is interactive but
 *     does not normally print such an announcement, your work based on
 *     the Program is not required to print an announcement.)
 *
 *     These requirements apply to the modified work as a whole.  If
 *  identifiable sections of that work are not derived from the Program,
 *  and can be reasonably considered independent and separate works in
 *  themselves, then this License, and its terms, do not apply to those
 *  sections when you distribute them as separate works.  But when you
 *  distribute the same sections as part of a whole which is a work based
 *  on the Program, the distribution of the whole must be on the terms of
 *  this License, whose permissions for other licensees extend to the
 *  entire whole, and thus to each and every part regardless of who wrote it.
 *
 *     Thus, it is not the intent of this section to claim rights or contest
 *  your rights to work written entirely by you; rather, the intent is to
 *  exercise the right to control the distribution of derivative or
 *  collective works based on the Program.
 *
 *     In addition, mere aggregation of another work not based on the Program
 *  with the Program (or with a work based on the Program) on a volume of
 *  a storage or distribution medium does not bring the other work under
 *  the scope of this License.
 *
 *      3. You may copy and distribute the Program (or a work based on it,
 *  under Section 2) in object code or executable form under the terms of
 *  Sections 1 and 2 above provided that you also do one of the following:
 *
 *        a) Accompany it with the complete corresponding machine-readable
 *     source code, which must be distributed under the terms of Sections
 *     1 and 2 above on a medium customarily used for software interchange; or,
 *
 *        b) Accompany it with a written offer, valid for at least three
 *     years, to give any third party, for a charge no more than your
 *     cost of physically performing source distribution, a complete
 *     machine-readable copy of the corresponding source code, to be
 *     distributed under the terms of Sections 1 and 2 above on a medium
 *     customarily used for software interchange; or,
 *
 *        c) Accompany it with the information you received as to the offer
 *     to distribute corresponding source code.  (This alternative is
 *     allowed only for noncommercial distribution and only if you
 *     received the program in object code or executable form with such
 *     an offer, in accord with Subsection b above.)
 *
 *  The source code for a work means the preferred form of the work for
 *  making modifications to it.  For an executable work, complete source
 *  code means all the source code for all modules it contains, plus any
 *  associated interface definition files, plus the scripts used to
 *  control compilation and installation of the executable.  However, as a
 *  special exception, the source code distributed need not include
 *  anything that is normally distributed (in either source or binary
 *  form) with the major components (compiler, kernel, and so on) of the
 *  operating system on which the executable runs, unless that component
 *  itself accompanies the executable.
 *
 *  If distribution of executable or object code is made by offering
 *  access to copy from a designated place, then offering equivalent
 *  access to copy the source code from the same place counts as
 *  distribution of the source code, even though third parties are not
 *  compelled to copy the source along with the object code.
 *
 *     4. You may not copy, modify, sublicense, or distribute the Program
 *  except as expressly provided under this License.  Any attempt
 *  otherwise to copy, modify, sublicense or distribute the Program is
 *  void, and will automatically terminate your rights under this License.
 *  However, parties who have received copies, or rights, from you under
 *  this License will not have their licenses terminated so long as such
 *  parties remain in full compliance.
 *
 *    5. You are not required to accept this License, since you have not
 *  signed it.  However, nothing else grants you permission to modify or
 *  distribute the Program or its derivative works.  These actions are
 *  prohibited by law if you do not accept this License.  Therefore, by
 *  modifying or distributing the Program (or any work based on the
 *  Program), you indicate your acceptance of this License to do so, and
 *  all its terms and conditions for copying, distributing or modifying
 *  the Program or works based on it.
 *
 *    6. Each time you redistribute the Program (or any work based on the
 *  Program), the recipient automatically receives a license from the
 *  original licensor to copy, distribute or modify the Program subject to
 *  these terms and conditions.  You may not impose any further
 *  restrictions on the recipients' exercise of the rights granted herein.
 *  You are not responsible for enforcing compliance by third parties to
 *  this License.
 *
 *    7. If, as a consequence of a court judgment or allegation of patent
 *  infringement or for any other reason (not limited to patent issues),
 *  conditions are imposed on you (whether by court order, agreement or
 *  otherwise) that contradict the conditions of this License, they do not
 *  excuse you from the conditions of this License.  If you cannot
 *  distribute so as to satisfy simultaneously your obligations under this
 *  License and any other pertinent obligations, then as a consequence you
 *  may not distribute the Program at all.  For example, if a patent
 *  license would not permit royalty-free redistribution of the Program by
 *  all those who receive copies directly or indirectly through you, then
 *  the only way you could satisfy both it and this License would be to
 *  refrain entirely from distribution of the Program.

 *  If any portion of this section is held invalid or unenforceable under
 *  any particular circumstance, the balance of the section is intended to
 *  apply and the section as a whole is intended to apply in other
 *  circumstances.

 *  It is not the purpose of this section to induce you to infringe any
 *  patents or other property right claims or to contest validity of any
 *  such claims; this section has the sole purpose of protecting the
 *  integrity of the free software distribution system, which is
 *  implemented by public license practices.  Many people have made
 *  generous contributions to the wide range of software distributed
 *  through that system in reliance on consistent application of that
 *  system; it is up to the author/donor to decide if he or she is willing
 *  to distribute software through any other system and a licensee cannot
 *  impose that choice.

 *  This section is intended to make thoroughly clear what is believed to
 *  be a consequence of the rest of this License.
 *
 *    8. If the distribution and/or use of the Program is restricted in
 *  certain countries either by patents or by copyrighted interfaces, the
 *  original copyright holder who places the Program under this License
 *  may add an explicit geographical distribution limitation excluding
 *  those countries, so that distribution is permitted only in or among
 *  countries not thus excluded.  In such case, this License incorporates
 *  the limitation as if written in the body of this License.
 *
 *    9. The Free Software Foundation may publish revised and/or new versions
 *  of the General Public License from time to time.  Such new versions will
 *  be similar in spirit to the present version, but may differ in detail to
 *  address new problems or concerns.
 *
 *  Each version is given a distinguishing version number.  If the Program
 *  specifies a version number of this License which applies to it and "any
 *  later version", you have the option of following the terms and conditions
 *  either of that version or of any later version published by the Free
 *  Software Foundation.  If the Program does not specify a version number of
 *  this License, you may choose any version ever published by the Free Software
 *  Foundation.

 *    10. If you wish to incorporate parts of the Program into other free
 *  programs whose distribution conditions are different, write to the author
 *  to ask for permission.  For software which is copyrighted by the Free
 *  Software Foundation, write to the Free Software Foundation; we sometimes
 *  make exceptions for this.  Our decision will be guided by the two goals
 *  vof preserving the free status of all derivatives of our free software and
 *  of promoting the sharing and reuse of software generally.
 *
 *  			    NO WARRANTY
 *
 *    11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
 *  FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
 *  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
 *  PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
 *  OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
 *  TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
 *  PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
 *  REPAIR OR CORRECTION.
 *
 *    12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
 *  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
 *  REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
 *  INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
 *  OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
 *  TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
 *  YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
 *  PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGES.
 *
 *  		     END OF TERMS AND CONDITIONS
 *
 *  	    How to Apply These Terms to Your New Programs
 *    If you develop a new program, and you want it to be of the greatest
 *  possible use to the public, the best way to achieve this is to make it
 *  free software which everyone can redistribute and change under these terms.
 *
 *    To do so, attach the following notices to the program.  It is safest
 *  to attach them to the start of each source file to most effectively
 *  convey the exclusion of warranty; and each file should have at least
 *  the "copyright" line and a pointer to where the full notice is found.
 *
 *      <one line to give the program's name and a brief idea of what it does.>
 *      Copyright (C) <year>  <name of author>
 *
 *      This program is free software; you can redistribute it and/or modify
 *      it under the terms of the GNU General Public License as published by
 *      the Free Software Foundation; either version 2 of the License, or
 *      (at your option) any later version.
 *
 *      This program is distributed in the hope that it will be useful,
 *      but WITHOUT ANY WARRANTY; without even the implied warranty of
 *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *      GNU General Public License for more details.
 *
 *      You should have received a copy of the GNU General Public License
 *      along with this program; if not, write to the Free Software
 *      Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *
 *
 *  Also add information on how to contact you by electronic and paper mail.
 *
 *  If the program is interactive, make it output a short notice like this
 *  when it starts in an interactive mode:
 *
 *      Gnomovision version 69, Copyright (C) year name of author
 *      Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
 *      This is free software, and you are welcome to redistribute it
 *      under certain conditions; type `show c' for details.
 *
 *  The hypothetical commands `show w' and `show c' should show the appropriate
 *  parts of the General Public License.  Of course, the commands you use may
 *  be called something other than `show w' and `show c'; they could even be
 *  mouse-clicks or menu items--whatever suits your program.
 *
 *  You should also get your employer (if you work as a programmer) or your
 *  school, if any, to sign a "copyright disclaimer" for the program, if
 *  necessary.  Here is a sample; alter the names:
 *
 *    Yoyodyne, Inc., hereby disclaims all copyright interest in the program
 *    `Gnomovision' (which makes passes at compilers) written by James Hacker.
 *
 *    <signature of Ty Coon>, 1 April 1989
 *    Ty Coon, President of Vice

 *  This General Public License does not permit incorporating your program into
 *  proprietary programs.  If your program is a subroutine library, you may
 *  consider it more useful to permit linking proprietary applications with the
 *  library.  If this is what you want to do, use the GNU Library General
 *  Public License instead of this License.

*/

package it.aco.mandragora.dao.impl.jpa;

import java.lang.annotation.Annotation;
import java.lang.reflect.AccessibleObject;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Vector;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.persistence.AssociationOverride;
import javax.persistence.AssociationOverrides;
import javax.persistence.AttributeOverride;
import javax.persistence.AttributeOverrides;
import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.EmbeddedId;
import javax.persistence.Entity;
import javax.persistence.EntityManager;
import javax.persistence.EntityNotFoundException;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.ManyToOne;
import javax.persistence.NoResultException;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.OptimisticLockException;
import javax.persistence.Query;
import javax.persistence.Transient;

import org.apache.commons.beanutils.BeanUtilsBean;
import org.apache.commons.beanutils.NestedNullException;
import org.apache.commons.beanutils.PropertyUtilsBean;
import org.apache.commons.lang.StringUtils;

import it.aco.mandragora.bo.Graph;
import it.aco.mandragora.common.Cursor;
import it.aco.mandragora.common.Node;
import it.aco.mandragora.common.Utils;
import it.aco.mandragora.common.utils.BeanCollectionUtils;
import it.aco.mandragora.common.utils.PersistenceUtil;
import it.aco.mandragora.comparator.FieldComparator;
import it.aco.mandragora.dao.DAO;
import it.aco.mandragora.exception.DataAccessException;
import it.aco.mandragora.exception.DataOptimisticLockException;
import it.aco.mandragora.query.LogicCondition;
import it.aco.mandragora.query.LogicSqlCondition;
import it.aco.mandragora.query.Operator;
import it.aco.mandragora.query.SimpleCondition;

public abstract class BaseJpaDAO implements DAO {

    // protected EntityManager entityManager;

    protected Integer inLimit = 1000;

    protected boolean flush = false;

    static private org.apache.log4j.Category log = org.apache.log4j.Logger.getLogger(BaseJpaDAO.class.getName());

    protected abstract EntityManager getEntityManager();

    protected abstract void setEntityManager(EntityManager entityManager);

    protected final static int ONE_TO_ONE = 0;
    protected final static int ONE_TO_N = 1;
    protected final static int M_TO_N = 2;
    protected final static int M_TO_ONE = 3; // added alessandro 19-03-2011
    protected final static int M_TO_N_INVERSE = 4; // added alessandro
						   // 09-08-2012
    protected final static int EMBEDDED_ID = 5; // added alessandro 10-08-2012

    protected final String joinPrefix = "bbb";

    public Object findByPrimaryKey(Class realClass, Object[] pkValues) throws DataAccessException {
	log.info("************Entering ***************");
	Object result = null;
	try {
	    result = findByPrimaryKey(realClass, null, pkValues);
	} catch (final Exception e) {
	    log.error("Exception caught in   BaseJpaDAO.findByPrimaryKey(Class realClass, Object[] pkValues): " + e.toString());
	    throw new DataAccessException("Error in   BaseJpaDAO.findByPrimaryKey(Class realClass, Object[] pkValues): " + e.toString(), e);
	}
	log.info("************Done***************");
	return result;
    }

    private boolean isEntityClass(Object object) throws DataAccessException {
	try {
	    return PersistenceUtil.getEntityClass(object).isAnnotationPresent(Entity.class);
	} catch (final Exception e) {
	    log.error("Exception caught in   BaseJpaDAO.isEntityClass(Object object): " + e.toString());
	    throw new DataAccessException("Error in   BaseJpaDAO.isEntityClass(Object object): " + e.toString(), e);
	}
    }

    // private Object buildPKValue(Class realClass,Object[] pkValues, int
    // pkIndex) throws DataAccessException{
    private Object buildPKValue(Class realClass, Object[] pkValues, Cursor pkIndex) throws DataAccessException {
	Object pkValue = null;

	try {
	    if (pkValues == null || pkValues.length == 0) {
		throw new DataAccessException("Error in  BaseJpaDAO.buildPKValue(Class realClass,Object[] pkValues, Cursor pkIndex): pkValues can't be null or empty ");
	    }

	    final AccessibleObject accessibleObject = getEmbeddedIdOrIdAnnotatedAccessibleObject(realClass);

	    if (accessibleObject == null) {
		throw new DataAccessException("Error in  BaseJpaDAO.buildPKValue(Class realClass,Object[] pkValues, Cursor pkIndex): No EmbeddedId and No Id annotation found ");
	    }

	    if (accessibleObject.isAnnotationPresent(EmbeddedId.class)) {

		final PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();

		AttributeOverrides attributeOverrides = null;
		AssociationOverrides associationOverrides = null;

		Class idClass = null;
		// String embeddedIdFieldName=null;

		if (Field.class.isInstance(accessibleObject)) {
		    // idClass= ((Field)accessibleObject).getClass();
		    idClass = ((Field) accessibleObject).getType();
		    // embeddedIdFieldName=((Field)accessibleObject).getName();
		} else if (Method.class.isInstance(accessibleObject)) {
		    idClass = ((Method) accessibleObject).getReturnType();
		    // String idGetterName=((Method)accessibleObject).getName();
		    // embeddedIdFieldName =
		    // idGetterName.substring(3,3).toLowerCase()+idGetterName.substring(4);
		} else {
		    throw new DataAccessException("Error in  BaseJpaDAO.buildPKValue(Class realClass,Object[] pkValues, Cursor pkIndex):accessibleObject is not Field and not Method instance");
		}
		// Object id =
		// idClass.getConstructor((Class)null).newInstance((Object)null);
		// Object id = idClass.getConstructor().newInstance();
		pkValue = idClass.getConstructor().newInstance();

		final Annotation[] accessibleObjectAnnotations = accessibleObject.getAnnotations();
		for (int i = 0; i < accessibleObjectAnnotations.length && pkValue != null; i++) {
		    if (accessibleObjectAnnotations[i].annotationType().equals(AttributeOverrides.class)) {
			attributeOverrides = accessibleObject.getAnnotation(AttributeOverrides.class);
			final AttributeOverride[] attributeOverrideArray = attributeOverrides.value();
			for (final AttributeOverride attributeOverride : attributeOverrideArray) {
			    propertyUtilsBean.setProperty(pkValue, attributeOverride.name(), pkValues[pkIndex.getValue()]);
			    pkIndex.increment();
			}

		    } else if (accessibleObjectAnnotations[i].annotationType().equals(AssociationOverrides.class)) {
			associationOverrides = accessibleObject.getAnnotation(AssociationOverrides.class);
			final AssociationOverride[] associationOverrideArray = associationOverrides.value();
			for (final AssociationOverride associationOverride : associationOverrideArray) {
			    if (isEntityClass(pkValues[pkIndex.getValue()])) {
				if (isPersisted(pkValues[pkIndex.getValue()])) {// condition
										// and
										// else
										// added
										// alessandro
										// on
										// 12/8/2012
				    propertyUtilsBean.setProperty(pkValue, associationOverride.name(), pkValues[pkIndex.getValue()]);
				    pkIndex.increment();
				} else {
				    pkValue = null;
				}
			    } else {
				final Object associationPKValue = buildPKValue(idClass.getDeclaredField(associationOverride.name()).getType(), pkValues, pkIndex);
				if (associationPKValue != null) {// condition
								 // and else
								 // added
								 // alessandro
								 // on 12/8/2012
				    final Class accociationClass = idClass.getDeclaredField(associationOverride.name()).getType();
				    /*
				     * deleted alessandro on 5/8/2012 Object
				     * accociationValue =
				     * accociationClass.getConstructor().
				     * newInstance(); String accociationIdName=
				     * (new
				     * EntityInfo(accociationClass)).getIdField(
				     * ).getName();
				     * propertyUtilsBean.setProperty(
				     * accociationValue,accociationIdName,
				     * associationPKValue);
				     */
				    final Object accociationValue = findByPrimaryKey(accociationClass, associationPKValue);// added
															   // alessandro
															   // on
															   // 5/8/2012
				    if (accociationValue != null) {// condition
								   // and else
								   // added
								   // alessandro
								   // on
								   // 12/8/2012
					propertyUtilsBean.setProperty(pkValue, associationOverride.name(), accociationValue);
				    } else {
					pkValue = null;
				    }
				} else {
				    pkValue = null;
				}
			    }

			}
		    }
		}

	    } else if (accessibleObject.isAnnotationPresent(Id.class)) {
		pkValue = pkValues[pkIndex.getValue()];
		pkIndex.increment();
	    } else {
		throw new DataAccessException("Error in buildPKValue(Class realClass,Object[] pkValues, Cursor pkIndex): accessibleObject has no EmbeddedId and No Id annotation ");
	    }
	} catch (final IllegalArgumentException e) {
	    log.error("IllegalArgumentException caught in   BaseJpaDAO.buildPKValue(Class realClass,Object[] pkValues, Cursor pkIndex): " + e.toString());
	    throw new DataAccessException("Error in   BaseJpaDAO.buildPKValue(Class realClass,Object[] pkValues, Cursor pkIndex): " + e.toString(), e);
	} catch (final SecurityException e) {
	    log.error("SecurityException caught in   BaseJpaDAO.buildPKValue(Class realClass,Object[] pkValues, Cursor pkIndex): " + e.toString());
	    throw new DataAccessException("Error in   BaseJpaDAO.buildPKValue(Class realClass,Object[] pkValues, Cursor pkIndex): " + e.toString(), e);
	} catch (final InstantiationException e) {
	    log.error("InstantiationException caught in   BaseJpaDAO.buildPKValue(Class realClass,Object[] pkValues, Cursor pkIndex): " + e.toString());
	    throw new DataAccessException("Error in   BaseJpaDAO.buildPKValue(Class realClass,Object[] pkValues, Cursor pkIndex): " + e.toString(), e);
	} catch (final IllegalAccessException e) {
	    log.error("IllegalAccessException caught in   BaseJpaDAO.buildPKValue(Class realClass,Object[] pkValues, Cursor pkIndex): " + e.toString());
	    throw new DataAccessException("Error in   BaseJpaDAO.buildPKValue(Class realClass,Object[] pkValues, Cursor pkIndex): " + e.toString(), e);
	} catch (final InvocationTargetException e) {
	    log.error("InvocationTargetException caught in   BaseJpaDAO.buildPKValue(Class realClass,Object[] pkValues, Cursor pkIndex): " + e.toString());
	    throw new DataAccessException("Error in   BaseJpaDAO.buildPKValue(Class realClass,Object[] pkValues, Cursor pkIndex): " + e.toString(), e);
	} catch (final NoSuchMethodException e) {
	    log.error("NoSuchMethodException caught in   BaseJpaDAO.buildPKValue(Class realClass,Object[] pkValues, Cursor pkIndex): " + e.toString());
	    throw new DataAccessException("Error in   BaseJpaDAO.buildPKValue(Class realClass,Object[] pkValues, Cursor pkIndex): " + e.toString(), e);
	} catch (final NoSuchFieldException e) {
	    log.error("NoSuchFieldException caught in   BaseJpaDAO.buildPKValue(Class realClass,Object[] pkValues, Cursor pkIndex): " + e.toString());
	    throw new DataAccessException("Error in   BaseJpaDAO.buildPKValue(Class realClass,Object[] pkValues, Cursor pkIndex): " + e.toString(), e);
	} catch (final Exception e) {
	    log.error("Exception caught in   BaseJpaDAO.buildPKValue(Class realClass,Object[] pkValues, Cursor pkIndex): " + e.toString());
	    throw new DataAccessException("Error in   BaseJpaDAO.buildPKValue(Class realClass,Object[] pkValues, Cursor pkIndex): " + e.toString(), e);
	}

	return pkValue;

    }

    public Object findByPrimaryKey(Class realClass, String[] pkFieldNames, Object[] pkValues) throws DataAccessException {
	log.info("************Entering the BaseOjbPbDAO.findByPrimaryKey(Class realClass,String[] pkFieldNames, Object[] pkValues) ***************");
	Object result = null;
	try {
	    if (pkValues == null || pkValues.length == 0) {
		throw new DataAccessException("Error in  BaseJpaDAO.findByPrimaryKey(Class realClass,String[] pkFieldNames, Object[] pkValues): pkValues can't be null or empty ");
	    }
	    if (pkFieldNames != null && pkFieldNames.length != pkValues.length) {
		throw new DataAccessException("Error in  BaseJpaDAO.findByPrimaryKey(Class realClass,String[] pkFieldNames, Object[] pkValues): pkFieldNames.length!=pkValues.length ");
	    }

	    if (pkValues.length == 1) {
		// result = getEntityManager().find(realClass, pkValues[0]);
		result = findByPrimaryKey(realClass, pkValues[0]);
	    } else if (pkFieldNames != null && pkFieldNames.length > 0) {

		// PropertyUtilsBean propertyUtilsBean =
		// BeanUtilsBean.getInstance().getPropertyUtils();
		final Node pkFieldNameNode = new Node(pkFieldNames);

		if (pkFieldNameNode.getChildren().entrySet().size() != 1) {
		    throw new DataAccessException("Error in  BaseJpaDAO.findByPrimaryKey(Class realClass,String[] pkFieldNames, Object[] pkValues): pkFieldNameNode entry size is not 1 ");
		}
		final String firstPkFieldName = pkFieldNameNode.getChildren().keySet().iterator().next();
		final Object pkValue = realClass.getDeclaredField(firstPkFieldName).getType().getConstructor().newInstance();

		// BeanCollectionUtils.setAttribute(pkValue,
		// pkFieldNameNode.getChildren().get(firstPkFieldName),
		// pkValues);
		for (int i = 0; i < pkFieldNames.length; i++) {
		    BeanCollectionUtils.setAttribute(pkValue, pkFieldNames[i].substring(pkFieldNames[i].indexOf(".") + 1), pkValues[i]);

		}

		// result = getEntityManager().find(realClass, pkValue);
		result = findByPrimaryKey(realClass, pkValue);

	    } else {
		// result = getEntityManager().find(realClass,
		// buildPKValue(realClass, pkValues, new Cursor()));
		final Object pKValue = buildPKValue(realClass, pkValues, new Cursor());
		if (pKValue != null) {// condition added by alessandro on
				      // 12/08/2012
		    result = findByPrimaryKey(realClass, buildPKValue(realClass, pkValues, new Cursor()));
		}
	    }
	} catch (final Exception e) {
	    log.error("Exception caught in   BaseJpaDAO.findByPrimaryKey(Class realClass,String[] pkFieldNames, Object[] pkValues): " + e.toString());
	    throw new DataAccessException("Error in   BaseJpaDAO.findByPrimaryKey(Class realClass,String[] pkFieldNames, Object[] pkValues): " + e.toString(), e);
	}
	log.info("************Done with the  BaseOjbPbDAO.findByPrimaryKey(Class realClass,String[] pkFieldNames, Object[] pkValues)***************");
	return result;
    }

    public Object findByPrimaryKey(Class realClass, Object pkValue) throws DataAccessException {
	log.info("************Entering  ***************");
	Object result = null;
	try {

	    try {
		result = getEntityManager().find(realClass, pkValue);
	    } catch (final EntityNotFoundException e) {
		result = null;
	    }

	} catch (final Exception e) {
	    log.error("Exception caught : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.findByPrimaryKey(Class realClass, Object pkValue): " + e.toString(), e);
	}
	log.info("************ Done ***************");
	return result;
    }

    public Object findObjectByTemplate(Object templateVO) throws DataAccessException {
	log.info("************Entering***************");
	Object result = null;

	try {
	    final Collection temp = findCollectionByTemplate(templateVO, 0, 1, null);
	    if (temp != null && temp.size() > 0) {
		result = temp.iterator().next();
	    }
	} catch (final Exception e) {
	    log.error("Exception caught : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.findObjectByTemplate(Object templateVO): " + e.toString(), e);
	}

	log.info("************Done ***************");
	return result;
    }

    public Object findObjectByQueryString(String queryString, Map parameters) throws DataAccessException {
	log.debug("************Entering ***************");
	Object result = null;
	try {

	    final Query query = getEntityManager().createQuery(queryString);

	    setQueryParameters(query, parameters);
	    result = query.getSingleResult();

	} catch (final NoResultException e) {
	    /**
	     * NADA result queda null
	     */
	} catch (final Exception e) {
	    log.error("Exception caught  : " + e.toString());
	    throw new DataAccessException("Error in  BaseJPADAO.findCollectionByQueryString(String queryString, Map parameters) : " + e.toString(), e);
	}
	log.debug("************Done **************");
	return result;
    }

    public Object findObjectByQueryString(String queryString) throws DataAccessException {
	log.debug("************Entering ***************");
	Object result = null;
	try {

	    final Query query = getEntityManager().createQuery(queryString);

	    result = query.getSingleResult();

	} catch (final NoResultException e) {
	    /**
	     * NADA result queda null
	     */
	} catch (final Exception e) {
	    log.error("Exception caught  : " + e.toString());
	    throw new DataAccessException("Error in  BaseJPADAO.findCollectionByQueryString(String queryString, Map parameters) : " + e.toString(), e);
	}
	log.debug("************Done **************");
	return result;
    }

    public Object findObjectByQueryString(String queryString, String parameterName, Object parameterValue) throws DataAccessException {
	log.debug("************Entering ***************");
	Object result = null;
	try {

	    final HashMap parameters = new HashMap();
	    parameters.put(parameterName, parameterValue);
	    result = findObjectByQueryString(queryString, parameters);
	} catch (final NoResultException e) {
	    /**
	     * NADA result queda null
	     */
	} catch (final Exception e) {
	    log.error("Exception caught  : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.findCollectionByQueryString(String queryString, String parameterName, Object parameterValue) : " + e.toString(), e);
	}
	log.debug("************Done **************");
	return result;
    }

    public Collection findCollectionByQueryString(String queryString) throws DataAccessException {
	log.debug("************Entering ***************");
	Collection result;
	try {
	    queryString = translateIn(queryString);// added alessandro
						   // 21-mar-2010
	    final Query query = getEntityManager().createQuery(queryString);
	    result = query.getResultList();

	} catch (final Exception e) {
	    log.error("Exception caught  : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.findCollectionByQueryString(String queryString) : " + e.toString(), e);
	}
	log.debug("************Done **************");
	return result;
    }

    public Collection findCollectionByQueryString(String queryString, String parameterName, Object parameterValue) throws DataAccessException {
	log.debug("************Entering ***************");
	Collection result;
	try {

	    final HashMap parameters = new HashMap();
	    parameters.put(parameterName, parameterValue);
	    result = findCollectionByQueryString(queryString, parameters);
	} catch (final Exception e) {
	    log.error("Exception caught  : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.findCollectionByQueryString(String queryString, String parameterName, Object parameterValue) : " + e.toString(), e);
	}
	log.debug("************Done **************");
	return result;
    }

    public Collection findCollectionByQueryString(String queryString, Integer firstResult, Integer maxResults) throws DataAccessException {
	return findCollectionByQueryString(queryString, new HashMap(), firstResult, maxResults);
    }

    public Collection findCollectionByQueryString(String queryString, Map parameters, Integer firstResult, Integer maxResults) throws DataAccessException {
	log.debug("************Entering ***************");
	Collection result;
	try {
	    /*
	     * queryString = translateInAll(queryString, parameters);// added //
	     * alessandro // 21-mar-2010
	     *
	     */
	    final Query query = getEntityManager().createQuery(queryString);

	    setQueryParameters(query, parameters);
	    if (firstResult != null) {
		query.setFirstResult(firstResult.intValue());
	    }
	    if (maxResults != null) {
		query.setMaxResults(maxResults.intValue());
	    }
	    result = query.getResultList();

	} catch (final Exception e) {
	    log.error("Exception caught  : " + e.toString());
	    throw new DataAccessException("Error in  BaseJPADAO.findCollectionByQueryString(String queryString, Map parameters,Integer firstResult, Integer maxResults) : " + e.toString(), e);
	}
	log.debug("************Done **************");
	return result;
    }

    public Collection findCollectionByQueryString(String queryString, Map parameters) throws DataAccessException {
	log.debug("************Entering ***************");
	Collection result;
	try {
	    queryString = translateInAll(queryString, parameters);// added
								  // alessandro
								  // 21-mar-2010
	    final Query query = getEntityManager().createQuery(queryString);

	    setQueryParameters(query, parameters);
	    result = query.getResultList();

	} catch (final Exception e) {
	    log.error("Exception caught  : " + e.toString());
	    throw new DataAccessException("Error in  BaseJPADAO.findCollectionByQueryString(String queryString, Map parameters) : " + e.toString(), e);
	}
	log.debug("************Done **************");
	return result;
    }

    public Collection findCollectionByNativeQueryString(String queryString) throws DataAccessException {
	log.debug("************Entering ***************");
	Collection result;
	try {
	    final Query query = getEntityManager().createNativeQuery(queryString);
	    result = query.getResultList();

	} catch (final Exception e) {
	    log.error("Exception caught  : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.findCollectionByNativeQueryString(String queryString) : " + e.toString(), e);
	}
	log.debug("************Done **************");
	return result;
    }

    public Collection findCollectionByNativeQueryString(String queryString, String parameterName, Object parameterValue) throws DataAccessException {
	log.debug("************Entering ***************");
	Collection result;
	try {

	    final HashMap parameters = new HashMap();
	    parameters.put(parameterName, parameterValue);
	    result = findCollectionByNativeQueryString(queryString, parameters);
	} catch (final Exception e) {
	    log.error("Exception caught  : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.findCollectionByNativeQueryString(String queryString, String parameterName, Object parameterValue) : " + e.toString(), e);
	}
	log.debug("************Done **************");
	return result;
    }

    public Collection findCollectionByNativeQueryString(String queryString, Map parameters) throws DataAccessException {
	log.debug("************Entering ***************");
	Collection result;
	try {
	    final Query query = getEntityManager().createNativeQuery(queryString);

	    setQueryParameters(query, parameters);
	    result = query.getResultList();

	} catch (final Exception e) {
	    log.error("Exception caught  : " + e.toString());
	    throw new DataAccessException("Error in  BaseJPADAO.findCollectionByNativeQueryString(String queryString, Map parameters) : " + e.toString(), e);
	}
	log.debug("************Done **************");
	return result;
    }

    public Object findObjectByNativeQueryString(String queryString, Map parameters) throws DataAccessException {
	log.debug("************Entering ***************");
	Object result;
	try {
	    final Query query = getEntityManager().createNativeQuery(queryString);
	    setQueryParameters(query, parameters);
	    result = query.getSingleResult();

	} catch (final NoResultException e) {
	    result = null;
	} catch (final Exception e) {
	    log.error("Exception caught  : " + e.toString());
	    throw new DataAccessException("Error in  BaseJPADAO : " + e.toString(), e);
	}
	log.debug("************Done **************");
	return result;
    }

    public Object findObjectByNativeQueryString(String queryString, String parameterName, Object parameterValue) throws DataAccessException {
	log.debug("************Entering ***************");
	Object result;
	try {
	    final Query query = getEntityManager().createNativeQuery(queryString);

	    final HashMap parameters = new HashMap();
	    parameters.put(parameterName, parameterValue);
	    setQueryParameters(query, parameters);
	    result = query.getSingleResult();

	} catch (final NoResultException e) {
	    result = null;
	} catch (final Exception e) {
	    log.error("Exception caught  : " + e.toString());
	    throw new DataAccessException("Error in  BaseJPADAO.findCollectionByNativeQueryString(String queryString, Map parameters) : " + e.toString(), e);
	}
	log.debug("************Done **************");
	return result;
    }

    public Collection findCollectionByTemplate(Object templateVO, Integer firstResult, Integer maxResults, String orderingField) throws DataAccessException {
	log.info("************Entering ***************");
	Collection result = null;

	final PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();

	try {
	    final Map m = propertyUtilsBean.describe(templateVO);
	    final Map parameters = new HashMap();
	    // String queryString = "SELECT c FROM " +
	    // templateVO.getClass().getSimpleName() + " c ";
	    String queryString = "SELECT c FROM " + getEntityClass(templateVO).getSimpleName() + " c ";
	    String whereCondition = "";
	    if (m != null) {
		int i = 0;
		for (final Object key : m.keySet()) {
		    // if (!key.equals("class") &&
		    // getAnnotation(templateVO.getClass(), key.toString(),
		    // Transient.class)==null) {
		    if (!key.equals("class") && getAnnotation(getEntityClass(templateVO), key.toString(), Transient.class) == null) {
			final Object value = m.get(key);

			if (value != null) {
			    final String lastToken = Utils.getExceptLastTokenAndLastToken((String) key)[1];
			    // ConvertUtils.convert(m.get(key),
			    // propertyUtilsBean.getPropertyType(templateVO,
			    // key.toString()));
			    whereCondition += " c." + key + " = :" + lastToken + i + " AND";
			    parameters.put(lastToken + i, value);
			    i++;
			}
		    }
		}
		if (!whereCondition.trim().equals("")) {
		    whereCondition = whereCondition.substring(0, whereCondition.lastIndexOf("AND"));
		    queryString += " WHERE " + whereCondition;
		}
		if (orderingField != null && !orderingField.trim().equals("")) {
		    queryString += " ORDER BY " + orderingField;
		}

		final Query query = getEntityManager().createQuery(queryString);

		setQueryParameters(query, parameters);
		if (firstResult != null) {
		    query.setFirstResult(firstResult.intValue());
		}
		if (maxResults != null) {
		    query.setMaxResults(maxResults.intValue());
		}
		result = query.getResultList();

	    }
	} catch (final IllegalAccessException e) {
	    log.error("IllegalAccessException caught : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.findCollectionByTemplate(Object templateVO, Integer firstResult, Integer maxResults, String orderingField): " + e.toString(), e);
	} catch (final InvocationTargetException e) {
	    log.error("InvocationTargetException caught : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.findCollectionByTemplate(Object templateVO, Integer firstResult, Integer maxResults, String orderingField): " + e.toString(), e);
	} catch (final NoSuchMethodException e) {
	    log.error("NoSuchMethodException caught : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.findCollectionByTemplate(Object templateVO, Integer firstResult, Integer maxResults, String orderingField): " + e.toString(), e);
	} catch (final Exception e) {
	    log.error("Exception caught : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.findCollectionByTemplate(Object templateVO, Integer firstResult, Integer maxResults, String orderingField): " + e.toString(), e);
	}

	log.info("************Done   ***************");
	return result;
    }

    public Collection findCollectionByTemplate(Object templateVO) throws DataAccessException {
	log.info("************Entering ***************");
	Collection result = null;

	try {
	    result = findCollectionByTemplate(templateVO, null, null, null);
	} catch (final Exception e) {
	    log.error("Exception caught : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.findCollectionByTemplate(Object templateVO): " + e.toString(), e);
	}

	log.info("************Done ***************");
	return result;
    }

    public Collection findCollectionByTemplate(Object templateVO, String orderingField, Boolean asc) throws DataAccessException {
	log.info("************Entering ***************");
	Collection result = null;

	try {
	    String order = null;
	    if (orderingField != null && !orderingField.trim().equals("")) {
		if (asc != null) {
		    if (asc) {
			order = orderingField + " ASC";
		    } else {
			order = orderingField + " DESC";
		    }
		}
	    }

	    result = findCollectionByTemplate(templateVO, null, null, order);
	} catch (final Exception e) {
	    log.error("Exception caught : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.findCollectionByTemplate(Object templateVO, String orderingField, Boolean asc): " + e.toString(), e);
	}

	log.info("************Done ***************");
	return result;
    }

    public Collection findCollectionByNullFields(Class realClass, String[] nullFields) throws DataAccessException {
	log.info("************Entering ***************");
	Collection result = null;

	try {
	    String queryString = "SELECT c FROM " + realClass.getSimpleName() + " c ";
	    String whereCondition = "";
	    if (nullFields != null) {
		for (final String nullField : nullFields) {
		    whereCondition += " c." + nullField + " IS  NULL AND";
		}
	    }
	    if (!whereCondition.equals("")) {
		whereCondition = whereCondition.substring(0, whereCondition.lastIndexOf("AND"));
		queryString += " WHERE " + whereCondition;
	    }
	    log.debug("queryString is " + queryString);
	    final Query query = getEntityManager().createQuery(queryString);
	    result = query.getResultList();
	} catch (final Exception e) {
	    log.error("Exception caught : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.findCollectionByNullFields(Class realClass, String[] nullFields) : " + e.toString(), e);
	}
	log.info("************Done **************");
	return result;
    }

    public Object findObjectByLogicCondition(java.lang.Class realClass, LogicCondition logicCondition) throws DataAccessException {
	log.debug("************Entering ***************");
	Object result;
	try {

	    // Query query = createQuery(realClass, logicCondition);
	    // result = query.getSingleResult();
	    result = findObjectByLogicCondition(null, realClass, logicCondition, null);

	} catch (final Exception e) {
	    log.error("Exception caught  : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.findObjectByLogicCondition(java.lang.Class realClass, LogicCondition logicCondition) : " + e.toString(), e);
	}
	log.info("************Done **************");
	return result;
    }

    public Object findObjectByLogicCondition(String[] selectFields, java.lang.Class realClass, LogicCondition logicCondition) throws DataAccessException {
	log.debug("************Entering ***************");
	Object result;
	try {

	    // Query query = createQuery(selectFields, realClass,
	    // logicCondition);
	    // result = query.getSingleResult();
	    result = findObjectByLogicCondition(selectFields, realClass, logicCondition, null);

	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.findObjectByLogicCondition(String[]selectFields, java.lang.Class realClass, LogicCondition logicCondition) : " + e.toString(), e);
	}
	log.info("************Done **************");
	return result;
    }

    public Object findObjectByLogicCondition(String[] selectFields, java.lang.Class realClass, LogicCondition logicCondition, String orderBy) throws DataAccessException {
	log.debug("************Entering ***************");
	Object result = null;
	try {

	    final Query query = createQuery(null, selectFields, realClass, logicCondition, orderBy);
	    result = query.getSingleResult();
	    // Collection collectionResult = query.getResultList();
	    // if(collectionResult!=null && !collectionResult.isEmpty()){
	    // result=collectionResult.iterator().next();
	    // }

	} catch (final NoResultException e) {
	    return null;
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException(
		    "Error in  BaseJpaDAO.findObjectByLogicCondition(String[]selectFields, java.lang.Class realClass, LogicCondition logicCondition, String orderBy) : " + e.toString(), e);
	}
	log.info("************Done **************");
	return result;
    }

    public Object findObjectByLogicCondition(java.lang.Class realClass, LogicCondition logicCondition, String orderBy) throws DataAccessException {
	log.debug("************Entering ***************");
	Object result;
	try {

	    // Query query = createQuery(null, null, realClass, logicCondition,
	    // orderBy);
	    // result = query.getSingleResult();
	    result = findObjectByLogicCondition(null, realClass, logicCondition, orderBy);

	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.findObjectByLogicCondition(java.lang.Class realClass, LogicCondition logicCondition, String orderBy) : " + e.toString(), e);
	}
	log.info("************Done **************");
	return result;
    }

    public Collection findCollectionByLogicCondition(java.lang.Class realClass, LogicCondition logicCondition) throws DataAccessException {
	log.debug("************Entering ***************");
	Collection result;
	try {

	    final Query query = createQuery(realClass, logicCondition);
	    result = query.getResultList();

	} catch (final NoResultException e) {
	    result = null;
	} catch (final Exception e) {
	    log.error("Exception caught  : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.findCollectionByLogicCondition(java.lang.Class realClass, LogicCondition logicCondition) : " + e.toString(), e);
	}
	log.info("************Done **************");
	return result;
    }

    public Collection findCollectionByLogicCondition(Class realClass, LogicCondition logicCondition, String orderingField, Boolean asc, Integer startAtIndex, Integer maxResults)
	    throws DataAccessException {
	log.info("************Entering ***************");
	Collection result = null;

	try {
	    String orderBy = null;
	    if (orderingField != null && !orderingField.trim().equals("")) {
		if (asc != null) {
		    if (asc) {
			orderBy = orderingField + " ASC";
		    } else {
			orderBy = orderingField + " DESC";
		    }
		}
	    }
	    // Integer maxResults = null;
	    // if(startAtIndex!=null && endAtIndex!=null)
	    // maxResults=endAtIndex-startAtIndex;

	    // result = findCollectionByLogicCondition(realClass,
	    // logicCondition, orderBy, startAtIndex, endAtIndex-startAtIndex);
	    result = findCollectionByLogicCondition(realClass, logicCondition, orderBy, startAtIndex, maxResults);
	} catch (final Exception e) {
	    log.error("Exception caught  : " + e.toString());
	    throw new DataAccessException(
		    "Error in  BaseJpaDAO.findCollectionByLogicCondition(Class realClass,LogicCondition logicCondition,String orderingField, Boolean asc,Integer startAtIndex, Integer endAtIndex) : "
			    + e.toString(),
		    e);
	}

	log.info("************Done ***************");
	return result;
    }

    public Collection findCollectionByLogicCondition(String[] selectFields, java.lang.Class realClass, LogicCondition logicCondition) throws DataAccessException {
	log.debug("************Entering ***************");
	Collection result;
	try {

	    final Query query = createQuery(selectFields, realClass, logicCondition);
	    result = query.getResultList();

	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.findCollectionByLogicCondition(String[]selectFields, java.lang.Class realClass, LogicCondition logicCondition) : " + e.toString(), e);
	}
	log.info("************Done **************");
	return result;
    }

    public Collection findCollectionByLogicCondition(String[] selectFields, java.lang.Class realClass, LogicCondition logicCondition, String orderBy) throws DataAccessException {
	log.debug("************Entering ***************");
	Collection result;
	try {

	    // Query query = createQuery(selectFields, realClass,
	    // logicCondition, orderBy);
	    final Query query = createQuery(null, selectFields, realClass, logicCondition, orderBy);
	    result = query.getResultList();

	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException(
		    "Error in  BaseJpaDAO.findCollectionByLogicCondition(String[]selectFields, java.lang.Class realClass, LogicCondition logicCondition, String orderBy) : " + e.toString(), e);
	}
	log.info("************Done **************");
	return result;
    }

    public Collection findCollectionByLogicCondition(java.lang.Class realClass, LogicCondition logicCondition, String orderBy) throws DataAccessException {
	log.debug("************Entering ***************");
	Collection result;
	try {

	    // Query query = createQuery(null, realClass, logicCondition,
	    // orderBy);
	    final Query query = createQuery(null, null, realClass, logicCondition, orderBy);
	    result = query.getResultList();

	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.findCollectionByLogicCondition(java.lang.Class realClass, LogicCondition logicCondition, String orderBy) : " + e.toString(), e);
	}
	log.info("************Done **************");
	return result;
    }

    public Collection findCollectionByLogicCondition(Boolean distinct, String[] selectFields, java.lang.Class realClass, LogicCondition logicCondition, String orderBy) throws DataAccessException {
	log.debug("************Entering ***************");
	Collection result;
	try {

	    // Query query = createQuery(selectFields, realClass,
	    // logicCondition, orderBy);
	    final Query query = createQuery(distinct, selectFields, realClass, logicCondition, orderBy);
	    result = query.getResultList();

	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException(
		    "Error in  BaseJpaDAO.findCollectionByLogicCondition(Boolean distinct,String[]selectFields, java.lang.Class realClass, LogicCondition logicCondition, String orderBy) : "
			    + e.toString(),
		    e);
	}
	log.info("************Done **************");
	return result;
    }

    public Collection findCollectionByLogicCondition(Boolean distinct, String[] selectFields, java.lang.Class realClass, LogicCondition logicCondition, String orderBy, String[] groupBy,
	    Integer firstResult, Integer maxResults) throws DataAccessException {
	log.debug("************Entering ***************");
	Collection result;
	try {
	    final Query query = createQuery(distinct, selectFields, realClass, logicCondition, orderBy, groupBy);

	    if (firstResult != null) {
		query.setFirstResult(firstResult.intValue());
	    }
	    if (maxResults != null) {
		query.setMaxResults(maxResults.intValue());
	    }

	    result = query.getResultList();

	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException(
		    "Error in  BaseJpaDAO.findCollectionByLogicCondition(Boolean distinct,String[] selectFields, java.lang.Class realClass, LogicCondition logicCondition, String orderBy,String[] groupBy,Integer firstResult, Integer maxResults) : "
			    + e.toString(),
		    e);
	}
	log.info("************Done **************");
	return result;
    }

    public Collection findCollectionByLogicCondition(Boolean distinct, String[] selectFields, java.lang.Class realClass, LogicCondition logicCondition, String orderBy, Integer firstResult,
	    Integer maxResults) throws DataAccessException {
	log.debug("************Entering ***************");
	Collection result;
	try {
	    final Query query = createQuery(distinct, selectFields, realClass, logicCondition, orderBy);

	    if (firstResult != null) {
		query.setFirstResult(firstResult.intValue());
	    }
	    if (maxResults != null) {
		query.setMaxResults(maxResults.intValue());
	    }

	    result = query.getResultList();

	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException(
		    "Error in  BaseJpaDAO.findCollectionByLogicCondition(Boolean distinct,String[] selectFields, java.lang.Class realClass, LogicCondition logicCondition, String orderBy,Integer firstResult, Integer maxResults) : "
			    + e.toString(),
		    e);
	}
	log.info("************Done **************");
	return result;
    }

    public Collection findCollectionByLogicCondition(String[] selectFields, java.lang.Class realClass, LogicCondition logicCondition, String orderBy, Integer firstResult, Integer maxResults)
	    throws DataAccessException {
	log.debug("************Entering ***************");
	Collection result;
	try {
	    final Query query = createQuery(null, selectFields, realClass, logicCondition, orderBy);

	    if (firstResult != null) {
		query.setFirstResult(firstResult.intValue());
	    }
	    if (maxResults != null) {
		query.setMaxResults(maxResults.intValue());
	    }

	    result = query.getResultList();

	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException(
		    "Error in  BaseJpaDAO.findCollectionByLogicCondition(String[] selectFields, java.lang.Class realClass, LogicCondition logicCondition, String orderBy,Integer firstResult, Integer maxResults) : "
			    + e.toString(),
		    e);
	}
	log.info("************Done **************");
	return result;
    }

    public Collection findCollectionByLogicCondition(java.lang.Class realClass, LogicCondition logicCondition, String orderBy, Integer firstResult, Integer maxResults) throws DataAccessException {
	log.debug("************Entering ***************");
	Collection result;
	try {
	    final Query query = createQuery(null, null, realClass, logicCondition, orderBy);

	    if (firstResult != null) {
		query.setFirstResult(firstResult.intValue());
	    }
	    if (maxResults != null) {
		query.setMaxResults(maxResults.intValue());
	    }

	    result = query.getResultList();

	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.findCollectionByLogicCondition(java.lang.Class realClass, LogicCondition logicCondition, String orderBy) : " + e.toString(), e);
	}
	log.info("************Done **************");
	return result;
    }

    public Collection findCollectionByLogicCondition(Boolean distinct, java.lang.Class realClass, LogicCondition logicCondition, String orderBy) throws DataAccessException {
	log.debug("************Entering ***************");
	Collection result;
	try {

	    // Query query = createQuery(selectFields, realClass,
	    // logicCondition, orderBy);
	    final Query query = createQuery(distinct, null, realClass, logicCondition, orderBy);
	    result = query.getResultList();

	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException(
		    "Error in  BaseJpaDAO.findCollectionByLogicCondition(Boolean distinct, java.lang.Class realClass, LogicCondition logicCondition, String orderBy) : " + e.toString(), e);
	}
	log.info("************Done **************");
	return result;
    }

    public Collection findCollectionByLogicCondition(Boolean distinct, java.lang.Class realClass, LogicCondition logicCondition) throws DataAccessException {
	log.debug("************Entering ***************");
	Collection result;
	try {

	    // Query query = createQuery(selectFields, realClass,
	    // logicCondition, orderBy);
	    final Query query = createQuery(distinct, null, realClass, logicCondition, null);
	    result = query.getResultList();

	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.findCollectionByLogicCondition(Boolean distinct, java.lang.Class realClass, LogicCondition logicCondition) : " + e.toString(), e);
	}
	log.info("************Done **************");
	return result;
    }

    public Collection findCollectionByLogicCondition(Boolean distinct, String[] selectFields, java.lang.Class realClass, LogicCondition logicCondition) throws DataAccessException {
	log.debug("************Entering ***************");
	Collection result;
	try {

	    // Query query = createQuery(selectFields, realClass,
	    // logicCondition, orderBy);
	    final Query query = createQuery(distinct, selectFields, realClass, logicCondition, null);
	    result = query.getResultList();

	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException(
		    "Error in  BaseJpaDAO.findCollectionByLogicCondition(Boolean distinct,String[]selectFields, java.lang.Class realClass, LogicCondition logicCondition) : " + e.toString(), e);
	}
	log.info("************Done **************");
	return result;
    }

    /**
     * @deprecated use
     *             {@link #findCollectionByLogicCondition(Class realClass, it.aco.mandragora.query.LogicCondition logicCondition,String orderingField, Boolean asc, Integer startAtIndex, Integer endAtIndex)}
     */
    @Deprecated
    public Collection findLimitedOrderedCollectionByLogicCondition(Class realClass, LogicCondition logicCondition, String orderingField, boolean asc, int startAtIndex, int endAtIndex)
	    throws DataAccessException {
	return findCollectionByLogicCondition(realClass, logicCondition, orderingField, new Boolean(asc), new Integer(startAtIndex), new Integer(endAtIndex));
    }

    public Collection findCollectionByOrValues(Class realClass, String pAttributeName, Collection valuesCollection) throws DataAccessException {
	log.info("************Entering  ***************");
	Collection result = null;

	try {
	    if (valuesCollection != null && !valuesCollection.isEmpty()) {
		final Map parameters = new HashMap();
		String queryString = "SELECT c FROM " + realClass.getSimpleName() + " c  WHERE ";

		int i = 0;
		final Iterator iterator = valuesCollection.iterator();
		while (iterator.hasNext()) {

		    Object value = new Object();
		    value = iterator.next();
		    if (value != null) {
			final String parameter = "parameter" + i;
			queryString += " c." + pAttributeName + " = :" + parameter + " OR";
			parameters.put(parameter, value);
			i++;
		    } else {
			queryString += " c." + pAttributeName + "IS NULL OR";
		    }
		}
		queryString = queryString.substring(0, queryString.lastIndexOf("OR"));

		final Query query = getEntityManager().createQuery(queryString);

		setQueryParameters(query, parameters);
		result = query.getResultList();
	    }
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.findCollectionByOrValues(Class realClass,String pAttributeName,Collection valuesCollection) : " + e.toString(), e);
	}
	log.info("************Done ***************");
	return result;
    }

    public Collection findCollectionByFieldsNotEqualsToValues(Class realClass, String[] pAttributeNames, Object[] valuesArray) throws DataAccessException {
	log.info("************Entering ***************");

	Collection result;
	try {
	    result = null;
	    if (valuesArray == null || pAttributeNames == null || valuesArray.length != pAttributeNames.length) {
		throw new DataAccessException(
			"DataAccessException in BaseJpaDAO.findCollectionByFieldsNotEqualsToValues(Class realClass,String[] pAttributeNames,Object[] valuesArray): pAttributeNames and values must not be null and must have the same length ");
	    }

	    final Map parameters = new HashMap();
	    String queryString = "SELECT c FROM " + realClass.getSimpleName() + " c   ";

	    if (pAttributeNames.length > 0) {
		String whereCondition = "";
		for (int i = 0; i < pAttributeNames.length; i++) {
		    final String parameter = "parameter" + i;
		    whereCondition += " c." + pAttributeNames[i] + " <> :" + parameter + " AND";
		    parameters.put(parameter, valuesArray[i]);
		}

		whereCondition = whereCondition.substring(0, whereCondition.lastIndexOf("AND"));
		queryString += " WHERE " + whereCondition;
	    }
	    final Query query = getEntityManager().createQuery(queryString);

	    setQueryParameters(query, parameters);
	    result = query.getResultList();
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.findCollectionByFieldsNotEqualsToValues(Class realClass,String[] pAttributeNames,Object[] valuesArray) : " + e.toString(), e);
	}
	log.info("************Done *************");
	return result;
    }

    public Collection findCollectionByAndFieldsOperatorValues(Class realClass, String[] pAttributeNames, String[] operators, Object[] valuesArray) throws DataAccessException {
	log.info("************Entering ***************");
	Collection result = null;

	try {
	    if (valuesArray == null || pAttributeNames == null || operators == null || valuesArray.length != pAttributeNames.length || operators.length != pAttributeNames.length) {
		throw new DataAccessException(
			"DataAccessException in BaseJpaDAO.findCollectionByAndFieldsOperatorValues(Class realClass,String[] pAttributeNames, String[] operators,Object[] valuesArray):properties,operators and values must not be null and must have the same length ");
	    }

	    final Map parameters = new HashMap();
	    String queryString = "SELECT c FROM " + realClass.getSimpleName() + " c ";

	    if (pAttributeNames.length > 0) {
		String whereCondition = "";
		for (int i = 0; i < pAttributeNames.length; i++) {

		    final String parameter = "parameter" + i;
		    final String operator = operators[i].equals("!=") ? "<>" : operators[i].equals("==") ? "=" : operators[i];
		    whereCondition += " c." + pAttributeNames[i] + " " + operator + " :" + parameter + " AND";
		    parameters.put(parameter, valuesArray[i]);
		}
		whereCondition = whereCondition.substring(0, whereCondition.lastIndexOf("AND"));
		queryString += " WHERE " + whereCondition;
	    }
	    final Query query = getEntityManager().createQuery(queryString);

	    setQueryParameters(query, parameters);
	    result = query.getResultList();
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException(
		    "Error in  BaseJpaDAO.findCollectionByAndFieldsOperatorValues(Class realClass,String[] pAttributeNames, String[] operators,Object[] valuesArray): " + e.toString(), e);
	}

	log.info("************Done *************");
	return result;
    }

    public Collection findCollectionByArrayOfFieldsOperatorsMatrixAndOrValues(Class realClass, String[] pAttributeNames, String[] operators, Object[][] valuesMatrix) throws DataAccessException {
	log.info("************Entering **************");
	Collection result = null;
	try {
	    if (valuesMatrix == null || pAttributeNames == null || operators == null || operators.length != pAttributeNames.length || operators.length == 0) {
		throw new DataAccessException(
			"DataAccessException in BaseJpaDAO.findCollectionByArrayOfFieldsOperatorsMatrixAndOrValues(Class realClass,String[] pAttributeNames, String[] operators,Object[][] valuesMatrix, PersistenceBroker broker ):pAttributeNames and operators  must not be null,  must have the same length and can't be empty ");
	    }
	    if (valuesMatrix.length == 0) {
		throw new DataAccessException(
			"DataAccessException in BaseJpaDAO.findCollectionByArrayOfFieldsOperatorsMatrixAndOrValues(Class realClass,String[] pAttributeNames, String[] operators,Object[][] valuesMatrix):valuesMatrix must not be empty");
	    }

	    final Map parameters = new HashMap();
	    String queryString = "SELECT c FROM " + realClass.getSimpleName() + " c  WHERE ";

	    for (int i = 0; i < valuesMatrix.length; i++) {
		if (valuesMatrix[i].length != pAttributeNames.length) {
		    throw new DataAccessException(
			    "OjbPbCoreException in DataAccessException.findCollectionByArrayOfFieldsOperatorsMatrixAndOrValues(Class realClass,String[] pAttributeNames, String[] operators,Object[][] valuesMatrix):valuesMatrix["
				    + i + "] have the same length of pAttributeNames");
		}
		queryString += " ( ";
		for (int j = 0; j < valuesMatrix[i].length; j++) {

		    final String parameter = "parameter" + i + "_" + j;
		    final String operator = operators[i].equals("!=") ? "<>" : operators[i].equals("==") ? "=" : operators[i];

		    queryString += " c." + pAttributeNames[j] + " " + operator + " :" + parameter + " AND";
		    parameters.put(parameter, valuesMatrix[i][j]);
		}
		queryString = queryString.substring(0, queryString.lastIndexOf("AND"));
		queryString += " ) OR ";
	    }
	    queryString = queryString.substring(0, queryString.lastIndexOf("OR"));
	    final Query query = getEntityManager().createQuery(queryString);
	    setQueryParameters(query, parameters);
	    result = query.getResultList();
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException(
		    "Error in  BaseJpaDAO.findCollectionByArrayOfFieldsOperatorsMatrixAndOrValues(Class realClass,String[] pAttributeNames, String[] operators, Object[][] valuesMatrix): "
			    + e.toString(),
		    e);
	}
	log.info("************Done ************");
	return result;
    }

    public Collection findCollectionByFieldInCollection(Class realClass, String pAttributeName, Collection valuesCollection) throws DataAccessException {

	log.info("************Entering ***************");
	Collection result = null;
	try {
	    if (valuesCollection != null && !valuesCollection.isEmpty()) {
		final Map parameters = new HashMap();
		String queryString = "SELECT c FROM " + realClass.getSimpleName() + " c ";
		if (valuesCollection.size() > this.inLimit) {
		    final ArrayList<List> splitIn = splitIn(valuesCollection);
		    queryString += " WHERE (" + orOfInsCollection("c." + pAttributeName, "parameter", splitIn, parameters) + " )";
		} else {
		    queryString += " WHERE c." + pAttributeName + " IN (:parameter)";
		    parameters.put("parameter", valuesCollection);
		}
		final Query query = getEntityManager().createQuery(queryString);
		setQueryParameters(query, parameters);
		result = query.getResultList();
	    }
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.findCollectionByFieldInCollection(Class realClass,String pAttributeName,Collection valuesCollection): " + e.toString(), e);
	}

	log.info("************Done *************");
	return result;
    }

    public Collection searchValueInFields(Class realClass, String[] pAttributeNames, Object value) throws DataAccessException {
	log.info("************Entering ***************");
	Collection result = null;

	try {
	    if (pAttributeNames != null && pAttributeNames.length > 0 && value != null) {

		final Map parameters = new HashMap();
		parameters.put("parameter", value);

		String queryString = "SELECT c FROM " + realClass.getSimpleName() + " c  WHERE ";

		for (final String pAttributeName : pAttributeNames) {
		    // queryString += " c." + pAttributeNames[i] + " LIKE
		    // %:parameter% OR ";
		    queryString += " c." + pAttributeName + " LIKE concat('%',:parameter,'%') OR ";
		    // LIKE lower(concat('%',:" + fieldLastToken + ",'%'))";
		}

		queryString = queryString.substring(0, queryString.lastIndexOf("OR"));
		final Query query = getEntityManager().createQuery(queryString);
		setQueryParameters(query, parameters);
		result = query.getResultList();
	    }
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.searchValueInFields(Class realClass, String[] pAttributeNames, Object value): " + e.toString(), e);
	}

	log.info("************Done ************");
	return result;
    }

    /*
     * TODO make it work with dot separated pAttributeName (non-Javadoc)
     *
     * @see
     * it.aco.mandragora.dao.DAO#getCollectionOfStoredItemsNotInBean(java.lang.
     * Object, java.lang.String)
     */
    public Collection getCollectionOfStoredItemsNotInBean(Object pInstance, String pAttributeName) throws DataAccessException {
	log.info("************Entering **************");
	Collection result = null;
	try {

	    result = getCollectionOfStoredItemsInOrNotInBean(pInstance, pAttributeName, true);
	    // if(pAttributeName==null || pAttributeName.trim().equals("")){
	    // log.error("Error in
	    // BaseJpaDAO.getCollectionOfStoredItemsNotInBean(Object pInstance,
	    // String pAttributeName) : pAttributeName can't be null or empty or
	    // blank chacarcters string" );
	    // throw new DataAccessException("Exception thrown in
	    // BaseJpaDAO.getCollectionOfStoredItemsNotInBean(Object pInstance,
	    // String pAttributeName) : pAttributeName can't be null or empty or
	    // blank chacarcters string");
	    // }
	    //
	    //
	    // PropertyUtilsBean propertyUtilsBean =
	    // BeanUtilsBean.getInstance().getPropertyUtils();
	    // Class pInstanceClass = getEntityClass(pInstance);
	    // Class pAttributeClass = getClassFromPath(pInstanceClass,
	    // pAttributeName);
	    // EntityInfo pAttributeEntityInfo = new
	    // EntityInfo(pAttributeClass);
	    //
	    // Field pAttributeIdField = pAttributeEntityInfo.getIdField();
	    // Collection pAttributeCollection =
	    // (Collection)propertyUtilsBean.getProperty(pInstance,
	    // pAttributeName);
	    // Collection pAttributeIds = null;
	    // if(pAttributeCollection!=null &&
	    // !pAttributeCollection.isEmpty()){
	    // pAttributeIds =
	    // Utils.selectFieldFromCollection(pAttributeCollection,
	    // pAttributeIdField.getName());
	    // }
	    //
	    //
	    // String pAttributeIdFieldName=pAttributeIdField.getName(); //
	    // added alessandro on 05/08/2012
	    //
	    //
	    //
	    // Map parameters = new HashMap();
	    // parameters.put("param0", pInstance);
	    //
	    // String queryString ="SELECT bbb FROM
	    // "+pInstanceClass.getSimpleName()+" a join a."+pAttributeName+"
	    // bbb WHERE a= :param0 " ;
	    //
	    //
	    //
	    // if(pAttributeIds!=null){
	    // queryString += "AND NOT EXISTS (SELECT 1 FROM
	    // "+pAttributeClass.getSimpleName()+" c WHERE ";
	    // queryString+=" bbb."+pAttributeIdFieldName+" =
	    // c."+pAttributeIdFieldName+ " AND ";
	    // queryString +="(";
	    // Iterator iterator = pAttributeIds.iterator();
	    // int paramIndex=1;
	    // while(iterator.hasNext()){
	    // String param = "param"+paramIndex;
	    // Object pAttributeId = iterator.next();
	    // queryString+=" (c."+pAttributeIdFieldName+" = :"+param;
	    // //queryString+=" AND bbb."+pAttributeIdFieldName+" =
	    // c."+pAttributeIdFieldName;
	    // queryString +=")";
	    // parameters.put(param, pAttributeId);
	    // if(iterator.hasNext()){
	    // queryString+=" OR ";
	    // }
	    // paramIndex++;
	    // }
	    // queryString +=") )";
	    // }
	    //
	    // result = findCollectionByQueryString(queryString, parameters);

	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getCollectionOfStoredItemsNotInBean(Object pInstance, String pAttributeName): " + e.toString(), e);
	}
	log.info("************Done **********");
	return result;
    }

    /**
     * TODO put in interface and bubble up; TODO make it work with dot separated
     * pAttributeName
     *
     * @param pInstance
     * @param pAttributeName
     * @return
     * @throws DataAccessException
     */
    public Collection getCollectionOfStoredItemsInBean(Object pInstance, String pAttributeName) throws DataAccessException {
	log.info("************Entering **************");
	Collection result = null;
	try {

	    result = getCollectionOfStoredItemsInOrNotInBean(pInstance, pAttributeName, false);

	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getCollectionOfStoredItemsInBean(Object pInstance, String pAttributeName): " + e.toString(), e);
	}
	log.info("************Done **********");
	return result;
    }

    private Collection getCollectionOfStoredItemsInOrNotInBean(Object pInstance, String pAttributeName, boolean notInBean) throws DataAccessException {
	log.info("************Entering **************");
	Collection result = null;
	try {
	    if (pAttributeName == null || pAttributeName.trim().equals("")) {
		log.error(
			"Error  in  BaseJpaDAO.getCollectionOfStoredItemsInOrNotInBean(Object pInstance, String pAttributeName, boolean notInBean) : pAttributeName can't be null or empty or blank chacarcters string");
		throw new DataAccessException(
			"Exception thrown in BaseJpaDAO.getCollectionOfStoredItemsInOrNotInBean(Object pInstance, String pAttributeName, boolean notInBean) : pAttributeName can't be null or empty or blank chacarcters string");
	    }

	    final PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();
	    final Class pInstanceClass = getEntityClass(pInstance);
	    final Class pAttributeClass = getClassFromPath(pInstanceClass, pAttributeName);
	    final EntityInfo pAttributeEntityInfo = new EntityInfo(pAttributeClass);

	    final Field pAttributeIdField = pAttributeEntityInfo.getIdField();
	    final Collection pAttributeCollection = (Collection) propertyUtilsBean.getProperty(pInstance, pAttributeName);
	    Collection pAttributeIds = null;
	    if (pAttributeCollection != null && !pAttributeCollection.isEmpty()) {
		pAttributeIds = Utils.selectFieldFromCollection(pAttributeCollection, pAttributeIdField.getName());
	    }

	    final String pAttributeIdFieldName = pAttributeIdField.getName(); // added
									      // alessandro
									      // on
									      // 05/08/2012

	    final Map parameters = new HashMap();
	    parameters.put("param0", pInstance);

	    String queryString = "SELECT bbb FROM " + pInstanceClass.getSimpleName() + " a join a." + pAttributeName + " bbb  WHERE a= :param0 ";

	    if (pAttributeIds != null) {
		if (notInBean) {
		    queryString += "AND NOT EXISTS ";
		} else {
		    queryString += "AND EXISTS ";
		}

		// queryString += "AND EXISTS (SELECT 1 FROM
		// "+pAttributeClass.getSimpleName()+" c WHERE ";
		queryString += "(SELECT 1 FROM " + pAttributeClass.getSimpleName() + " c WHERE ";
		queryString += " bbb." + pAttributeIdFieldName + " = c." + pAttributeIdFieldName + " AND ";
		queryString += "(";
		final Iterator iterator = pAttributeIds.iterator();
		int paramIndex = 1;
		while (iterator.hasNext()) {
		    final String param = "param" + paramIndex;
		    final Object pAttributeId = iterator.next();
		    queryString += " (c." + pAttributeIdFieldName + " = :" + param;
		    // queryString+=" AND bbb."+pAttributeIdFieldName+" =
		    // c."+pAttributeIdFieldName;
		    queryString += ")";
		    parameters.put(param, pAttributeId);
		    if (iterator.hasNext()) {
			queryString += " OR ";
		    }
		    paramIndex++;
		}
		queryString += ") )";
	    }

	    result = findCollectionByQueryString(queryString, parameters);

	} catch (final IllegalAccessException e) {
	    log.error("IllegalAccessException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getCollectionOfStoredItemsInOrNotInBean(Object pInstance, String pAttributeName, boolean notInBean): " + e.toString(), e);
	} catch (final InvocationTargetException e) {
	    log.error("InvocationTargetException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getCollectionOfStoredItemsInOrNotInBean(Object pInstance, String pAttributeName, boolean notInBean): " + e.toString(), e);
	} catch (final NoSuchMethodException e) {
	    log.error("NoSuchMethodException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getCollectionOfStoredItemsInOrNotInBean(Object pInstance, String pAttributeName, boolean notInBean): " + e.toString(), e);
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getCollectionOfStoredItemsInOrNotInBean(Object pInstance, String pAttributeName, boolean notInBean): " + e.toString(), e);
	}
	log.info("************Done **********");
	return result;
    }

    /*
     * TODO make it works with path of dot (non-Javadoc)
     *
     * @see it.aco.mandragora.dao.DAO#getStoredCollection(java.lang.Object,
     * java.lang.String)
     */
    public Collection getStoredCollection(Object pInstance, String pAttributeName) throws DataAccessException {
	log.info("************Entering **************");
	Collection result = null;

	try {
	    if (pAttributeName == null || pAttributeName.trim().equals("")) {
		log.error(
			"Error  in  BaseOjbPbCore.getStoredCollection(Object pInstance, String pAttributeName, PersistenceBroker broker) : pAttributeName can't be null or empty or blank chacarcters string");
		throw new DataAccessException(
			"Exception thrown in BaseJpaDAO.getStoredCollection(Object pInstance, String pAttributeName) : pAttributeName can't be null or empty or blank chacarcters string");
	    }

	    final Class pInstanceClass = getEntityClass(pInstance);
	    log.debug("pInstanceClass is " + pInstanceClass.toString());
	    final Class pAttributeClass = getClassFromPath(pInstanceClass, pAttributeName);
	    log.debug("pAttributeClass is " + pAttributeClass.toString());

	    String mappedBy = null;
	    final OneToMany oneToMany = (OneToMany) getAnnotation(pInstanceClass, pAttributeName, OneToMany.class);
	    if (oneToMany != null) {
		mappedBy = oneToMany.mappedBy();
	    }

	    if (mappedBy == null || mappedBy.trim().equals("")) {// is
								 // manytomany
								 // or onetomany
								 // with no
								 // mappedby
		final String queryString = "SELECT bbb FROM " + pInstanceClass.getSimpleName() + " a join a." + pAttributeName + " bbb  WHERE a= :param ";
		final Query query = getEntityManager().createQuery(queryString);
		query.setParameter("param", pInstance);
		result = query.getResultList();
		// JoinTable joinTable = (JoinTable)
		// getAnnotation(pInstanceClass, pAttributeName,
		// JoinTable.class);
		// String joinTableName = joinTable.name();
		// String queryString ="SELECT a FROM
		// "+pAttributeClass.getSimpleName()+" a, "+joinTableName+" j
		// WHERE " ;
		//
		// String[] pkColumnNames = getPkColumnNames(pAttributeClass);
		// String[] inverseJoinColumnNames =
		// getJoinTableInverseColumnName(joinTable);
		// if(pkColumnNames!=null && inverseJoinColumnNames!=null &&
		// pkColumnNames.length==inverseJoinColumnNames.length &&
		// pkColumnNames.length>0){
		// for (int i=0; i<pkColumnNames.length;i++){
		// queryString+="
		// a."+pkColumnNames[i]+"="+"j."+inverseJoinColumnNames[i]+" AND
		// ";
		// }
		// queryString = queryString.substring(0,
		// queryString.lastIndexOf("AND"));
		// Query query = getEntityManager().createQuery(queryString);
		// result = query.getResultList();
		// }else{
		// throw new DataAccessException("Exception thrown in
		// BaseJpaDAO.getStoredCollection(Object pInstance, String
		// pAttributeName) : pkColumnNames and inverseJoinColumnNames
		// can't be null or empty or have different length");
		// }

	    } else { // is onetomany with mappedBy
		final LogicCondition logicCondition = new LogicSqlCondition(mappedBy, "==", pInstance);

		result = findCollectionByLogicCondition(pAttributeClass, logicCondition);
	    }

	    // String mappedBy = getMappedBy(pInstance, pAttributeName);
	    // if (mappedBy==null) throw new
	    // DataAccessException("DataAccessException thrown in
	    // BaseJpaDAO.getStoredCollection(Object pInstance, String
	    // pAttributeName) : OneToMany or ManyToMany annotation must have a
	    // mappedBy attribute");

	    // LogicCondition logicCondition = new
	    // LogicSqlCondition(mappedBy,"==",pInstance);
	    // result = findCollectionByLogicCondition(pAttributeClass,
	    // logicCondition);
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getStoredCollection(Object pInstance, String pAttributeName): " + e.toString(), e);
	}

	log.info("************Done **********");
	return result;
    }

    public Iterator getReportQueryIterator(Class realClass, LogicCondition logicCondition, String[] pAttributeNames, String[] groupBy) throws DataAccessException {
	log.info("************Entering ***************");
	Iterator iterator = null;

	try {
	    if (pAttributeNames == null || pAttributeNames.length == 0) {
		log.error(
			"DataAccessException thrown in  BaseJpaDAO.getReportQueryIterator(Class realClass,LogicCondition logicCondition, String[] pAttributeNames, String[] groupBy): attributes can't be null nor empty");
		throw new DataAccessException(
			"Error in  BaseJpaDAO.getReportQueryIterator(Class realClass,LogicCondition logicCondition, String[] pAttributeNames, String[] groupBy): attributes can't be null nor empty");
	    }
	    if (logicCondition == null) {
		log.error(
			"DataAccessException thrown in  BaseJpaDAO.getReportQueryIterator(Class realClass,LogicCondition logicCondition, String[] pAttributeNames, String[] groupBy): logicCondition can't be null ");
		throw new DataAccessException(
			"Error in  BaseJpaDAO.getReportQueryIterator(Class realClass,LogicCondition logicCondition, String[] pAttributeNames, String[] groupBy): logicCondition can't be null");
	    }

	    final Collection result = findCollectionByLogicCondition(null, pAttributeNames, realClass, logicCondition, null, groupBy, null, null);
	    if (result != null) {
		iterator = result.iterator();
	    }
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getReportQueryIterator(Class realClass, LogicCondition logicCondition, String[] pAttributeNames, String[] groupBy): " + e.toString(),
		    e);
	}
	log.info("************Done *************");
	return iterator;
    }

    public void retrieveReference(Object pInstance, String pAttributeName) throws DataAccessException {
	log.info("************Entering ***************");

	try {

	    // Class pInstanceClass=pInstance.getClass();
	    final Class pInstanceClass = getEntityClass(pInstance);
	    log.info("pInstanceClass is " + pInstanceClass.toString());
	    log.info("pAttributeName is " + pAttributeName);
	    final EntityInfo entityInfo = new EntityInfo(pInstanceClass);

	    final PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();

	    // if(getAnnotation(pInstanceClass,pAttributeName,
	    // OneToOne.class)!=null ||
	    // getAnnotation(pInstanceClass,pAttributeName,
	    // ManyToOne.class)!=null){
	    if (getAnnotation(pInstanceClass, pAttributeName, OneToOne.class) != null || getAnnotation(pInstanceClass, pAttributeName, ManyToOne.class) != null
		    || getAnnotation(pInstanceClass, pAttributeName, EmbeddedId.class) != null) {
		// The reference is an object and not a collection

		final String pInstancePrimaryKey = entityInfo.getIdField().getName();
		final Object pInstancePrimaryKeyValue = propertyUtilsBean.getProperty(pInstance, pInstancePrimaryKey);

		final Object retrievedReference = findObjectByLogicCondition(new String[] { pAttributeName }, pInstanceClass,
			new LogicSqlCondition(pInstancePrimaryKey, "==", pInstancePrimaryKeyValue));
		propertyUtilsBean.setProperty(pInstance, pAttributeName, retrievedReference);
		if (getAnnotation(pInstanceClass, pAttributeName, EmbeddedId.class) == null) {
		    refresh(retrievedReference);
		}

	    } else if (getAnnotation(pInstanceClass, pAttributeName, OneToMany.class) != null || getAnnotation(pInstanceClass, pAttributeName, ManyToMany.class) != null) {
		// The reference is a collection
		// Collection retrievedReference =
		// getStoredCollection(pInstanceClass, pAttributeName);
		final Collection retrievedReference = getStoredCollection(pInstance, pAttributeName);
		propertyUtilsBean.setProperty(pInstance, pAttributeName, retrievedReference);

	    } else {
		throw new DataAccessException("Error in  BaseJpaDAO.retrieveReference(Object pInstance, String pAttributeName): no annotation found");
	    }
	} catch (final IllegalAccessException e) {
	    log.error("IllegalAccessException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.retrieveReference(Object pInstance, String pAttributeName): " + e.toString(), e);
	} catch (final InvocationTargetException e) {
	    log.error("InvocationTargetException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.retrieveReference(Object pInstance, String pAttributeName): " + e.toString(), e);
	} catch (final NoSuchMethodException e) {
	    log.error("NoSuchMethodException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.retrieveReference(Object pInstance, String pAttributeName): " + e.toString(), e);
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.retrieveReference(Object pInstance, String pAttributeName): " + e.toString(), e);
	}

	log.info("************Done***************");
    }

    public void retrieveAllReferences(Object pInstance) throws DataAccessException {
	log.info("************Entering***************");

	try {
	    final PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();

	    // Class pInstanceClass=pInstance.getClass();
	    final Class pInstanceClass = getEntityClass(pInstance);

	    final Map describe = propertyUtilsBean.describe(pInstance);
	    final Iterator iterator = describe.keySet().iterator();
	    while (iterator.hasNext()) {
		final String pAttributeName = (String) iterator.next();
		log.debug("pAttributeName is " + pAttributeName);

		if (getAnnotation(pInstanceClass, pAttributeName, OneToMany.class) != null || getAnnotation(pInstanceClass, pAttributeName, ManyToMany.class) != null
			|| getAnnotation(pInstanceClass, pAttributeName, OneToOne.class) != null || getAnnotation(pInstanceClass, pAttributeName, ManyToOne.class) != null) {

		    retrieveReference(pInstance, pAttributeName);
		}

	    }
	} catch (final IllegalAccessException e) {
	    log.error("IllegalAccessException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.retrieveAllReferences(Object pInstance): " + e.toString(), e);
	} catch (final InvocationTargetException e) {
	    log.error("InvocationTargetException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.retrieveAllReferences(Object pInstance): " + e.toString(), e);
	} catch (final NoSuchMethodException e) {
	    log.error("NoSuchMethodException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.retrieveAllReferences(Object pInstance): " + e.toString(), e);
	}

	log.info("************Done**********");
    }

    public void retrieveAllReferencesInCollection(Collection valueObjectsCollection) throws DataAccessException {
	log.info("************Entering ***************");
	try {
	    if (valueObjectsCollection != null) {
		final Iterator iterator = valueObjectsCollection.iterator();
		while (iterator.hasNext()) {
		    retrieveAllReferences(iterator.next());
		}
	    }
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.retrieveAllReferencesInCollection(Collection valueObjectsCollection): " + e.toString(), e);
	}
	log.info("************Done ***************");
    }

    public void retrieveReferenceInCollection(Collection valueObjectsCollection, String pAttributeName) throws DataAccessException {
	log.info("************Entering***************");
	try {
	    if (valueObjectsCollection != null) {
		final Iterator iterator = valueObjectsCollection.iterator();
		while (iterator.hasNext()) {
		    retrieveReference(iterator.next(), pAttributeName);
		}
	    }
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.retrieveReferenceInCollection(Collection valueObjectsCollection, String pAttributeName): " + e.toString(), e);
	}
	log.info("************Done ***************");
    }

    public void retrieveNullReference(Object pInstance, String pAttributeName) throws DataAccessException {
	log.info("************Entering***************");
	try {
	    final PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();
	    if (propertyUtilsBean.getProperty(pInstance, pAttributeName) == null) {
		retrieveReference(pInstance, pAttributeName);
	    }
	} catch (final IllegalAccessException e) {
	    log.error("IllegalAccessException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.retrieveNullReference(Object pInstance, String pAttributeName): " + e.toString(), e);
	} catch (final InvocationTargetException e) {
	    log.error("InvocationTargetException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.retrieveNullReference(Object pInstance, String pAttributeName): " + e.toString(), e);
	} catch (final NoSuchMethodException e) {
	    log.error("NoSuchMethodException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.retrieveNullReference(Object pInstance, String pAttributeName): " + e.toString(), e);
	}
	log.info("************Done **************");
    }

    public void retrieveAllNullReferences(Object pInstance) throws DataAccessException {
	log.info("************Entering ***************");

	try {
	    final PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();

	    // Class pInstanceClass=pInstance.getClass();
	    final Class pInstanceClass = getEntityClass(pInstance);

	    final Map describe = propertyUtilsBean.describe(pInstance);
	    final Iterator iterator = describe.keySet().iterator();
	    while (iterator.hasNext()) {
		final String pAttributeName = (String) iterator.next();
		if (getAnnotation(pInstanceClass, pAttributeName, OneToMany.class) != null || getAnnotation(pInstanceClass, pAttributeName, ManyToMany.class) != null
			|| getAnnotation(pInstanceClass, pAttributeName, OneToOne.class) != null || getAnnotation(pInstanceClass, pAttributeName, ManyToOne.class) != null) {

		    retrieveNullReference(pInstance, pAttributeName);
		}

	    }
	} catch (final IllegalAccessException e) {
	    log.error("IllegalAccessException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.retrieveAllNullReferences(Object pInstance): " + e.toString(), e);
	} catch (final InvocationTargetException e) {
	    log.error("InvocationTargetException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.retrieveAllNullReferences(Object pInstance): " + e.toString(), e);
	} catch (final NoSuchMethodException e) {
	    log.error("NoSuchMethodException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.retrieveAllNullReferences(Object pInstance): " + e.toString(), e);
	}
	log.info("************Done ***************");
    }

    /**
     * convenience method to use when the first attribute is an embeddedId
     *
     * @param valueobjectOrCollection
     * @param path
     * @throws DataAccessException
     */
    private void retrievePKPathReference(Object valueobject, String firstAttributeName, String remainingPath) throws DataAccessException {
	log.info("************Entering **************");
	try {
	    final PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();
	    // Object valueobjectPrimaryKeyValue =
	    // propertyUtilsBean.getProperty(valueobject,firstAttributeName);
	    final String[] firstAttributeNameAndRemainingPath2 = Utils.getFirstAttributeNameAndRemainingPath(remainingPath);
	    final String secondAttributeName = firstAttributeNameAndRemainingPath2[0];
	    final String remainingPath2 = firstAttributeNameAndRemainingPath2[1];

	    // Object retrievedReference = findObjectByLogicCondition(new
	    // String[]{firstAttributeName+"."+secondAttributeName},
	    // valueobject.getClass(), new
	    // LogicSqlCondition(firstAttributeName,"==",
	    // valueobjectPrimaryKeyValue));
	    // propertyUtilsBean.setProperty(valueobjectPrimaryKeyValue,
	    // secondAttributeName,retrievedReference);
	    // if(remainingPath2!=null &&
	    // !remainingPath2.trim().equals(""))retrievePathReference(retrievedReference,remainingPath2);
	    //

	    final Object pkAttribute = propertyUtilsBean.getProperty(valueobject, firstAttributeName);
	    // retrieveReference(pkAttribute,secondAttributeName);
	    final Object secondAttribute = propertyUtilsBean.getProperty(pkAttribute, secondAttributeName);
	    refresh(secondAttribute);
	    if (remainingPath2 != null && !remainingPath2.trim().equals("")) {
		retrievePathReference(secondAttribute, remainingPath2);
	    }
	} catch (final IllegalAccessException e) {
	    log.error("IllegalAccessException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.retrievePKPathReference(Object valueobject, String firstAttributeName, String remainingPath): " + e.toString(), e);
	} catch (final InvocationTargetException e) {
	    log.error("InvocationTargetException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.retrievePKPathReference(Object valueobject, String firstAttributeName, String remainingPath): " + e.toString(), e);
	} catch (final NoSuchMethodException e) {
	    log.error("NoSuchMethodException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.retrievePKPathReference(Object valueobject, String firstAttributeName, String remainingPath): " + e.toString(), e);
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.retrievePKPathReference(Object valueobject, String firstAttributeName, String remainingPath): " + e.toString(), e);
	}

	log.info("************Done ************");
    }

    public void retrievePathReference(Object valueobjectOrCollection, String path) throws DataAccessException {
	log.info("************Entering **************");
	String firstAttributeName = "";
	String remainingPath = "";

	try {
	    if (path != null && !path.trim().equals("") && valueobjectOrCollection != null) {

		final PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();
		log.debug("retrievePathReference:path=" + path);
		final String[] firstAttributeNameAndRemainingPath = Utils.getFirstAttributeNameAndRemainingPath(path);

		firstAttributeName = firstAttributeNameAndRemainingPath[0];
		remainingPath = firstAttributeNameAndRemainingPath[1];

		log.debug("retrievePathReference:firstAttributeName=" + firstAttributeName);

		if (Collection.class.isInstance(valueobjectOrCollection)) { // is
									    // a
									    // collection
		    log.debug("retrievePathReference: valueobjectOrCollection is a collection");

		    final Iterator iterator = ((Collection) valueobjectOrCollection).iterator();
		    while (iterator.hasNext()) {
			final Object valueobjectOrCollectionItem = iterator.next();
			retrieveReference(valueobjectOrCollectionItem, firstAttributeName);
			if (remainingPath != null && !remainingPath.trim().equals("")) {
			    // if(getAnnotation(valueobjectOrCollectionItem.getClass(),
			    // firstAttributeName, EmbeddedId.class)!=null){
			    if (getAnnotation(getEntityClass(valueobjectOrCollectionItem), firstAttributeName, EmbeddedId.class) != null) {
				// String[] firstAttributeNameAndRemainingPath2
				// =
				// Utils.getFirstAttributeNameAndRemainingPath(remainingPath);
				// String
				// secondAttributeName=firstAttributeNameAndRemainingPath2[0];
				// String
				// remainingPath2=firstAttributeNameAndRemainingPath2[1];
				// Object
				// pkAttribute=propertyUtilsBean.getProperty(valueobjectOrCollectionItem,firstAttributeName);
				// retrieveReference(pkAttribute,secondAttributeName);
				// if(remainingPath2!=null &&
				// !remainingPath2.trim().equals("")){
				// retrievePathReference(propertyUtilsBean.getProperty(pkAttribute,secondAttributeName),remainingPath2);
				// }
				retrievePKPathReference(valueobjectOrCollectionItem, firstAttributeName, remainingPath);
			    } else {
				retrievePathReference(propertyUtilsBean.getProperty(valueobjectOrCollectionItem, firstAttributeName), remainingPath);
			    }
			}

			// if(getAnnotation(valueobjectOrCollectionItem.getClass(),
			// firstAttributeName, EmbeddedId.class)!=null){
			// retrievePKPathReference(valueobjectOrCollectionItem,
			// firstAttributeName, remainingPath);
			// }else{
			// retrieveReference(valueobjectOrCollectionItem,firstAttributeName);
			// if(remainingPath!=null &&
			// !remainingPath.trim().equals("")){
			// retrievePathReference(propertyUtilsBean.getProperty(valueobjectOrCollectionItem,firstAttributeName),remainingPath);
			// }
			// }

		    }

		} // else
		  // if(valueobjectOrCollection.getClass().isAnnotationPresent(Entity.class)){
		else {
		    retrieveReference(valueobjectOrCollection, firstAttributeName);
		    // if(getAnnotation(valueobjectOrCollection.getClass(),
		    // firstAttributeName, EmbeddedId.class)!=null){
		    if (getAnnotation(getEntityClass(valueobjectOrCollection), firstAttributeName, EmbeddedId.class) != null) {

			retrievePKPathReference(valueobjectOrCollection, firstAttributeName, remainingPath);
			// Object valueobjectOrCollectionPrimaryKeyValue =
			// propertyUtilsBean.getProperty(valueobjectOrCollection,firstAttributeName);
			// String[] firstAttributeNameAndRemainingPath2 =
			// Utils.getFirstAttributeNameAndRemainingPath(remainingPath);
			// String
			// secondAttributeName=firstAttributeNameAndRemainingPath2[0];
			// String
			// remainingPath2=firstAttributeNameAndRemainingPath2[1];
			// Object retrievedReference =
			// findObjectByLogicCondition(new
			// String[]{firstAttributeName+"."+secondAttributeName},
			// valueobjectOrCollection.getClass(), new
			// LogicSqlCondition(firstAttributeName,"==",
			// valueobjectOrCollectionPrimaryKeyValue));
			// propertyUtilsBean.setProperty(valueobjectOrCollectionPrimaryKeyValue,
			// secondAttributeName,retrievedReference);
			// if(remainingPath2!=null &&
			// !remainingPath2.trim().equals(""))retrievePathReference(retrievedReference,remainingPath2);
			//
		    } else {
			log.debug("retrievePathReference: valueobjectOrCollection is a valueobject");

			// retrieveReference(valueobjectOrCollection,firstAttributeName);
			if (remainingPath != null && !remainingPath.trim().equals("")) {
			    retrievePathReference(propertyUtilsBean.getProperty(valueobjectOrCollection, firstAttributeName), remainingPath);
			}
		    }
		}
		// else {
		// throw new DataAccessException("Error in
		// BaseJpaDAO.retrievePathReference(Object
		// valueobjectOrCollection, String path): "
		// +valueobjectOrCollection.getClass().toString()+" is not a
		// collection and not an Entity");
		// }
	    }
	} catch (final IllegalAccessException e) {
	    log.error("IllegalAccessException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.retrievePathReference(Object valueobjectOrCollection, String path): " + e.toString(), e);
	} catch (final InvocationTargetException e) {
	    log.error("InvocationTargetException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.retrievePathReference(Object valueobjectOrCollection, String path): " + e.toString(), e);
	} catch (final NoSuchMethodException e) {
	    log.error("NoSuchMethodException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.retrievePathReference(Object valueobjectOrCollection, String path): " + e.toString(), e);
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.retrievePathReference(Object valueobjectOrCollection, String path): " + e.toString(), e);
	}
	log.info("************Done ************");

    }

    public void retrieveNullPathReference(Object valueobjectOrCollection, String path) throws DataAccessException {
	log.info("************Entering **************");

	try {
	    if (path != null && !path.trim().equals("") && valueobjectOrCollection != null) {

		final PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();
		log.debug("retrieveNullPathReference:path=" + path);
		final String[] firstAttributeNameAndRemainingPath = Utils.getFirstAttributeNameAndRemainingPath(path);
		final String firstAttributeName = firstAttributeNameAndRemainingPath[0];
		final String remainingPath = firstAttributeNameAndRemainingPath[1];

		log.debug("retrieveNullPathReference:firstAttributeName=" + firstAttributeName);

		if (Collection.class.isInstance(valueobjectOrCollection)) { // is
									    // a
									    // collection
		    log.debug("retrieveNullPathReference: valueobjectOrCollection is a collection");

		    if (valueobjectOrCollection != null) {
			final Iterator iterator = ((Collection) valueobjectOrCollection).iterator();
			while (iterator.hasNext()) {
			    final Object valueobjectOrCollectionItem = iterator.next();
			    if (propertyUtilsBean.getProperty(valueobjectOrCollectionItem, firstAttributeName) == null) {
				retrieveReference(valueobjectOrCollectionItem, firstAttributeName);
			    }
			    if (!remainingPath.equals("")) {
				retrieveNullPathReference(propertyUtilsBean.getProperty(valueobjectOrCollectionItem, firstAttributeName), remainingPath);
			    }
			}
		    }
		} else {// is a valueobject
		    log.debug(".retrieveNullPathReference: valueobjectOrCollection is a valueobject");

		    if (propertyUtilsBean.getProperty(valueobjectOrCollection, firstAttributeName) == null) {
			log.debug("retrieveNullPathReference: propertyUtilsBean.getProperty(valueobjectOrCollection,firstAttributeName)==null");
			log.debug("retrieveNullPathReference: valueobjectOrCollection = " + valueobjectOrCollection.toString());
			log.debug("retrieveNullPathReference: firstAttributeName = " + firstAttributeName);
			retrieveReference(valueobjectOrCollection, firstAttributeName);
			log.debug("retrieveNullPathReference: retrieved null reference");
		    }
		    if (!remainingPath.equals("")) {
			log.debug("retrieveNullPathReference: before recursion");
			retrieveNullPathReference(propertyUtilsBean.getProperty(valueobjectOrCollection, firstAttributeName), remainingPath);
			log.debug("retrieveNullPathReference: after recursion");
		    }
		}
	    }
	} catch (final IllegalAccessException e) {
	    log.error("IllegalAccessException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.retrieveNullPathReference(Object valueobjectOrCollection, String path): " + e.toString(), e);
	} catch (final InvocationTargetException e) {
	    log.error("InvocationTargetException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.retrieveNullPathReference(Object valueobjectOrCollection, String path): " + e.toString(), e);
	} catch (final NoSuchMethodException e) {
	    log.error("NoSuchMethodException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.retrieveNullPathReference(Object valueobjectOrCollection, String path): " + e.toString(), e);
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.retrieveNullPathReference(Object valueobjectOrCollection, String path): " + e.toString(), e);
	}

	log.info("************Done ***********");

    }

    private void deleteCore(Object deleteVO) throws DataAccessException, DataOptimisticLockException {
	log.debug("************Entering ***************");
	try {
	    if (getEntityManager().contains(deleteVO)) {
		getEntityManager().remove(deleteVO);
	    } else {
		getEntityManager().remove(getEntityManager().merge(deleteVO));
	    }
	} catch (final OptimisticLockException e) {
	    log.error("OptimisticLockException  caught: " + e.toString());
	    throw new DataOptimisticLockException("Error in BaseJpaDAO.deleteCore(Object deleteVO): " + e.toString(), e);
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.deleteCore(Object deleteVO) : " + e.toString(), e);
	}
	log.info("************Done **************");
    }

    public void delete(Object deleteVO) throws DataAccessException, DataOptimisticLockException {
	log.debug("************Entering ***************");
	try {
	    // if (deleteVO!=null){
	    // getEntityManager().remove(getEntityManager().merge(deleteVO));
	    // }
	    deleteCore(deleteVO);
	    if (flush) {
		flush();
	    }
	} catch (final OptimisticLockException e) {
	    log.error("OptimisticLockException  caught: " + e.toString());
	    throw new DataOptimisticLockException("Error in BaseJpaDAO.delete(Object deleteVO): " + e.toString(), e);
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.delete(Object deleteVO) : " + e.toString(), e);
	}
	log.info("************Done **************");
    }

    public void deleteCollection(Collection deleteVOs) throws DataAccessException, DataOptimisticLockException {
	log.info("************Entering ***************");
	try {

	    deleteCollectionCore(deleteVOs);
	    if (flush) {
		flush();
	    }
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.deleteCollectionCore(Collection deleteVOs) : " + e.toString(), e);
	}
	log.info("************Done **************");

    }

    private void deleteCollectionCore(Collection deleteVOs) throws DataAccessException {
	log.info("************Entering ***************");
	try {
	    if (deleteVOs == null) {
		return;
	    }
	    final Iterator iterator = deleteVOs.iterator();
	    while (iterator.hasNext()) {
		final Object deleteVO = iterator.next();
		// getEntityManager().remove(getEntityManager().merge(deleteVO));
		deleteCore(deleteVO);
	    }

	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.deleteCollectionCore(Collection deleteVOs) : " + e.toString(), e);
	}
	log.info("************Done **************");

    }

    public void deleteMToNRelationshipCollection(Object left, String leftFieldName, Collection rightCollection) throws DataAccessException {
	log.info("************Entering***************");
	try {
	    // Object cloneLeft = BeanUtilsBean.getInstance().cloneBean(left);

	    deleteMToNRelationshipCollectionCore(left, leftFieldName, rightCollection);
	    if (flush) {
		flush();
	    }
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.deleteMToNRelationshipCollection(Object left, String leftFieldName, Collection rightCollection) : " + e.toString(), e);
	}
	log.info("************Done  ***************");

    }

    private void deleteMToNRelationshipCollectionCore(Object left, String leftFieldName, Collection rightCollection) throws DataAccessException {
	log.info("************Entering***************");
	// JoinTable joinTable =
	// getAnnotation(getEntityClass(left),leftFieldName,JoinTable.class);
	// String[] columnNames = getJoinTableColumnName(joinTable);
	// String[] inverseColumnNames
	// =getJoinTableInverseColumnName(joinTable);
	//
	// String queryString =" DELETE FROM "+joinTable.name();

	try {
	    final Object managedLeft = getEntityManager().merge(left);
	    final PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();
	    // EntityInfo entityInfo = new
	    // EntityInfo(getClassFromPath(left.getClass(), leftFieldName));
	    final EntityInfo entityInfo = new EntityInfo(getClassFromPath(getEntityClass(left), leftFieldName));
	    // retrieveReference(managedLeft, leftFieldName);
	    final Collection leftFieldCollection = (Collection) propertyUtilsBean.getProperty(managedLeft, leftFieldName);
	    BeanCollectionUtils.removeAllFromCollection(leftFieldCollection, rightCollection, entityInfo.getPkNames());
	    // leftFieldCollection.retainAll(rightCollection);
	} catch (final IllegalAccessException e) {
	    log.error("IllegalAccessException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.deleteMToNRelationshipCollectionCore(Object left, String leftFieldName, Collection rightCollection) : " + e.toString(), e);
	} catch (final InvocationTargetException e) {
	    log.error("InvocationTargetException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.deleteMToNRelationshipCollectionCore(Object left, String leftFieldName, Collection rightCollection) : " + e.toString(), e);
	} catch (final NoSuchMethodException e) {
	    log.error("NoSuchMethodException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.deleteMToNRelationshipCollectionCore(Object left, String leftFieldName, Collection rightCollection) : " + e.toString(), e);
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.deleteMToNRelationshipCollectionCore(Object left, String leftFieldName, Collection rightCollection) : " + e.toString(), e);
	}
	log.info("************Done  ***************");

    }

    public void deleteItemsNotInCollectionsInPath(Object rootVO, String path, Boolean applyDeletePathCascade, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) throws DataAccessException {
	log.info("************Entering  ***************");
	try {
	    deleteItemsNotInCollectionsInPathCore(rootVO, path, applyDeletePathCascade, ifM2NDeleteOnlyRelationship, deleteOneToOne);
	    if (flush) {
		flush();
	    }
	} catch (final DataOptimisticLockException e) {
	    log.error("DataOptimisticLockException caught: " + e.toString());
	    throw new DataAccessException(
		    "Error in  BaseJpaDAO.deleteItemsNotInCollectionsInPath(Object rootVO, String path, Boolean applyDeletePathCascade, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne): "
			    + e.toString(),
		    e);
	}
	log.info("************Done  ***************");
    }

    public void deleteItemsNotInCollectionsInPath(Object rootVO, String path) throws DataAccessException {
	log.info("************Entering ***************");
	try {
	    deleteItemsNotInCollectionsInPathCore(rootVO, path, null, null, null);
	    if (flush) {
		flush();
	    }
	} catch (final DataOptimisticLockException e) {
	    log.error("DataOptimisticLockException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.deleteItemsNotInCollectionsInPath(Object rootVO, String path): " + e.toString(), e);
	}
	log.info("************Done  ***************");
    }

    public void deleteItemsNotInCollectionsInPath(Object rootVO, String path, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) throws DataAccessException {
	log.info("************Entering the BaseOjbPbDAO.deleteItemsNotInCollectionsInPath(Object rootVO, String path,Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) ***************");
	try {
	    deleteItemsNotInCollectionsInPathCore(rootVO, path, null, ifM2NDeleteOnlyRelationship, deleteOneToOne);
	    if (flush) {
		flush();
	    }
	} catch (final DataOptimisticLockException e) {
	    log.error("DataOptimisticLockException caught: " + e.toString());
	    throw new DataAccessException(
		    "Error in  BaseJpaDAO.deleteItemsNotInCollectionsInPath(Object rootVO, String path,Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne): " + e.toString(), e);
	}
	log.info("************Done with the BaseOjbPbDAO.deleteItemsNotInCollectionsInPath(Object rootVO, String path,Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) ***************");
    }

    /**
     *
     * @param rootVO
     * @param path
     * @param applyDeletePathCascade
     * @param ifM2NDeleteOnlyRelationship
     * @param deleteOneToOne
     * @throws DataAccessException
     */
    private void deleteItemsNotInCollectionsInPathCore_old(Object rootVO, String path, Boolean applyDeletePathCascade, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne)
	    throws DataAccessException, DataOptimisticLockException {
	log.info("************Entering  ***************");
	try {
	    if (path != null && !path.trim().equals("") && rootVO != null) {

		if (applyDeletePathCascade == null) {
		    applyDeletePathCascade = Boolean.TRUE;
		}
		if (ifM2NDeleteOnlyRelationship == null) {
		    ifM2NDeleteOnlyRelationship = Boolean.TRUE;
		}
		if (deleteOneToOne == null) {
		    deleteOneToOne = Boolean.FALSE;
		}

		final Class rootVOClass = getEntityClass(rootVO);

		final String[] firstAttributeNameAndRemainingPath = Utils.getFirstAttributeNameAndRemainingPath(path);
		final String firstAttributeName = firstAttributeNameAndRemainingPath[0];
		final String remainingPath = firstAttributeNameAndRemainingPath[1];

		final PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();

		final Integer relationType = getRelationType(rootVOClass, firstAttributeName);
		if (M_TO_N == relationType || M_TO_N_INVERSE == relationType || ONE_TO_N == relationType) {
		    final Collection notInBeanReferencedEntities = getCollectionOfStoredItemsNotInBean(rootVO, firstAttributeName);
		    if (notInBeanReferencedEntities != null) {
			if (M_TO_N == relationType || M_TO_N_INVERSE == relationType) {
			    final String inverseManyToManyField = getInverseManyToManyField(rootVO, firstAttributeName);
			    for (final Object notInBeanReferencedEntity : notInBeanReferencedEntities) {
				if (!StringUtils.isEmpty(inverseManyToManyField)) { // m2n
										    // (direct
										    // or
										    // inverse)
				    final Collection inverseCollection = (Collection) propertyUtilsBean.getProperty(notInBeanReferencedEntity, inverseManyToManyField);
				    inverseCollection.remove(rootVO);
				}
				if (applyDeletePathCascade.booleanValue() && !ifM2NDeleteOnlyRelationship) {
				    deletePathCascadeCore(notInBeanReferencedEntity, remainingPath, ifM2NDeleteOnlyRelationship, deleteOneToOne);
				}
			    }
			    if (!applyDeletePathCascade || ifM2NDeleteOnlyRelationship) {
				deleteCollectionCore(notInBeanReferencedEntities);
			    }
			} else {// ONE_TO_N
			    if (applyDeletePathCascade) {
				for (final Object notInBeanReferencedEntity : notInBeanReferencedEntities) {
				    deletePathCascadeCore(notInBeanReferencedEntity, remainingPath, ifM2NDeleteOnlyRelationship, deleteOneToOne);
				}
			    } else {
				deleteCollectionCore(notInBeanReferencedEntities);
			    }
			}

		    }

		} else if (relationType != null) {// MANY_TO_ONE or ONE_TO_ONE
		    final Object firstAttributeValue = propertyUtilsBean.getProperty(rootVO, firstAttributeName);
		    if (firstAttributeValue != null) {
			deleteItemsNotInCollectionsInPathCore(firstAttributeValue, remainingPath, applyDeletePathCascade, ifM2NDeleteOnlyRelationship, deleteOneToOne);
			if (deleteOneToOne) {
			    getEntityManager().remove(firstAttributeValue);
			    propertyUtilsBean.setProperty(rootVO, firstAttributeName, null);
			}
		    }
		}
	    }
	} catch (final IllegalAccessException e) {
	    log.error("IllegalAccessException caught: " + e.toString());
	    throw new DataAccessException(
		    "Error in  BaseJpaDAO.deleteItemsNotInCollectionsInPathCore(Object rootVO, String path, Boolean applyDeletePathCascade, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne): "
			    + e.toString(),
		    e);
	} catch (final InvocationTargetException e) {
	    log.error("InvocationTargetException caught: " + e.toString());
	    throw new DataAccessException(
		    "Error in  BaseJpaDAO.deleteItemsNotInCollectionsInPathCore(Object rootVO, String path, Boolean applyDeletePathCascade, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne): "
			    + e.toString(),
		    e);
	} catch (final NoSuchMethodException e) {
	    log.error("NoSuchMethodException caught: " + e.toString());
	    throw new DataAccessException(
		    "Error in  BaseJpaDAO.deleteItemsNotInCollectionsInPathCore(Object rootVO, String path, Boolean applyDeletePathCascade, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne): "
			    + e.toString(),
		    e);
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException(
		    "Error in  BaseJpaDAO.deleteItemsNotInCollectionsInPathCore(Object rootVO, String path, Boolean applyDeletePathCascade, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne): "
			    + e.toString(),
		    e);
	}
	log.info("************Done ***************");

    }

    /**
     *
     * @param rootVO
     * @param path
     * @param applyDeletePathCascade
     * @param ifM2NDeleteOnlyRelationship
     * @param deleteOneToOne
     * @throws DataAccessException
     */
    private void deleteItemsNotInCollectionsInPathCore(Object rootVO, String path, Boolean applyDeletePathCascade, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne)
	    throws DataAccessException, DataOptimisticLockException {
	log.info("************Entering  ***************");
	try {
	    final Collection paths = new ArrayList();
	    paths.add(path);
	    deleteItemsNotInCollectionsInPathsCore(rootVO, paths, false, applyDeletePathCascade, ifM2NDeleteOnlyRelationship, deleteOneToOne);

	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException(
		    "Error in  BaseJpaDAO.deleteItemsNotInCollectionsInPathCore(Object rootVO, String path, Boolean applyDeletePathCascade, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne): "
			    + e.toString(),
		    e);
	}
	log.info("************Done ***************");

    }

    public void deleteItemsNotInCollectionsInPaths(Object rootVO, Collection paths, Boolean applyDeletePathCascade, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne)
	    throws DataAccessException {
	log.info("************Entering ***************");
	try {
	    deleteItemsNotInCollectionsInPathsCore(rootVO, paths, Boolean.TRUE, applyDeletePathCascade, ifM2NDeleteOnlyRelationship, deleteOneToOne);
	    if (flush) {
		flush();
	    }
	} catch (final DataOptimisticLockException e) {
	    log.error("DataOptimisticLockException caught: " + e.toString());
	    throw new DataAccessException(
		    "Error in  BaseJpaDAO.deleteItemsNotInCollectionsInPaths(Object rootVO, Collection paths,  Boolean applyDeletePathCascade, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne): "
			    + e.toString(),
		    e);
	}
	log.info("************Done ***************");
    }

    private void deleteItemsNotInCollectionsInPathsCore(Object rootVO, Collection paths, Boolean pathsHasToBeSorted, Boolean applyDeletePathCascade, Boolean ifM2NDeleteOnlyRelationship,
	    Boolean deleteOneToOne) throws DataAccessException {
	log.info("************Entering ***************");

	try {
	    if (paths != null && !paths.isEmpty() && rootVO != null) {

		if (pathsHasToBeSorted == null) {
		    pathsHasToBeSorted = Boolean.TRUE;
		}
		if (applyDeletePathCascade == null) {
		    applyDeletePathCascade = Boolean.TRUE;
		}
		if (ifM2NDeleteOnlyRelationship == null) {
		    ifM2NDeleteOnlyRelationship = Boolean.TRUE;
		}
		if (deleteOneToOne == null) {
		    deleteOneToOne = Boolean.FALSE;
		}

		final PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();

		// Class rootVOClass = rootVO.getClass();
		final Class rootVOClass = getEntityClass(rootVO);

		String[] pathsArray = new String[paths.size()];
		if (pathsHasToBeSorted.booleanValue()) {
		    final ArrayList<String> pathsList = Collections.list(Collections.enumeration(paths));
		    Collections.sort(pathsList);
		    pathsArray = pathsList.toArray(pathsArray);
		} else {
		    pathsArray = (String[]) paths.toArray(pathsArray);
		}
		int index = 0;
		while (index < pathsArray.length) {
		    final String path = pathsArray[index];
		    if (path != null && !path.trim().equals("")) {
			final String[] firstAttributeNameAndRemainingPath = Utils.getFirstAttributeNameAndRemainingPath(path);
			final String firstAttributeName = firstAttributeNameAndRemainingPath[0];
			final String remainingPath = firstAttributeNameAndRemainingPath[1];
			final ArrayList<String> subPaths = new ArrayList<String>();
			if (!remainingPath.trim().equals("")) {
			    subPaths.add(remainingPath);
			}
			index++;
			boolean matchingFirstAttributeName = true;
			while (index < pathsArray.length && matchingFirstAttributeName) {
			    final String path2 = pathsArray[index];
			    if (path2 != null && !path2.trim().equals("")) {
				final String[] firstAttributeNameAndRemainingPath2 = Utils.getFirstAttributeNameAndRemainingPath(path2);
				final String firstAttributeName2 = firstAttributeNameAndRemainingPath2[0];
				final String remainingPath2 = firstAttributeNameAndRemainingPath2[1];
				if (firstAttributeName.equals(firstAttributeName2)) {
				    if (!remainingPath2.trim().equals("")) {
					subPaths.add(remainingPath2);
				    }
				    index++;
				} else {
				    matchingFirstAttributeName = false;
				}
			    } else {
				index++;
			    }

			}

			/*********************************************************************************************/
			final Integer relationType = getRelationType(rootVOClass, firstAttributeName);
			if (M_TO_N == relationType || M_TO_N_INVERSE == relationType || ONE_TO_N == relationType) {
			    final Collection notInBeanReferencedEntities = getCollectionOfStoredItemsNotInBean(rootVO, firstAttributeName);
			    if (notInBeanReferencedEntities != null) {
				if (M_TO_N == relationType || M_TO_N_INVERSE == relationType) {
				    final String inverseManyToManyField = getInverseManyToManyField(rootVO, firstAttributeName);
				    for (final Object notInBeanReferencedEntity : notInBeanReferencedEntities) {
					if (!StringUtils.isEmpty(inverseManyToManyField)) { // m2n
											    // (direct
											    // or
											    // inverse)
					    final Collection inverseCollection = (Collection) propertyUtilsBean.getProperty(notInBeanReferencedEntity, inverseManyToManyField);
					    inverseCollection.remove(rootVO);
					}
					if (applyDeletePathCascade.booleanValue() && !ifM2NDeleteOnlyRelationship.booleanValue()) {
					    deletePathsCascadeCore(notInBeanReferencedEntity, subPaths, Boolean.FALSE, ifM2NDeleteOnlyRelationship, deleteOneToOne);
					} else if (!ifM2NDeleteOnlyRelationship) {// applyDeletePathCascade
										  // is
										  // false
					    deleteCore(notInBeanReferencedEntity);
					}
				    }
				    // if(!applyDeletePathCascade.booleanValue()
				    // ||
				    // ifM2NDeleteOnlyRelationship.booleanValue()){
				    // deleteCollectionCore(notInBeanReferencedEntities);
				    // }
				} else {// ONE_TO_N
				    if (applyDeletePathCascade) {
					for (final Object notInBeanReferencedEntity : notInBeanReferencedEntities) {
					    deletePathsCascadeCore(notInBeanReferencedEntity, subPaths, Boolean.FALSE, ifM2NDeleteOnlyRelationship, deleteOneToOne);
					}
				    } else {
					deleteCollectionCore(notInBeanReferencedEntities);
				    }
				}

			    }

			} else if (relationType != null) {// MANY_TO_ONE or
							  // ONE_TO_ONE OR
							  // EMBEDDED_ID
			    final Object firstAttributeValue = propertyUtilsBean.getProperty(rootVO, firstAttributeName);
			    if (firstAttributeValue != null) {
				deleteItemsNotInCollectionsInPathsCore(firstAttributeValue, subPaths, Boolean.FALSE, applyDeletePathCascade, ifM2NDeleteOnlyRelationship, deleteOneToOne);
				if (deleteOneToOne.booleanValue()) {
				    final EntityInfo entityInfo = new EntityInfo(rootVOClass);
				    if (!entityInfo.isEmbeddable()) {
					// getEntityManager().remove(firstAttributeValue);
					deleteCore(firstAttributeValue);
					propertyUtilsBean.setProperty(rootVO, firstAttributeName, null);
				    }
				}
			    }
			}

			/*********************************************************************************************/
			// if(subPaths.size()>1){
			// ManyToMany manyToMany = (ManyToMany)
			// getAnnotation(rootVOClass, firstAttributeName,
			// ManyToMany.class);
			// OneToMany oneToMany = null;
			// OneToOne oneToOne = null;
			// ManyToOne manyToOne = null ;
			//
			//
			// if(manyToMany==null){
			// oneToMany = (OneToMany) getAnnotation(rootVOClass,
			// firstAttributeName, OneToMany.class);
			// if(oneToMany==null){
			// manyToOne = (ManyToOne) getAnnotation(rootVOClass,
			// firstAttributeName, ManyToOne.class);
			// if(manyToOne == null){
			// oneToOne = (OneToOne) getAnnotation(rootVOClass,
			// firstAttributeName, OneToOne.class);
			// if(oneToOne == null)throw new
			// DataAccessException("Error in
			// BaseJpaDAO.deleteItemsNotInCollectionsInPathsCore(Object
			// rootVO, Collection paths, Boolean pathsHasToBeSorted,
			// Boolean applyDeletePathCascade, Boolean
			// ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne):
			// Error: firstAttributeName is no ManyToOne, no
			// OneToMnay, no OneToOne, no ManyToMany " );
			// }
			// }
			// }
			//
			//
			//
			//
			//
			//
			//
			// Object firstAttributeValue =
			// propertyUtilsBean.getProperty(rootVO,firstAttributeName);
			// if(oneToMany!=null || manyToMany!=null){
			// Collection notInBeanReferencedEntities =
			// getCollectionOfStoredItemsNotInBean(rootVO,
			// firstAttributeName);
			// if(oneToMany!=null ||
			// !ifM2NDeleteOnlyRelationship.booleanValue()){
			// if(applyDeletePathCascade.booleanValue()){
			// if(notInBeanReferencedEntities != null){
			// Iterator iterator =
			// notInBeanReferencedEntities.iterator();
			// while(iterator.hasNext()){
			// deletePathsCascadeCore(iterator.next(),subPaths,Boolean.FALSE,ifM2NDeleteOnlyRelationship,deleteOneToOne);
			// }
			// }
			// } else{
			// deleteCollectionCore(notInBeanReferencedEntities);
			// }
			// }// If it is manyToMnay and
			// ifM2NDeleteOnlyRelationship the relationship will be
			// removed on flush
			// if(firstAttributeValue!=null){
			// Iterator iterator =
			// ((Collection)firstAttributeValue).iterator();
			// while(iterator.hasNext()){
			// deleteItemsNotInCollectionsInPathsCore(iterator.next(),subPaths,
			// Boolean.FALSE, applyDeletePathCascade,
			// ifM2NDeleteOnlyRelationship, deleteOneToOne);
			// }
			// }
			// }else{ // firstAttributeValue is not a collection
			// deleteItemsNotInCollectionsInPathsCore(firstAttributeValue,subPaths,
			// Boolean.FALSE, applyDeletePathCascade,
			// ifM2NDeleteOnlyRelationship, deleteOneToOne);
			// }
			// }else { //subPaths.size()<=1
			// deleteItemsNotInCollectionsInPathCore(rootVO, path,
			// applyDeletePathCascade, ifM2NDeleteOnlyRelationship,
			// deleteOneToOne);
			// }

		    } else {
			index++;
		    }
		}
	    }
	} catch (final IllegalAccessException e) {
	    log.error(
		    "Exception caught in BaseJpaDAO.deleteItemsNotInCollectionsInPathsCore(Object rootVO, Collection paths,  Boolean pathsHasToBeSorted, Boolean applyDeletePathCascade, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) : "
			    + e.toString());
	    throw new DataAccessException(
		    "Error in BaseJpaDAO.deleteItemsNotInCollectionsInPathsCore(Object rootVO, Collection paths,  Boolean pathsHasToBeSorted, Boolean applyDeletePathCascade, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) : "
			    + e.toString(),
		    e);
	} catch (final InvocationTargetException e) {
	    log.error(
		    "InvocationTargetException caught in BaseJpaDAO.deleteItemsNotInCollectionsInPathsCore(Object rootVO, Collection paths,  Boolean pathsHasToBeSorted, Boolean applyDeletePathCascade, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) : "
			    + e.toString());
	    throw new DataAccessException(
		    "Error in BaseJpaDAO.deleteItemsNotInCollectionsInPathsCore(Object rootVO, Collection paths,  Boolean pathsHasToBeSorted, Boolean applyDeletePathCascade, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) : "
			    + e.toString(),
		    e);
	} catch (final NoSuchMethodException e) {
	    log.error(
		    "NoSuchMethodException caught in BaseJpaDAO.deleteItemsNotInCollectionsInPathsCore(Object rootVO, Collection paths,  Boolean pathsHasToBeSorted, Boolean applyDeletePathCascade, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) : "
			    + e.toString());
	    throw new DataAccessException(
		    "Error in BaseJpaDAO.deleteItemsNotInCollectionsInPathsCore(Object rootVO, Collection paths,  Boolean pathsHasToBeSorted, Boolean applyDeletePathCascade, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) : "
			    + e.toString(),
		    e);
	} catch (final Exception e) {
	    log.error(
		    "Exception caught in BaseJpaDAO.deleteItemsNotInCollectionsInPathsCore(Object rootVO, Collection paths,  Boolean pathsHasToBeSorted, Boolean applyDeletePathCascade, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) : "
			    + e.toString());
	    throw new DataAccessException(
		    "Error in BaseJpaDAO.deleteItemsNotInCollectionsInPathsCore(Object rootVO, Collection paths,  Boolean pathsHasToBeSorted, Boolean applyDeletePathCascade, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) : "
			    + e.toString(),
		    e);
	}

	log.info("************Done   ***************");

    }

    public void deletePathCascade(Object parentVO, String path, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) throws DataAccessException {
	log.info("************Entering  ***************");
	try {
	    if (parentVO != null) {
		if (ifM2NDeleteOnlyRelationship == null) {
		    ifM2NDeleteOnlyRelationship = Boolean.TRUE;
		}
		if (deleteOneToOne == null) {
		    deleteOneToOne = Boolean.FALSE;
		}

		deletePathCascadeCore(parentVO, path, ifM2NDeleteOnlyRelationship, deleteOneToOne);

		if (flush) {
		    flush();
		}
	    }
	} catch (final Exception e) {
	    log.error("Exception thrown in BaseJpaDAO.deletePathCascade(Object parentVO, String path, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) : " + e.toString());
	    throw new DataAccessException("Error in BaseJpaDAO.deletePathCascade(Object parentVO, String path, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) : " + e.toString(), e);
	}
	log.info("************Done   ***************");

    }

    // private void deletePathsCascadeCore(Object parentVO,Collection
    // paths,Boolean pathsHasToBeSorted,Boolean ifM2NDeleteOnlyRelationship,
    // Boolean deleteOneToOne) throws DataAccessException{
    private void deletePathCascadeCore(Object parentVO, String path, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) throws DataAccessException, DataOptimisticLockException {
	log.info("************Entering ***************");
	try {
	    final Collection paths = new ArrayList();
	    paths.add(path);
	    deletePathsCascadeCore(parentVO, paths, false, ifM2NDeleteOnlyRelationship, deleteOneToOne);

	} catch (final Exception e) {
	    log.error("Exception thrown in BaseJpaDAO.deletePathCascadeCore(Object parentVO, String path, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) : " + e.toString());
	    throw new DataAccessException("Error in BaseJpaDAO.deletePathCascadeCore(Object parentVO, String path, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) : " + e.toString(), e);
	}
	log.info("************Done ***************");
    }

    private void deletePathCascadeCore_old(Object parentVO, String path, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) throws DataAccessException, DataOptimisticLockException {
	log.info("************Entering ***************");
	try {
	    if (parentVO != null) {
		// Object mergedParentVO;
		// if(getEntityManager().contains(parentVO)){
		// mergedParentVO=parentVO;
		// }else{
		// mergedParentVO = getEntityManager().merge(parentVO);
		// }
		// Object mergedParentVO = getEntityManager().merge(parentVO);
		if (path == null || path.trim().equals("")) {
		    // getEntityManager().remove(mergedParentVO);
		    deleteCore(parentVO);
		} else {
		    // Class parentVOClass = getEntityClass(parentVO);

		    ArrayList lastLevelEntities = new ArrayList();
		    final ArrayList toBeDeletedEntities = new ArrayList();
		    // lastLevelEntities.add(mergedParentVO);
		    // toBeDeletedEntities.add(mergedParentVO);

		    lastLevelEntities.add(parentVO);
		    toBeDeletedEntities.add(parentVO);

		    final String[] splitPath = path.split("\\.");

		    int endIndex = 0;
		    final int pathSize = splitPath.length;
		    boolean follow = true;
		    String pathToken = null;
		    while (endIndex < pathSize && !lastLevelEntities.isEmpty() && follow) {

			final Class parentVOClass = getEntityClass(lastLevelEntities.iterator().next());
			pathToken = splitPath[endIndex];

			final ManyToMany manyToMany = (ManyToMany) getAnnotation(parentVOClass, pathToken, ManyToMany.class);
			OneToMany oneToMany = null;
			OneToOne oneToOne = null;
			ManyToOne manyToOne = null;

			if (manyToMany != null) {
			    if (ifM2NDeleteOnlyRelationship.booleanValue()) {
				follow = false;
			    } else {
				follow = true;
			    }
			} else {
			    oneToMany = (OneToMany) getAnnotation(parentVOClass, pathToken, OneToMany.class);
			    if (oneToMany != null) {
				follow = true;
			    } else { // not a collection
				oneToOne = (OneToOne) getAnnotation(parentVOClass, pathToken, OneToOne.class);
				if (oneToOne == null) {
				    manyToOne = (ManyToOne) getAnnotation(parentVOClass, pathToken, ManyToOne.class);
				    if (manyToOne == null) {
					throw new DataAccessException(
						"Error in BaseJpaDAO.deletePathCascadeCore(Object parentVO, String path, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne): Error:splitPath("
							+ endIndex + ")  is no ManyToOne, no OneToMnay, no OneToOne, no ManyToMany and no CollectionDescriptor");
				    }
				}
				if (deleteOneToOne.booleanValue()) {
				    follow = true;
				} else {
				    follow = false;
				}
			    }
			}

			if (manyToMany != null) {
			    final ArrayList newLastLevelEntities = new ArrayList();
			    if (!ifM2NDeleteOnlyRelationship.booleanValue()) {
				log.debug("lastLevelEntities.size() = " + lastLevelEntities.size());
				final Iterator iterator = lastLevelEntities.iterator();// lastLevelEntities
										       // is
										       // never
										       // null
				while (iterator.hasNext()) {
				    final Object left = iterator.next();
				    final Collection referencedEntities = getStoredCollection(left, pathToken);
				    if (referencedEntities != null) {
					log.debug("referencedEntities.size() = " + referencedEntities.size());
					newLastLevelEntities.addAll(referencedEntities);
				    }
				}
			    }
			    Collections.reverse(toBeDeletedEntities);
			    deleteCollectionCore(toBeDeletedEntities);
			    lastLevelEntities = newLastLevelEntities;
			    toBeDeletedEntities.clear();
			    toBeDeletedEntities.addAll(lastLevelEntities);
			} else if (oneToMany != null) {
			    final ArrayList partialPathEntities = getPartialPathEntities(lastLevelEntities, splitPath, endIndex, endIndex);
			    toBeDeletedEntities.addAll(partialPathEntities); // getPartialPathEntities
									     // never
									     // returns
									     // null!!
			    lastLevelEntities = partialPathEntities;
			} else if (oneToOne != null || manyToOne != null) {
			    ArrayList partialPathEntities = new ArrayList();
			    if (deleteOneToOne.booleanValue()) {
				partialPathEntities = getPartialPathEntities(lastLevelEntities, splitPath, endIndex, endIndex);
			    }
			    Collections.reverse(toBeDeletedEntities);
			    deleteCollectionCore(toBeDeletedEntities);
			    lastLevelEntities = partialPathEntities; // in the
								     // case of
								     // Not
								     // deleteOneToOne
								     // partialPathEntities
								     // is empty
			    toBeDeletedEntities.clear();
			    toBeDeletedEntities.addAll(partialPathEntities);
			} else {
			    throw new DataAccessException(
				    "Error in BaseJpaDAO.deletePathCascadeCore(Object parentVO, String path, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne): Error:splitPath(" + endIndex
					    + ")  is no ManyToOne, no OneToMnay, no OneToOne, no ManyToMany and no CollectionDescriptor");
			}
			endIndex++;
		    }
		    Collections.reverse(toBeDeletedEntities);
		    deleteCollectionCore(toBeDeletedEntities);
		}
	    }
	} catch (final Exception e) {
	    log.error("Exception thrown in BaseJpaDAO.deletePathCascadeCore(Object parentVO, String path, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) : " + e.toString());
	    throw new DataAccessException("Error in BaseJpaDAO.deletePathCascadeCore(Object parentVO, String path, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) : " + e.toString(), e);
	}
	log.info("************Done ***************");
    }

    public void deletePathsCascade(Object parentVO, Collection paths, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) throws DataAccessException {
	log.info("************Entering ***************");
	try {
	    if (parentVO != null) {
		if (ifM2NDeleteOnlyRelationship == null) {
		    ifM2NDeleteOnlyRelationship = Boolean.TRUE;
		}
		if (deleteOneToOne == null) {
		    deleteOneToOne = Boolean.FALSE;
		}
		deletePathsCascadeCore(parentVO, paths, Boolean.TRUE, ifM2NDeleteOnlyRelationship, deleteOneToOne);
		if (flush) {
		    flush();
		}
	    }
	} catch (final DataOptimisticLockException e) {
	    log.error("DataOptimisticLockException thrown in BaseJpaDAO.deletePathsCascade(Object parentVO,Collection paths,Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) : "
		    + e.toString());
	    throw new DataAccessException("Error in BaseJpaDAO.deletePathsCascade(Object parentVO,Collection paths,Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne): " + e.toString(), e);
	} catch (final Exception e) {
	    log.error("Exception thrown in BaseJpaDAO.deletePathsCascade(Object parentVO,Collection paths,Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) : " + e.toString());
	    throw new DataAccessException("Error in BaseJpaDAO.deletePathsCascade(Object parentVO,Collection paths,Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) : " + e.toString(), e);
	}
	log.info("************Done  ***************");
    }

    private void deletePathsCascadeCore(Object parentVO, Collection paths, Boolean pathsHasToBeSorted, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) throws DataAccessException {
	log.info("************Entering ***************");
	// List<Graph> notDeletedGraphs = new ArrayList<Graph>();
	try {
	    if (parentVO != null) {
		final PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();

		if (ifM2NDeleteOnlyRelationship == null) {
		    ifM2NDeleteOnlyRelationship = Boolean.TRUE;
		}
		if (deleteOneToOne == null) {
		    deleteOneToOne = Boolean.FALSE;
		}
		if (pathsHasToBeSorted == null) {
		    pathsHasToBeSorted = Boolean.TRUE;
		}

		// Class parentVOClass = parentVO.getClass();
		final Class parentVOClass = getEntityClass(parentVO);

		if (paths == null || paths.isEmpty()) {
		    getEntityManager().remove(getEntityManager().merge(parentVO));
		} else {

		    String[] pathsArray = new String[paths.size()];
		    if (pathsHasToBeSorted.booleanValue()) {
			final ArrayList<String> pathsList = Collections.list(Collections.enumeration(paths));
			Collections.sort(pathsList);
			pathsArray = pathsList.toArray(pathsArray);
		    } else {
			pathsArray = (String[]) paths.toArray(pathsArray);
		    }
		    int index = 0;

		    final HashMap<String, ArrayList<String>> directReferenceMap = new HashMap<String, ArrayList<String>>(); // map
															    // for
															    // oneToOne
															    // and
															    // MToOne

		    final HashMap<String, ArrayList<String>> oneToNReferenceMap = new HashMap<String, ArrayList<String>>();

		    final HashMap<String, ArrayList<String>> mToNReferenceMap = new HashMap<String, ArrayList<String>>();

		    final HashMap<String, ArrayList<String>> mToNInverseReferenceMap = new HashMap<String, ArrayList<String>>();

		    while (index < pathsArray.length) {
			final String path = pathsArray[index];
			if (path != null && !path.trim().equals("")) {
			    final String[] firstAttributeNameAndRemainingPath = Utils.getFirstAttributeNameAndRemainingPath(path);
			    final String firstAttributeName = firstAttributeNameAndRemainingPath[0];
			    final ArrayList<String> subPaths = new ArrayList<String>();

			    final Integer relationType = getRelationType(parentVOClass, firstAttributeName);

			    if (!firstAttributeNameAndRemainingPath[1].trim().equals("")) {
				subPaths.add(firstAttributeNameAndRemainingPath[1]);
			    }

			    index++;
			    boolean matchingFirstAttributeName = true;
			    while (index < pathsArray.length && matchingFirstAttributeName) {
				final String path2 = pathsArray[index];
				if (path2 != null && !path2.trim().equals("")) {
				    final String[] firstAttributeNameAndRemainingPath2 = Utils.getFirstAttributeNameAndRemainingPath(path2);
				    final String firstAttributeName2 = firstAttributeNameAndRemainingPath2[0];
				    if (firstAttributeName.equals(firstAttributeName2)) {
					if (!firstAttributeNameAndRemainingPath2[1].trim().equals("")) {
					    subPaths.add(firstAttributeNameAndRemainingPath2[1]);
					}
					index++;
				    } else {
					matchingFirstAttributeName = false;
				    }
				} else {
				    index++;
				}
			    }

			    switch (relationType) {
			    case ONE_TO_ONE:
				directReferenceMap.put(firstAttributeName, subPaths);
				break;
			    case M_TO_ONE:
				directReferenceMap.put(firstAttributeName, subPaths);
				break;
			    case EMBEDDED_ID:
				directReferenceMap.put(firstAttributeName, subPaths);
				break;
			    case ONE_TO_N:
				oneToNReferenceMap.put(firstAttributeName, subPaths);
				break;
			    case M_TO_N:
				mToNReferenceMap.put(firstAttributeName, subPaths);
				break;
			    case M_TO_N_INVERSE:
				mToNInverseReferenceMap.put(firstAttributeName, subPaths);
				break;
			    }

			} else {
			    index++;
			}
		    }

		    /*
		     * ONE_TO_N
		     */
		    Iterator<String> iterator = oneToNReferenceMap.keySet().iterator();
		    while (iterator.hasNext()) {
			final String firstAttributeName = iterator.next();
			log.debug("deletePathsCascadeCore in oneToNReferenceMap: firstAttributeName = " + firstAttributeName);

			final Collection storedChildren = getStoredCollection(parentVO, firstAttributeName);
			final ArrayList<String> subPaths = oneToNReferenceMap.get(firstAttributeName);
			final Collection children = (Collection) propertyUtilsBean.getProperty(parentVO, firstAttributeName);
			if (children != null) {
			    children.clear();
			}
			if (storedChildren != null) {
			    for (final Object child : storedChildren) {
				deletePathsCascadeCore(child, subPaths, Boolean.FALSE, ifM2NDeleteOnlyRelationship, deleteOneToOne);
			    }
			}
			//// boolean isCascadeRemove = isCascade(parentVO,
			//// firstAttributeName, CascadeType.REMOVE);
			//// ArrayList<String> subPaths =
			//// oneToNReferenceMap.get(firstAttributeName);
			// Collection storedChildren = null;
			// if(isCascadeRemove){
			// storedChildren =
			//// getCollectionOfStoredItemsNotInBean(parentVO,
			//// firstAttributeName);
			// Collection storedItemsInBeanChildren =
			//// getCollectionOfStoredItemsInBean(parentVO,
			//// firstAttributeName);
			// for(Object child:storedItemsInBeanChildren){
			//// notDeletedGraphs.addAll(deletePathsCascadeCore(child,subPaths,Boolean.FALSE,ifM2NDeleteOnlyRelationship,deleteOneToOne));
			// deletePathsCascadeCore(child,subPaths,Boolean.FALSE,ifM2NDeleteOnlyRelationship,deleteOneToOne);
			// }
			//
			// }else{
			//
			// storedChildren = getStoredCollection(parentVO,
			//// firstAttributeName);
			//
			// }
			// if(storedChildren!=null &&
			//// !storedChildren.isEmpty()){
			//
			// for(Object child:storedChildren){
			//// notDeletedGraphs.addAll(deletePathsCascadeCore(child,subPaths,Boolean.FALSE,ifM2NDeleteOnlyRelationship,deleteOneToOne));
			// deletePathsCascadeCore(child,subPaths,Boolean.FALSE,ifM2NDeleteOnlyRelationship,deleteOneToOne);
			// }
			//
			// }
		    }

		    /*
		     * M_TO_N_INVERSE
		     */
		    processM2NDeletePathsCascade(parentVO, mToNInverseReferenceMap, ifM2NDeleteOnlyRelationship, deleteOneToOne);
		    // iterator = mToNInverseReferenceMap.keySet().iterator();
		    // while(iterator.hasNext()){
		    // String firstAttributeName = iterator.next();
		    // log.debug("deletePathsCascadeCore in
		    // mToNInverseReferenceMap: firstAttributeName =
		    // "+firstAttributeName);
		    // Collection storedChildren = getStoredCollection(parentVO,
		    // firstAttributeName);
		    // ArrayList<String> subPaths =
		    // mToNInverseReferenceMap.get(firstAttributeName);
		    //
		    // if(storedChildren!=null){
		    //
		    //// String mappedBy = getMappedBy(parentVO,
		    // firstAttributeName); // being an inverse m2m mappedyBY
		    // surely exists
		    // for(Object child:storedChildren){
		    // /*
		    // * remove parentVO from reverse collection
		    // */
		    //
		    // String inverseManyToManyField =
		    // getInverseManyToManyField(parentVO, firstAttributeName);
		    // Collection inverseCollection = (Collection)
		    // propertyUtilsBean.getProperty(child,
		    // inverseManyToManyField);
		    // inverseCollection.remove(parentVO);
		    //
		    // /*
		    // * clear this collection
		    // */
		    // Collection children = (Collection)
		    // propertyUtilsBean.getProperty(parentVO,
		    // firstAttributeName);
		    // children.clear();
		    //
		    // /*
		    // * delete child
		    // */
		    // if(!ifM2NDeleteOnlyRelationship){
		    //// notDeletedGraphs.addAll(deletePathsCascadeCore(child,subPaths,Boolean.FALSE,ifM2NDeleteOnlyRelationship,deleteOneToOne));
		    // deletePathsCascadeCore(child,subPaths,Boolean.FALSE,ifM2NDeleteOnlyRelationship,deleteOneToOne);
		    // }
		    // }
		    // }
		    // }

		    final EntityInfo entityInfo = new EntityInfo(parentVOClass);
		    if (!entityInfo.isEmbeddable()) {
			deleteCore(parentVO);

		    }

		    /*
		     * M_TO_N
		     */
		    processM2NDeletePathsCascade(parentVO, mToNReferenceMap, ifM2NDeleteOnlyRelationship, deleteOneToOne);
		    // iterator = mToNReferenceMap.keySet().iterator();
		    // while(iterator.hasNext()) {
		    // String firstAttributeName = iterator.next();
		    // log.debug("deletePathsCascadeCore in mToNReferenceMap:
		    // firstAttributeName = "+firstAttributeName);
		    // Collection storedChildren = getStoredCollection(parentVO,
		    // firstAttributeName);
		    // ArrayList<String> subPaths =
		    // mToNInverseReferenceMap.get(firstAttributeName);
		    // if(storedChildren!=null){
		    // for(Object child:storedChildren){
		    // /*
		    // * remove parentVO from reverse collection
		    // */
		    // String inverseManyToManyField =
		    // getInverseManyToManyField(parentVO, firstAttributeName);
		    // Collection inverseCollection = (Collection)
		    // propertyUtilsBean.getProperty(child,
		    // inverseManyToManyField);
		    // inverseCollection.remove(parentVO);
		    //
		    // /*
		    // * clear the inverse m2m collection
		    // */
		    // Collection children = (Collection)
		    // propertyUtilsBean.getProperty(parentVO,
		    // firstAttributeName);
		    // children.clear();
		    //
		    // /*
		    // * delete child
		    // */
		    // if(!ifM2NDeleteOnlyRelationship){
		    // deletePathsCascadeCore(child,subPaths,Boolean.FALSE,ifM2NDeleteOnlyRelationship,deleteOneToOne);
		    // }
		    // }
		    // }
		    // }

		    /*
		     * ONE_TO_ONE and M_TO_ONE
		     */
		    // HashMap<String,Object> directReferencedObjectMap= new
		    // HashMap<String, Object>();
		    iterator = directReferenceMap.keySet().iterator();
		    while (iterator.hasNext()) {
			final String firstAttributeName = iterator.next();
			if (deleteOneToOne.booleanValue()) {
			    final ArrayList<String> subPaths = directReferenceMap.get(firstAttributeName);
			    retrieveReference(parentVO, firstAttributeName);
			    final Object referencedObject = propertyUtilsBean.getProperty(parentVO, firstAttributeName);
			    propertyUtilsBean.setProperty(parentVO, firstAttributeName, null);
			    deletePathsCascadeCore(referencedObject, subPaths, Boolean.FALSE, ifM2NDeleteOnlyRelationship, deleteOneToOne);
			} else {
			    propertyUtilsBean.setProperty(parentVO, firstAttributeName, null);
			}

		    }

		    // if(deleteOneToOne){
		    // iterator = directReferenceMap.keySet().iterator();
		    // while(iterator.hasNext()) {
		    // String firstAttributeName = iterator.next();
		    // Object referencedObject =
		    // propertyUtilsBean.getProperty(parentVO,
		    // firstAttributeName);
		    // log.debug("deletePathsCascadeCore in directReferenceMap:
		    // firstAttributeName = "+firstAttributeName);
		    // if(referencedObject!=null)
		    // directReferencedObjectMap.put(firstAttributeName,
		    // referencedObject);
		    // }
		    // }

		    // getEntityManager().remove(getEntityManager().merge(parentVO));

		    // if(!ifM2NDeleteOnlyRelationship) {
		    // iterator =
		    // mToNReferencedCollectionMap.keySet().iterator();
		    // while(iterator.hasNext()) {
		    // String firstAttributeName = iterator.next();
		    // log.debug("deletePathsCascadeCore in
		    // mToNReferencedCollectionMap iteration: firstAttributeName
		    // = "+firstAttributeName);
		    //
		    // Collection children =
		    // mToNReferencedCollectionMap.get(firstAttributeName);
		    // if(children!=null ){
		    // Iterator childrenIterator = children.iterator();
		    // while(childrenIterator.hasNext()){
		    // deletePathsCascadeCore(childrenIterator.next(),mToNReferenceMap.get(firstAttributeName),Boolean.FALSE,ifM2NDeleteOnlyRelationship,deleteOneToOne);
		    // }
		    // }
		    // }
		    // }

		    // if(deleteOneToOne){
		    // iterator = directReferencedObjectMap.keySet().iterator();
		    // while(iterator.hasNext()) {
		    // String firstAttributeName = iterator.next();
		    // log.debug("deleteIdentityPathsCascade in
		    // directReferencedObjectMap iteration: firstAttributeName =
		    // "+firstAttributeName);
		    //
		    // Object child =
		    // directReferencedObjectMap.get(firstAttributeName);
		    // if(child==null){
		    // log.debug("child is null");
		    // }else {//(child==null!=null)
		    // log.debug("child :"+child.toString());
		    // deletePathsCascadeCore(child,directReferenceMap.get(firstAttributeName),Boolean.FALSE,ifM2NDeleteOnlyRelationship,deleteOneToOne);
		    // }
		    // }
		    // }

		}
	    }
	} catch (final IllegalAccessException e) {
	    log.error(
		    "IllegalAccessException thrown in BaseJpaDAO.deletePathsCascadeCore(Object parentVO,Collection paths,Boolean  pathsHasToBeSorted,Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) : "
			    + e.toString());
	    throw new DataAccessException(
		    "Error in BaseJpaDAO.deletePathsCascadeCore(Object parentVO,Collection paths,Boolean  pathsHasToBeSorted,Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) : "
			    + e.toString(),
		    e);
	} catch (final InvocationTargetException e) {
	    log.error(
		    "InvocationTargetException thrown in BaseJpaDAO.deletePathsCascadeCore(Object parentVO,Collection paths,Boolean  pathsHasToBeSorted,Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) : "
			    + e.toString());
	    throw new DataAccessException(
		    "Error in BaseJpaDAO.deletePathsCascadeCore(Object parentVO,Collection paths,Boolean  pathsHasToBeSorted,Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) : "
			    + e.toString(),
		    e);
	} catch (final NoSuchMethodException e) {
	    log.error(
		    "NoSuchMethodException thrown in BaseJpaDAO.deletePathsCascadeCore(Object parentVO,Collection paths,Boolean  pathsHasToBeSorted,Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) : "
			    + e.toString());
	    throw new DataAccessException(
		    "Error in BaseJpaDAO.deletePathsCascadeCore(Object parentVO,Collection paths,Boolean  pathsHasToBeSorted,Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) : "
			    + e.toString(),
		    e);
	} catch (final Exception e) {
	    log.error(
		    "Exception thrown in BaseJpaDAO.deletePathsCascadeCore(Object parentVO,Collection paths,Boolean  pathsHasToBeSorted,Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) : "
			    + e.toString());
	    throw new DataAccessException(
		    "Error in BaseJpaDAO.deletePathsCascadeCore(Object parentVO,Collection paths,Boolean  pathsHasToBeSorted,Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) : "
			    + e.toString(),
		    e);
	}

	log.info("************Done  ***************");
    }

    private void processM2NDeletePathsCascade(Object parentVO, HashMap<String, ArrayList<String>> map, boolean ifM2NDeleteOnlyRelationship, boolean deleteOneToOne) throws DataAccessException {

	try {
	    final PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();
	    final Iterator<String> iterator = map.keySet().iterator();
	    while (iterator.hasNext()) {
		final String firstAttributeName = iterator.next();
		final Collection storedChildren = getStoredCollection(parentVO, firstAttributeName);
		final ArrayList<String> subPaths = map.get(firstAttributeName);
		/*
		 * clear the inverse m2m collection
		 */
		final Collection children = (Collection) propertyUtilsBean.getProperty(parentVO, firstAttributeName);
		if (children != null) {
		    children.clear();
		}
		if (storedChildren != null) {
		    for (final Object child : storedChildren) {
			/*
			 * remove parentVO from reverse collection
			 */
			final String inverseManyToManyField = getInverseManyToManyField(parentVO, firstAttributeName);
			if (!StringUtils.isEmpty(inverseManyToManyField)) {
			    final Collection inverseCollection = (Collection) propertyUtilsBean.getProperty(child, inverseManyToManyField);
			    inverseCollection.remove(parentVO);
			}

			/*
			 * delete child
			 */
			if (!ifM2NDeleteOnlyRelationship) {
			    // notDeletedGraphs.addAll(deletePathsCascadeCore(child,subPaths,Boolean.FALSE,ifM2NDeleteOnlyRelationship,deleteOneToOne));
			    deletePathsCascadeCore(child, subPaths, Boolean.FALSE, ifM2NDeleteOnlyRelationship, deleteOneToOne);
			}
		    }
		}
	    }
	} catch (final IllegalAccessException e) {
	    log.error(
		    "IllegalAccessException thrown in BaseJpaDAO.processDeletePathsCascade(Object parentVO, HashMap<String,ArrayList<String>> map, boolean ifM2NDeleteOnlyRelationship, boolean deleteOneToOne) : "
			    + e.toString());
	    throw new DataAccessException(
		    "Error in BaseJpaDAO.processDeletePathsCascade(Object parentVO, HashMap<String,ArrayList<String>> map, boolean ifM2NDeleteOnlyRelationship, boolean deleteOneToOne): "
			    + e.toString(),
		    e);
	} catch (final InvocationTargetException e) {
	    log.error(
		    "InvocationTargetException thrown in BaseJpaDAO.processDeletePathsCascade(Object parentVO, HashMap<String,ArrayList<String>> map, boolean ifM2NDeleteOnlyRelationship, boolean deleteOneToOne) : "
			    + e.toString());
	    throw new DataAccessException(
		    "Error in BaseJpaDAO.processDeletePathsCascade(Object parentVO, HashMap<String,ArrayList<String>> map, boolean ifM2NDeleteOnlyRelationship, boolean deleteOneToOne): "
			    + e.toString(),
		    e);
	} catch (final NoSuchMethodException e) {
	    log.error(
		    "NoSuchMethodException thrown in BaseJpaDAO.processDeletePathsCascade(Object parentVO, HashMap<String,ArrayList<String>> map, boolean ifM2NDeleteOnlyRelationship, boolean deleteOneToOne) : "
			    + e.toString());
	    throw new DataAccessException(
		    "Error in BaseJpaDAO.processDeletePathsCascade(Object parentVO, HashMap<String,ArrayList<String>> map, boolean ifM2NDeleteOnlyRelationship, boolean deleteOneToOne): "
			    + e.toString(),
		    e);
	} catch (final Exception e) {
	    log.error("Exception thrown in BaseJpaDAO.processDeletePathsCascade(Object parentVO, HashMap<String,ArrayList<String>> map, boolean ifM2NDeleteOnlyRelationship, boolean deleteOneToOne) : "
		    + e.toString());
	    throw new DataAccessException(
		    "Error in BaseJpaDAO.processDeletePathsCascade(Object parentVO, HashMap<String,ArrayList<String>> map, boolean ifM2NDeleteOnlyRelationship, boolean deleteOneToOne): "
			    + e.toString(),
		    e);
	}
    }

    private boolean toBeRemoved(Object deleteVO) throws DataAccessException {
	boolean toBeRemoved = false;
	try {
	    if (isPersisted(deleteVO)) {
		if (!getEntityManager().contains(deleteVO)) {
		    getEntityManager().merge(deleteVO);
		}
		toBeRemoved = true;
	    }
	} catch (final Exception e) {
	    log.error("Exception thrown in BaseJpaDAO.toBeRemoved(Object deleteVO): " + e.toString());
	    throw new DataAccessException("Error in BaseJpaDAO.toBeRemoved(Object deleteVO) : " + e.toString(), e);
	}
	return toBeRemoved;
    }

    private int getRelationType(Class realClass, String pAttributeName) throws DataAccessException {
	log.info("************Entering **************");
	int relationType;

	try {
	    final ManyToMany manyToMany = (ManyToMany) getAnnotation(realClass, pAttributeName, ManyToMany.class);
	    OneToMany oneToMany = null;
	    OneToOne oneToOne = null;
	    ManyToOne manyToOne = null;
	    EmbeddedId embeddedId = null;

	    if (manyToMany == null) {
		oneToMany = (OneToMany) getAnnotation(realClass, pAttributeName, OneToMany.class);
		if (oneToMany == null) {
		    manyToOne = (ManyToOne) getAnnotation(realClass, pAttributeName, ManyToOne.class);
		    if (manyToOne == null) {
			oneToOne = (OneToOne) getAnnotation(realClass, pAttributeName, OneToOne.class);
			if (oneToOne == null) {
			    embeddedId = (EmbeddedId) getAnnotation(realClass, pAttributeName, EmbeddedId.class);
			    if (embeddedId == null) {
				throw new DataAccessException(
					"Error in BaseJpaDAO.getRelationType(Class realClass, String pAttributeName): Error: pAttributeName  is no ManyToOne, no OneToMnay, no OneToOne, no ManyToMany, no EmbeddedId ");
			    } else {
				relationType = EMBEDDED_ID;
			    }
			} else {
			    relationType = ONE_TO_ONE;
			}
		    } else {
			relationType = M_TO_ONE;
		    }
		} else {
		    relationType = ONE_TO_N;
		}
	    } else {
		if (StringUtils.isEmpty(manyToMany.mappedBy())) {
		    relationType = M_TO_N;
		} else {
		    relationType = M_TO_N_INVERSE;
		}
	    }
	} catch (final DataAccessException e) {
	    log.error("Exception thrown in BaseJpaDAO.getRelationType(Class realClass, String pAttributeName): " + e.toString());
	    throw new DataAccessException("Error in BaseJpaDAO.getRelationType(Class realClass, String pAttributeName): " + e.toString(), e);
	}
	log.info("************Done  ***************");
	return relationType;
    }

    private ArrayList getPartialPathEntities(ArrayList startEntities, String[] splitPath, int startIndex, int endIndex) throws DataAccessException {
	log.info("************Entering **************");
	ArrayList partialPathEntities = new ArrayList();
	try {
	    if (splitPath == null) {
		throw new DataAccessException("Error in BaseJpaDAO.getPartialPathIdentities(ArrayList startEntities, String[] splitPath, int startIndex, int endIndex):Error:splitPath can't be null ");
	    }
	    if (startEntities == null) {
		throw new DataAccessException(
			"Error in BaseJpaDAO.getPartialPathIdentities(ArrayList startEntities, String[] splitPath, int startIndex, int endIndex):Error:startEntities can't be null ");
	    }
	    if (startIndex > endIndex) {
		throw new DataAccessException(
			"Error in BaseJpaDAO.getPartialPathIdentities(ArrayList startEntities, String[] splitPath, int startIndex, int endIndex): Error:startIndex can't be higher than endIndex ");
	    }
	    if (endIndex >= splitPath.length) {
		throw new DataAccessException(
			"Error in BaseJpaDAO.getPartialPathIdentities(ArrayList startEntities, String[] splitPath, int startIndex, int endIndex): Error:endIndex must be less than splitPath size");
	    }
	    if (startIndex < 0) {
		throw new DataAccessException(
			"Error in BaseJpaDAO.getPartialPathIdentities(ArrayList startEntities, String[] splitPath, int startIndex, int endIndex): Error:startIndex can't be less than 0");
	    }
	    if (startEntities.isEmpty() || splitPath.length == 0) {
		partialPathEntities = startEntities;
	    } else {

		/**
		 * start checking all entities of startEntities have the same
		 * objectsRealClass
		 **/
		final Iterator iterator = startEntities.iterator();
		final Object firstStartEntity = iterator.next(); // at least one
								 // identity is
								 // in
								 // startIdentities
								 // as it is not
								 // empty.
		if (firstStartEntity == null) {
		    throw new DataAccessException(
			    "Error in BaseJpaDAO.getPartialPathIdentities(ArrayList startEntities, String[] splitPath, int startIndex, int endIndex): Error:startEntities(0) is null");
		}
		// Class realClass = firstStartEntity.getClass();
		final Class realClass = getEntityClass(firstStartEntity);
		while (iterator.hasNext()) {
		    final Object entity = iterator.next();
		    if (entity == null) {
			throw new DataAccessException(
				"Error in BaseJpaDAO.getPartialPathIdentities(ArrayList startEntities, String[] splitPath, int startIndex, int endIndex): Error:found one entity in startEntities that is  null");
		    }
		    // Class entityRealClass = entity.getClass();
		    final Class entityRealClass = getEntityClass(entity);
		    if (!entityRealClass.equals(realClass)) {
			throw new DataAccessException(
				"Error in BaseJpaDAO.getPartialPathIdentities(ArrayList startEntities, String[] splitPath, int startIndex, int endIndex): Error:found two entities in startIdentities with different realClass");
		    }
		}
		/**
		 * end checking all identities of startIdentities have the same
		 * objectsRealClass
		 **/

		/******
		 * start calculate path from startIndex to endindex
		 *********/
		String path = splitPath[startIndex];
		int index = startIndex + 1;
		while (index <= endIndex) {
		    path = path + "." + splitPath[index];
		    index++;
		}
		/******
		 * end calculate path from startIndex to endindex
		 *********/

		final String[] selectAndJoinString = makeSelectAndJoinString(realClass, "a", path);
		final String queryString = "SELECT " + selectAndJoinString[0] + " FROM " + realClass.getSimpleName() + " a " + selectAndJoinString[1] + " WHERE a IN (:startEntities) ";

		final Query query = getEntityManager().createQuery(queryString);
		query.setParameter("startEntities", startEntities);
		final List result = query.getResultList();
		partialPathEntities.addAll(result);

	    }
	} catch (final Exception e) {
	    log.error("Exception thrown in BaseJpaDAO.getPartialPathEntities(ArrayList startEntities, String[] splitPath, int startIndex, int endIndex) : " + e.toString());
	    throw new DataAccessException("Error in BaseJpaDAO.getPartialPathEntities(ArrayList startEntities, String[] splitPath, int startIndex, int endIndex) : " + e.toString(), e);
	}
	log.info("************Done ***************");
	return partialPathEntities;
    }

    private String[] makeSelectAndJoinString(Class startingEntityClass, String join0, String path) throws DataAccessException {
	final String[] selectAndJoinString = new String[2];
	log.info("************Entering **************");
	try {
	    if (startingEntityClass == null) {
		throw new DataAccessException("Error in BaseJpaDAO.makeSelectAndJoinString(Class startingEntityClass, String join0, String path): startingEntityClass  is null");
	    }
	    final StringBuffer joinSB = new StringBuffer("");
	    Integer joinIndex = 0;
	    String lastJoin = join0;
	    // if(join0!=null && !join0.trim().equals("") &&
	    // !path.trim().equals("")){
	    if (join0 == null || join0.trim().equals("") || path.trim().equals("")) {
		throw new DataAccessException("Error in BaseJpaDAO.makeSelectAndJoinString(Class startingEntityClass, String join0, String path) : join0 or path null or empty");
	    }
	    StringBuffer currentPartialPath = new StringBuffer("");
	    final String[] pathArray = path.split("\\.");
	    for (int index = 0; index < pathArray.length; index++) {
		currentPartialPath.append("." + pathArray[index]);
		if (isReferenceCollection(startingEntityClass, pathArray[index])) {
		    joinIndex++;
		    final String currentJoin = "join" + joinIndex;
		    joinSB.append("join " + lastJoin + currentPartialPath + " " + currentJoin + " ");
		    lastJoin = currentJoin;
		    currentPartialPath = new StringBuffer("");
		} else if (!isReferenceBean(startingEntityClass, pathArray[index])) {
		    throw new DataAccessException("Error in BaseJpaDAO. makeSelectAndJoinString(Class startingEntityClass, String join0, String path) : " + startingEntityClass.getSimpleName() + "."
			    + pathArray[index] + " is not a Bean and not a Collection");
		}
		startingEntityClass = getClassFromPath(startingEntityClass, pathArray[index]);// added
											      // alessandro
											      // 11/09/2011
	    }
	    selectAndJoinString[0] = lastJoin + currentPartialPath;
	    selectAndJoinString[1] = joinSB.toString();

	    log.info("selectAndJoinString[0] is " + selectAndJoinString[0]);
	    log.info("selectAndJoinString[1] is " + selectAndJoinString[1]);
	} catch (final Exception e) {
	    log.error("Exception thrown in BaseJpaDAO. makeSelectAndJoinString(Class startingEntityClass, String join0, String path) : " + e.toString());
	    throw new DataAccessException("Error in BaseJpaDAO. makeSelectAndJoinString(Class startingEntityClass, String join0, String path): " + e.toString(), e);
	}

	log.info("************Done ***************");
	return selectAndJoinString;

    }

    private boolean isReferenceCollection(Class pInstanceClass, String pAttributeName) throws DataAccessException {

	return getAnnotation(pInstanceClass, pAttributeName, OneToMany.class) != null || getAnnotation(pInstanceClass, pAttributeName, ManyToMany.class) != null;

    }

    private boolean isReferenceBean(Class pInstanceClass, String pAttributeName) throws DataAccessException {

	return getAnnotation(pInstanceClass, pAttributeName, OneToOne.class) != null || getAnnotation(pInstanceClass, pAttributeName, ManyToOne.class) != null;

    }

    private boolean isManyToMany(Class pInstanceClass, String pAttributeName) throws DataAccessException {

	return getAnnotation(pInstanceClass, pAttributeName, ManyToMany.class) != null;

    }

    private boolean isOneToMany(Class pInstanceClass, String pAttributeName) throws DataAccessException {

	return getAnnotation(pInstanceClass, pAttributeName, OneToMany.class) != null;

    }

    public Object refresh(Object refreshVO) throws DataAccessException {
	log.debug("************Entering ***************");
	try {

	    if (refreshVO != null) {
		getEntityManager().refresh(refreshVO);
	    }

	} catch (final EntityNotFoundException e) {
	    log.warn("Entity Not Found  ");
	    refreshVO = null;
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.refresh(Object refreshVO) : " + e.toString(), e);
	}
	log.debug("************Done **************");
	return refreshVO;
    }

    public Object update(Object storeVO) throws DataAccessException, DataOptimisticLockException {
	log.debug("************Entering ***************");
	try {
	    if (storeVO != null) {
		storeVO = getEntityManager().merge(storeVO);
	    }
	    if (flush) {
		flush();
	    }
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.update(Object storeVO) : " + e.toString(), e);
	}
	log.debug("************Done **************");
	return storeVO;
    }

    public void updateCollection(Collection storeVOs) throws DataAccessException, DataOptimisticLockException {
	log.debug("Entering ");
	try {
	    updateCollectionCore(storeVOs);
	    if (flush) {
		flush();
	    }
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in BaseJpaDAO.updateCollection(Collection storeVOs): " + e.toString(), e);
	}
	log.info("************Done with the BaseJpaDAO.updateCollection(Collection storeVOs)***************");
    }

    private void updateCollectionCore(Collection storeVOs) throws DataAccessException {
	log.info("Entering ");
	try {
	    if (storeVOs == null) {
		throw new DataAccessException("Error in BaseJpaDAO.updateCollectionCore(Collection storeVOs): storeVOs can't be null. ");
	    }
	    final Iterator iterator = storeVOs.iterator();
	    while (iterator.hasNext()) {

		final Object storeVO = iterator.next();

		// if (getEntityManager().contains(storeVO)) {
		if (isPersisted(storeVO)) {
		    getEntityManager().merge(storeVO);
		} else {
		    getEntityManager().persist(storeVO);
		}
	    }
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in BaseJpaDAO.updateCollectionCore(Collection storeVOs): " + e.toString(), e);
	}
	log.info("************Done with the BaseJpaDAO.updateCollectionCore(Collection storeVOs)***************");
    }

    public Object insert(Object storeVO) throws DataAccessException, DataOptimisticLockException {
	log.debug("************Entering ***************");
	try {
	    if (storeVO != null) {
		getEntityManager().persist(storeVO);// getEntityManager().getFlushMode()
	    }
	    if (flush) {
		flush();
	    }
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.insert(Object storeVO) : " + e.toString(), e);
	}
	log.debug("************Done **************");
	return storeVO;
    }

    private Object storeCore(Object storeVO) throws DataAccessException {
	log.debug("************Entering ***************");
	try {
	    if (storeVO != null) {
		if (isPersisted(storeVO)) {
		    storeVO = getEntityManager().merge(storeVO);
		} else {
		    getEntityManager().persist(storeVO);
		}
	    }
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.storeCore(Object storeVO): " + e.toString(), e);
	}
	log.debug("************Done **************");
	return storeVO;
    }

    private Object persistIfNotPersisted(Object storeVO) throws DataAccessException {
	log.debug("************Entering ***************");
	try {
	    if (storeVO != null && !isPersisted(storeVO)) {

		getEntityManager().persist(storeVO);

	    }
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.persistIfNotPersisted(Object storeVO): " + e.toString(), e);
	}
	log.debug("************Done **************");
	return storeVO;
    }

    private Object store(Object storeVO) throws DataAccessException {
	log.debug("************Entering ***************");
	try {
	    storeVO = storeCore(storeVO);
	    if (flush) {
		flush();
	    }
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.store(Object storeVO): " + e.toString(), e);
	}
	log.debug("************Done **************");
	return storeVO;
    }

    public Object updateCollectionReference(Object storeVO, String pAttributeName) throws DataAccessException, DataOptimisticLockException {
	log.info("************Entering ***************");

	try {
	    if (storeVO == null) {
		throw new DataAccessException("Error in BaseJpaDAO.updateCollectionReference(Object storeVO, String pAttributeName): storeVO can't be null. ");
	    }
	    // if(!isReferenceCollection(storeVO.getClass(), pAttributeName))
	    // throw new DataAccessException("Error in
	    // BaseJpaDAO.updateCollectionReference(Object storeVO, String
	    // pAttributeName) : pAttributeName doesn't represent a collection
	    // ");
	    if (!isReferenceCollection(getEntityClass(storeVO), pAttributeName)) {
		throw new DataAccessException("Error in BaseJpaDAO.updateCollectionReference(Object storeVO, String pAttributeName) : pAttributeName doesn't represent a collection ");
	    }
	    // getAnnotation(pInstanceClass,pAttributeName,
	    // OneToMany.class)!=null ||
	    // getAnnotation(pInstanceClass,pAttributeName,
	    // ManyToMany.class)!=null;
	    // if(getAnnotation(storeVO.getClass(),pAttributeName,
	    // OneToMany.class)!=null){
	    if (getAnnotation(getEntityClass(storeVO), pAttributeName, OneToMany.class) != null) {
		// storeVO = storeCore(storeVO);
		updateCollectionReferenceWithoutMain(storeVO, pAttributeName, Boolean.TRUE, Boolean.TRUE, Boolean.TRUE);
		// storeVO = storeCore(storeVO);
		persistIfNotPersisted(storeVO);
		setInverseForeignKeyFields(storeVO, pAttributeName);
	    } else {
		updateCollectionReferenceWithoutMain(storeVO, pAttributeName, Boolean.TRUE, Boolean.TRUE, Boolean.TRUE);
		// storeVO = storeCore(storeVO);
		persistIfNotPersisted(storeVO);
	    }
	    if (flush) {
		flush();
	    }
	} catch (final OptimisticLockException e) {
	    log.error("OptimisticLockException caught in BaseJpaDAO.updateCollectionReference(Object storeVO, String pAttributeName): " + e.toString());
	    throw new DataOptimisticLockException("Error in BaseJpaDAO.updateCollectionReference(Object storeVO, String pAttributeName): " + e.toString(), e);
	} catch (final Exception e) {
	    log.error("Exception  in BaseJpaDAO.updateCollectionReference(Object storeVO, String pAttributeName): " + e.toString());
	    throw new DataAccessException("Error in BaseJpaDAO.updateCollectionReference(Object storeVO, String pAttributeName): " + e.toString(), e);
	}
	log.info("************Done **************");
	return storeVO;
    }

    private Object updateCollectionReferenceWithoutMain(Object storeVO, String pAttributeName, Boolean deleteNotInBeanReferencedObjects, Boolean storeCollection, Boolean ifM2NDeleteOnlyRelationship)
	    throws DataAccessException {
	log.info("************Entering   **************");

	try {
	    if (storeVO == null) {
		throw new DataAccessException(
			"Error in BaseJpaDAO.updateCollectionReferenceWithoutMain(Object storeVO, String pAttributeName, Boolean deleteNotInBeanReferencedObjects, Boolean storeCollection, Boolean ifM2NDeleteOnlyRelationship): storeVO can't be null. ");
	    }
	    if (pAttributeName == null || pAttributeName.trim().equals("")) {
		throw new DataAccessException(
			"Error in BaseJpaDAO.updateCollectionReferenceWithoutMain(Object storeVO, String pAttributeName, Boolean deleteNotInBeanReferencedObjects, Boolean storeCollection, Boolean ifM2NDeleteOnlyRelationship) : pAttributeName can't be null or empty or blank characters string. ");
	    }
	    // if(!isReferenceCollection(storeVO.getClass(), pAttributeName))
	    // throw new DataAccessException("Error in
	    // BaseJpaDAO.updateCollectionReferenceWithoutMain(Object storeVO,
	    // String pAttributeName, Boolean deleteNotInBeanReferencedObjects,
	    // Boolean storeCollection, Boolean ifM2NDeleteOnlyRelationship) :
	    // pAttributeName doesn't represent a collection ");
	    if (!isReferenceCollection(getEntityClass(storeVO), pAttributeName)) {
		throw new DataAccessException(
			"Error in BaseJpaDAO.updateCollectionReferenceWithoutMain(Object storeVO, String pAttributeName, Boolean deleteNotInBeanReferencedObjects, Boolean storeCollection, Boolean ifM2NDeleteOnlyRelationship) : pAttributeName doesn't represent a collection ");
	    }

	    final PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();

	    if (deleteNotInBeanReferencedObjects.booleanValue()) {
		deleteItemsNotInCollectionsInPathCore(storeVO, pAttributeName, false, ifM2NDeleteOnlyRelationship, false);
	    }

	    final Collection pAttributeNameCollection = (Collection) propertyUtilsBean.getProperty(storeVO, pAttributeName);

	    if (pAttributeNameCollection != null) {

		if (storeCollection.booleanValue()) {

		    updateCollectionCore(pAttributeNameCollection);
		}

	    }

	} catch (final Exception e) {
	    log.error(
		    "Exception thrown in BaseJpaDAO.updateCollectionReferenceWithoutMain(Object storeVO, String pAttributeName, Boolean deleteNotInBeanReferencedObjects, Boolean storeCollection, Boolean ifM2NDeleteOnlyRelationship): "
			    + e.toString());
	    throw new DataAccessException(
		    "Error in BaseJpaDAO.updateCollectionReferenceWithoutMain(Object storeVO, String pAttributeName, Boolean deleteNotInBeanReferencedObjects, Boolean storeCollection, Boolean ifM2NDeleteOnlyRelationship): "
			    + e.toString(),
		    e);
	}
	log.info("************Done  ***************");
	return storeVO;
    }

    @SuppressWarnings("unused")
    private void deleteReferencedCollection(Object parentVO, String pAttributeName, Collection toBeDeletedCollection, Boolean ifM2NDeleteOnlyRelationship) throws DataAccessException {
	log.info("************Entering **************");

	try {
	    if (parentVO == null) {
		throw new DataAccessException(
			"Error in BaseJpaDAO.deleteReferencedCollection(Object parentVO, String pAttributeName, Collection toBeDeletedIdentities, Boolean ifM2NDeleteOnlyRelationship) : parentVO can't be null. ");
	    }
	    if (pAttributeName == null || pAttributeName.trim().equals("")) {
		throw new DataAccessException(
			"Error in BaseJpaDAO.deleteReferencedCollection(Object parentVO, String pAttributeName, Collection toBeDeletedIdentities,Boolean ifM2NDeleteOnlyRelationship)  : pAttributeName can't be null or empty or blank characters string. ");
	    }
	    // if(!isReferenceCollection(parentVO.getClass(), pAttributeName))
	    // throw new DataAccessException("Error in
	    // BaseJpaDAO.deleteReferencedCollection(Object parentVO, String
	    // pAttributeName, Collection toBeDeletedIdentities, Boolean
	    // ifM2NDeleteOnlyRelationship) : pAttributeName doesn't represent a
	    // collection ");
	    if (!isReferenceCollection(getEntityClass(parentVO), pAttributeName)) {
		throw new DataAccessException(
			"Error in BaseJpaDAO.deleteReferencedCollection(Object parentVO, String pAttributeName, Collection toBeDeletedIdentities, Boolean ifM2NDeleteOnlyRelationship)  : pAttributeName doesn't represent a collection ");
	    }

	    if (toBeDeletedCollection != null) {

		// if(collectionDescriptor.isMtoNRelation()){
		// if(getAnnotation(parentVO.getClass(),pAttributeName,
		// ManyToMany.class)!=null){
		if (getAnnotation(getEntityClass(parentVO), pAttributeName, ManyToMany.class) != null) {
		    // deleteMToNRelationshipIdentitiesCollection(parentVO,pAttributeName,toBeDeletedIdentities,broker);
		    deleteMToNRelationshipCollectionCore(parentVO, pAttributeName, toBeDeletedCollection);
		    if (!ifM2NDeleteOnlyRelationship.booleanValue()) {
			deleteCollectionCore(toBeDeletedCollection);
		    }
		} else {
		    deleteCollectionCore(toBeDeletedCollection);
		}

	    }

	} catch (final Exception e) {
	    log.error("Exception thrown in BaseJpaDAO.deleteReferencedCollection(Object parentVO, String pAttributeName, Collection toBeDeletedIdentities, Boolean ifM2NDeleteOnlyRelationship)  : "
		    + e.toString());
	    throw new DataAccessException(
		    "Error in BaseJpaDAO.deleteReferencedCollection(Object parentVO, String pAttributeName, Collection toBeDeletedIdentities, Boolean ifM2NDeleteOnlyRelationship)  : " + e.toString(),
		    e);
	}
	log.info("************Done **************");
    }

    public Object updateCollectionReferences(Object storeVO) throws DataAccessException, DataOptimisticLockException {
	log.info("************Entering **************");
	if (storeVO == null) {
	    throw new DataAccessException("Error in BaseJpaDAO.updateCollectionReferences(Object storeVO) : storeVO can't be null. ");
	}

	try {
	    final PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();

	    // Class storeVOClass=storeVO.getClass();
	    final Class storeVOClass = getEntityClass(storeVO);

	    // storeVO = getEntityManager().merge(storeVO);

	    final Map describe = propertyUtilsBean.describe(storeVO);
	    Iterator iterator = describe.keySet().iterator();
	    while (iterator.hasNext()) {
		final String pAttributeName = (String) iterator.next();
		if (getAnnotation(storeVOClass, pAttributeName, ManyToMany.class) != null) {
		    updateCollectionReferenceWithoutMain(storeVO, pAttributeName, Boolean.TRUE, Boolean.TRUE, Boolean.TRUE);
		}
	    }

	    // storeVO=storeCore(storeVO);
	    persistIfNotPersisted(storeVO);

	    iterator = describe.keySet().iterator();
	    while (iterator.hasNext()) {
		final String pAttributeName = (String) iterator.next();
		if (getAnnotation(storeVOClass, pAttributeName, OneToMany.class) != null) {
		    updateCollectionReferenceWithoutMain(storeVO, pAttributeName, Boolean.TRUE, Boolean.TRUE, Boolean.TRUE);
		}
	    }
	    if (flush) {
		flush();
	    }

	} catch (final OptimisticLockException e) {
	    log.error("OptimisticLockException  in BaseJpaDAO.updateCollectionReferences(Object storeVO): " + e.toString());
	    throw new DataOptimisticLockException("Error in BaseJpaDAO.updateCollectionReferences(Object storeVO): " + e.toString(), e);
	} catch (final Exception e) {
	    log.error("Exception thrown in BaseJpaDAO.updateCollectionReferences(Object storeVO): " + e.toString());
	    throw new DataAccessException("Error in BaseJpaDAO.updateCollectionReferences(Object storeVO): " + e.toString(), e);
	}
	log.info("************Done************");
	return storeVO;
    }

    public void storePathCascade(Object storeVO, String path) throws DataAccessException, DataOptimisticLockException {
	log.info("************Entering ***************");

	try {
	    if (storeVO != null) {
		if (path == null || path.trim().equals("")) {
		    store(storeVO);
		} else {
		    final Collection paths = new ArrayList();
		    paths.add(path);
		    storePathsCascadeCore(storeVO, paths, false, true);
		    // ArrayList storeVOs =new ArrayList();
		    // storeVOs.add(storeVO);
		    // storeCollectionPathCascadeCore(storeVOs, path);
		}

	    }

	    if (flush) {
		flush();
	    }

	} catch (final OptimisticLockException e) {
	    log.error("OptimisticLockException  in BaseJpaDAO.storePathCascade(Object storeVO, String path) : " + e.toString());
	    throw new DataOptimisticLockException("Error in BaseJpaDAO.storePathCascade(Object storeVO, String path) : " + e.toString(), e);
	} catch (final Exception e) {
	    log.error("Exception thrown in BaseJpaDAO.storePathCascade(Object storeVO, String path) : " + e.toString());
	    throw new DataAccessException("Error in BaseJpaDAO.storePathCascade(Object storeVO, String path) : " + e.toString(), e);
	}
	log.info("************Done **************");

    }

    private void storeCollectionPathCascadeCore(Collection storeVOs, String path) throws DataAccessException {
	log.info("************Entering  ***************");

	try {
	    if (log.isDebugEnabled()) {
		if (storeVOs == null) {
		    log.debug("storeVOs==null");
		} else {
		    log.debug("storeVOs.size() == " + storeVOs.size());
		}
	    }

	    if (storeVOs != null && !storeVOs.isEmpty()) {
		if (path == null || path.trim().equals("")) {
		    updateCollectionCore(storeVOs);
		} else {

		    final String[] firstAttributeNameAndRemainingPath = Utils.getFirstAttributeNameAndRemainingPath(path);
		    final String firstAttributeName = firstAttributeNameAndRemainingPath[0];
		    final String remainingPath = firstAttributeNameAndRemainingPath[1];

		    // Class realClass = storeVOs.iterator().next().getClass();
		    final Class realClass = getEntityClass(storeVOs.iterator().next());
		    final Collection childrenVOs = BeanCollectionUtils.getTreeLeaves(storeVOs, firstAttributeName);
		    // if(isReferenceBean(realClass,firstAttributeName) ||
		    // isManyToMany(realClass,firstAttributeName)){
		    if (isReferenceBean(realClass, firstAttributeName)) {
			storeCollectionPathCascadeCore(childrenVOs, remainingPath);
			updateCollectionCore(storeVOs);
		    } else if (isManyToMany(realClass, firstAttributeName)) {
			setInverseForeignKeyFields(storeVOs, firstAttributeName);
			storeCollectionPathCascadeCore(childrenVOs, remainingPath);
			updateCollectionCore(storeVOs);
		    } else if (isOneToMany(realClass, firstAttributeName)) {
			setInverseForeignKeyFields(storeVOs, firstAttributeName);
			// updateCollectionCore(storeVOs); moved bottom for
			// entitynotfoundexception
			// https://hibernate.onjira.com/browse/HHH-3217
			storeCollectionPathCascadeCore(childrenVOs, remainingPath);
			updateCollectionCore(storeVOs);
		    } else {
			throw new DataAccessException("Error in BaseJpaDAO.storeCollectionPathCascadeCore(Collection storeVOs, String path): The relation between  " + realClass.getSimpleName()
				+ " and " + firstAttributeName + " is no one of oneToOne, oneToMany, manyToMany, manyToOne");
		    }
		}

	    }
	} catch (final Exception e) {
	    log.error("Exception thrown in BaseJpaDAO.storeCollectionPathCascadeCore(Collection storeVOs, String path): " + e.toString());
	    throw new DataAccessException("Error in BaseOjbPbCore.BaseJpaDAO.storeCollectionPathCascadeCore(Collection storeVOs, String path): " + e.toString(), e);
	}
	log.info("************Done **************");

    }

    /**
     * This method checks if all elements in a collection are of instances of
     * the same class
     *
     * @param valueObjects
     * @return true if the collection is null or empty, or if none of its
     *         elements is null and are all instances of the same class; it
     *         returns false, if at least one of its elements is null or not
     *         instances of the same class
     * @throws DataAccessException
     */
    @SuppressWarnings("unused")
    private boolean allElementsInCollectionSameClass(Collection valueObjects) throws DataAccessException {
	log.info("************Entering  ***************");
	boolean allElementsInCollectionSameClass = true;
	try {
	    if (valueObjects != null && !valueObjects.isEmpty()) {
		final Iterator iterator = valueObjects.iterator();
		final Object firstElement = iterator.next(); // at least one
							     // identity is in
							     // valueObjects as
							     // it is not empty.
		if (firstElement == null) {
		    allElementsInCollectionSameClass = false;
		} else {
		    // Class realClass = firstElement.getClass();
		    final Class realClass = getEntityClass(firstElement);
		    while (iterator.hasNext() && allElementsInCollectionSameClass) {
			final Object element = iterator.next();
			// if(element== null ||
			// !element.getClass().equals(realClass)){
			if (element == null || !getEntityClass(element).equals(realClass)) {
			    allElementsInCollectionSameClass = false;
			}
		    }
		}
	    }
	} catch (final Exception e) {
	    log.error("Exception thrown in BaseJpaDAO.allElementsInCollectionSameClass(Collection valueObjects): " + e.toString());
	    throw new DataAccessException("Error in BaseJpaDAO.allElementsInCollectionSameClass(Collection valueObjects): " + e.toString(), e);
	}
	log.info("************ Done  ***************");
	return allElementsInCollectionSameClass;
    }

    public void storePathsCascade(Object storeVO, Collection paths, Boolean pathsHasToBeSorted, Boolean storeVOHasToBeStored) throws DataAccessException, DataOptimisticLockException {
	log.info("************Entering ***************");

	storePathsCascadeCore(storeVO, paths, pathsHasToBeSorted, storeVOHasToBeStored);
	if (flush) {
	    flush();
	}

	log.info("************Done **************");
    }

    /**
     *
     *
     * @param storeVO
     * @param paths
     * @param pathsHasToBeSorted
     * @param storeVOHasToBeStored
     * @param isStoreVORightHandM2N
     * @return
     * @throws DataAccessException
     */
    private List<Graph> storePathsCascadeCore(Object storeVO, Collection<String> paths, Boolean pathsHasToBeSorted, Boolean storeVOHasToBeStored) throws DataAccessException {
	log.info("************Entering   ***************");
	final List<Graph> notStoredGraphs = new ArrayList<Graph>();
	try {
	    if (storeVO != null) {
		if (pathsHasToBeSorted == null) {
		    pathsHasToBeSorted = Boolean.TRUE;
		}
		if (storeVOHasToBeStored == null) {
		    storeVOHasToBeStored = Boolean.TRUE;
		}
		if (paths != null && !paths.isEmpty()) {
		    final Class storeVOClass = getEntityClass(storeVO);
		    final PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();

		    final HashMap<String, ArrayList<String>> directReferenceMap = new HashMap<String, ArrayList<String>>();
		    final HashMap<String, ArrayList<String>> oneToNReferenceMap = new HashMap<String, ArrayList<String>>();
		    final HashMap<String, ArrayList<String>> mToNReferenceMap = new HashMap<String, ArrayList<String>>();

		    final HashMap<String, ArrayList<String>> mToNInverseReferenceMap = new HashMap<String, ArrayList<String>>();

		    Collection<String> sortedPaths = null;
		    if (pathsHasToBeSorted.booleanValue()) {
			final ArrayList<String> tempPaths = Collections.list(Collections.enumeration(paths));
			Collections.sort(tempPaths);
			sortedPaths = tempPaths;
		    } else {
			sortedPaths = paths;
		    } // no side effects on paths

		    String firstAttributeName = "";
		    ArrayList<String> subPaths = null;
		    Iterator iterator = sortedPaths.iterator(); // sure
								// sortedPaths!=null
		    while (iterator.hasNext()) {
			// log.debug("storePathsCascade : entering in the
			// iterator ");
			final String path = (String) iterator.next();
			if (path != null && !path.trim().equals("")) {
			    final String[] firstAttributeNameAndRemainingPath = Utils.getFirstAttributeNameAndRemainingPath(path);
			    final String firstAttributeName2 = firstAttributeNameAndRemainingPath[0];
			    if (!firstAttributeName.equals(firstAttributeName2)) {
				firstAttributeName = firstAttributeName2;
				// log.debug("storePathsCascade : in iterator
				// firstAttributeName= "+firstAttributeName);

				// int relationType =
				// getRelationType(storeVO.getClass(),
				// firstAttributeName);
				final int relationType = getRelationType(storeVOClass, firstAttributeName);
				HashMap<String, ArrayList<String>> map = null;
				switch (relationType) {
				case ONE_TO_ONE:
				    map = directReferenceMap;
				    break;
				case M_TO_ONE:
				    map = directReferenceMap;
				    break;
				case EMBEDDED_ID:
				    map = directReferenceMap;
				    break;
				case ONE_TO_N:
				    map = oneToNReferenceMap;
				    break;
				case M_TO_N:
				    map = mToNReferenceMap;
				    break;
				case M_TO_N_INVERSE:
				    map = mToNInverseReferenceMap;
				    break;
				}
				// log.debug("storePathsCascade : in iterator
				// before map.put(firstAttributeName, new
				// ArrayList()); ");
				if (map == null) {
				    throw new DataAccessException(
					    "Error in BaseJpaDAO.storePathsCascadeCore(Object storeVO, Collection<String> paths, Boolean pathsHasToBeSorted, Boolean  storeVOHasToBeStored): no relation annotation found ");
				}
				map.put(firstAttributeName, new ArrayList<String>()); // each
										      // key
										      // firstAttributeName
										      // inserted
										      // has
										      // always
										      // an
										      // arraylist
										      // at
										      // least
										      // empty
										      // ,
										      // never
										      // nul
				subPaths = map.get(firstAttributeName);
			    }
			    final String remainingPath = firstAttributeNameAndRemainingPath[1];
			    if (remainingPath != null && !remainingPath.trim().equals("")) {
				if (subPaths == null) {
				    throw new DataAccessException(
					    "Error in BaseJpaDAO.storePathsCascadeCore(Object storeVO, Collection<String> paths, Boolean pathsHasToBeSorted, Boolean  storeVOHasToBeStored): subpaths is null");
				}
				subPaths.add(remainingPath);
			    }
			}
		    }

		    /*
		     * ONE TO ONE and M TO ONE
		     */
		    iterator = directReferenceMap.keySet().iterator();
		    String directReferenceMapFirstAttributeName;
		    while (iterator.hasNext()) {
			directReferenceMapFirstAttributeName = (String) iterator.next();
			final boolean nuevoStoreVOHasToBeStored = getNuevoStoreVOHasToBeStored(storeVO, directReferenceMapFirstAttributeName);
			log.debug("storePathsCascade : directReferenceMapFirstAttributeName = " + directReferenceMapFirstAttributeName);
			// storePathsCascadeCore(propertyUtilsBean.getProperty(storeVO,
			// directReferenceMapFirstAttributeName),
			// directReferenceMap.get(directReferenceMapFirstAttributeName),
			// Boolean.FALSE, Boolean.TRUE,false);
			notStoredGraphs.addAll(storePathsCascadeCore(propertyUtilsBean.getProperty(storeVO, directReferenceMapFirstAttributeName),
				directReferenceMap.get(directReferenceMapFirstAttributeName), Boolean.FALSE, nuevoStoreVOHasToBeStored));
		    }

		    /*
		     * M TO N
		     */
		    notStoredGraphs.addAll(processStorePathsCascadeToMany(storeVO, mToNReferenceMap, false));
		    // iterator = mToNReferenceMap.keySet().iterator();
		    // String mToNReferenceFirstAttributeName;
		    // while(iterator.hasNext()){
		    // mToNReferenceFirstAttributeName = (String)
		    // iterator.next();
		    // Collection mToNReferenceFirstAttributeValue =
		    // (Collection)propertyUtilsBean.getProperty(storeVO,
		    // mToNReferenceFirstAttributeName);
		    // setInverseForeignKeyFields(storeVO,
		    // mToNReferenceFirstAttributeName);
		    // boolean isCascadeAll = isCascade(storeVO,
		    // mToNReferenceFirstAttributeName, CascadeType.ALL );
		    // boolean isCascadePersist = isCascade(storeVO,
		    // mToNReferenceFirstAttributeName, CascadeType.PERSIST );
		    // boolean isCascadeMerge = isCascade(storeVO,
		    // mToNReferenceFirstAttributeName, CascadeType.MERGE );
		    // if(mToNReferenceFirstAttributeValue!=null){
		    // ArrayList<String> mToNReferenceSubPaths =
		    // mToNReferenceMap.get(mToNReferenceFirstAttributeName);
		    // for(Object childVO:mToNReferenceFirstAttributeValue){
		    // boolean nuevoStoreVOHasToBeStored =
		    // getNuevoStoreVOHasToBeStored(storeVO,
		    // childVO,isCascadeAll,isCascadePersist, isCascadeMerge);
		    // notStoredGraphs.addAll(storePathsCascadeCore(childVO,
		    // mToNReferenceSubPaths, Boolean.FALSE,
		    // nuevoStoreVOHasToBeStored));
		    // }
		    // }
		    // }

		    /******************************************************************************/
		    /*
		     * ONE TO N
		     */
		    notStoredGraphs.addAll(processStorePathsCascadeToMany(storeVO, oneToNReferenceMap, true));
		    // iterator = oneToNReferenceMap.keySet().iterator();
		    // String oneToNReferenceFirstAttributeName;
		    // while(iterator.hasNext()){
		    // oneToNReferenceFirstAttributeName = (String)
		    // iterator.next();
		    // Collection oneToNReferenceFirstAttributeValue =
		    // (Collection)propertyUtilsBean.getProperty(storeVO,
		    // oneToNReferenceFirstAttributeName);
		    // setInverseForeignKeyFields(storeVO,
		    // oneToNReferenceFirstAttributeName);
		    // boolean isCascadeAll = isCascade(storeVO,
		    // oneToNReferenceFirstAttributeName, CascadeType.ALL );
		    // boolean isCascadePersist = isCascade(storeVO,
		    // oneToNReferenceFirstAttributeName, CascadeType.PERSIST );
		    // boolean isCascadeMerge = isCascade(storeVO,
		    // oneToNReferenceFirstAttributeName, CascadeType.MERGE );
		    // if(oneToNReferenceFirstAttributeValue!=null){
		    // ArrayList<String> oneToNReferenceSubPaths =
		    // oneToNReferenceMap.get(oneToNReferenceFirstAttributeName);
		    //
		    // for(Object childVO:oneToNReferenceFirstAttributeValue){
		    // boolean nuevoStoreVOHasToBeStored =
		    // getNuevoStoreVOHasToBeStored(storeVO,
		    // childVO,isCascadeAll,isCascadePersist, isCascadeMerge);
		    // if(!nuevoStoreVOHasToBeStored){
		    // notStoredGraphs.addAll(storePathsCascadeCore( childVO,
		    // oneToNReferenceSubPaths, Boolean.FALSE, false));
		    // }else{
		    // notStoredGraphs.add(new
		    // Graph(childVO,oneToNReferenceSubPaths));
		    // }
		    // }
		    // }
		    // }

		    /*
		     * M_TO_N_INVERSE
		     */
		    notStoredGraphs.addAll(processStorePathsCascadeToMany(storeVO, mToNInverseReferenceMap, true));
		    // iterator = mToNInverseReferenceMap.keySet().iterator();
		    // String mToNInverseReferenceFirstAttributeName;
		    // while(iterator.hasNext()){
		    // mToNInverseReferenceFirstAttributeName = (String)
		    // iterator.next();
		    // Collection mToNInverseReferenceFirstAttributeValue =
		    // (Collection)propertyUtilsBean.getProperty(storeVO,
		    // mToNInverseReferenceFirstAttributeName);
		    // setInverseForeignKeyFields(storeVO,
		    // mToNInverseReferenceFirstAttributeName);
		    // boolean isCascadeAll = isCascade(storeVO,
		    // mToNInverseReferenceFirstAttributeName, CascadeType.ALL
		    // );
		    // boolean isCascadePersist = isCascade(storeVO,
		    // mToNInverseReferenceFirstAttributeName,
		    // CascadeType.PERSIST );
		    // boolean isCascadeMerge = isCascade(storeVO,
		    // mToNInverseReferenceFirstAttributeName, CascadeType.MERGE
		    // );
		    // if(mToNInverseReferenceFirstAttributeValue!=null){
		    // ArrayList<String> mToNInverseReferenceSubPaths =
		    // mToNReferenceMap.get(mToNInverseReferenceFirstAttributeName);
		    // for(Object
		    // childVO:mToNInverseReferenceFirstAttributeValue){
		    // boolean nuevoStoreVOHasToBeStored =
		    // getNuevoStoreVOHasToBeStored(storeVO,
		    // childVO,isCascadeAll,isCascadePersist, isCascadeMerge);
		    // if(!nuevoStoreVOHasToBeStored){
		    // notStoredGraphs.addAll(storePathsCascadeCore(childVO,
		    // mToNInverseReferenceSubPaths, Boolean.FALSE, false));
		    // }else{
		    // notStoredGraphs.add(new
		    // Graph(childVO,mToNInverseReferenceSubPaths));
		    // }
		    // }
		    // }
		    // }

		    if (storeVOHasToBeStored) {
			final EntityInfo entityInfo = new EntityInfo(storeVOClass);
			if (!entityInfo.isEmbeddable()) {
			    persistIfNotPersisted(storeVO);
			    for (final Graph notStoredGraph : notStoredGraphs) {
				storePathsCascadeCore(notStoredGraph.getRoot(), notStoredGraph.getPaths(), false, true);
			    }
			    notStoredGraphs.clear();
			}
		    }

		} else { // paths==null || paths.isEmpty()
			 // if (storeVOHasToBeStored) storeCore(storeVO);
		    if (storeVOHasToBeStored) {
			persistIfNotPersisted(storeVO);
		    }
		}
	    }

	} catch (final Exception e) {
	    log.error("Exception caught in BaseJpaDAO.storePathsCascadeCore(Object storeVO, Collection<String> paths, Boolean pathsHasToBeSorted, Boolean  storeVOHasToBeStored): " + e.toString());
	    throw new DataAccessException(
		    "Error in BaseJpaDAO.storePathsCascadeCore(Object storeVO, Collection<String> paths, Boolean pathsHasToBeSorted, Boolean  storeVOHasToBeStored): " + e.toString(), e);
	}
	log.info("************Done ***************");
	return notStoredGraphs;
    }

    private List<Graph> processStorePathsCascadeToMany(Object storeVO, HashMap<String, ArrayList<String>> map, boolean postStore) throws DataAccessException {
	final List<Graph> notStoredGraphs = new ArrayList<Graph>();
	try {
	    final PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();
	    final Iterator iterator = map.keySet().iterator();
	    String firstAttributeName;
	    while (iterator.hasNext()) {
		firstAttributeName = (String) iterator.next();
		final Collection firstAttributeValue = (Collection) propertyUtilsBean.getProperty(storeVO, firstAttributeName);
		setInverseForeignKeyFields(storeVO, firstAttributeName);
		final boolean isCascadeAll = isCascade(storeVO, firstAttributeName, CascadeType.ALL);
		final boolean isCascadePersist = isCascade(storeVO, firstAttributeName, CascadeType.PERSIST);
		final boolean isCascadeMerge = isCascade(storeVO, firstAttributeName, CascadeType.MERGE);
		if (firstAttributeValue != null) {
		    final ArrayList<String> subPaths = map.get(firstAttributeName);
		    for (final Object childVO : firstAttributeValue) {
			final boolean nuevoStoreVOHasToBeStored = getNuevoStoreVOHasToBeStored(storeVO, childVO, isCascadeAll, isCascadePersist, isCascadeMerge);
			if (postStore) {
			    if (!nuevoStoreVOHasToBeStored) {
				notStoredGraphs.addAll(storePathsCascadeCore(childVO, subPaths, Boolean.FALSE, false));
			    } else {
				notStoredGraphs.add(new Graph(childVO, subPaths));
			    }
			} else {
			    notStoredGraphs.addAll(storePathsCascadeCore(childVO, subPaths, Boolean.FALSE, nuevoStoreVOHasToBeStored));
			}
		    }
		}
	    }
	} catch (final IllegalAccessException e) {
	    log.error("IllegalAccessException caught in BaseJpaDAO.processStorePathsCascadeToMany(Object storeVO, HashMap<String,ArrayList<String>> map, boolean postStore): " + e.toString());
	    throw new DataAccessException("Error in BaseJpaDAO.processStorePathsCascadeToMany(Object storeVO, HashMap<String,ArrayList<String>> map, boolean postStore): " + e.toString(), e);
	} catch (final InvocationTargetException e) {
	    log.error("InvocationTargetException caught in BaseJpaDAO.processStorePathsCascadeToMany(Object storeVO, HashMap<String,ArrayList<String>> map, boolean postStore): " + e.toString());
	    throw new DataAccessException("Error in BaseJpaDAO.processStorePathsCascadeToMany(Object storeVO, HashMap<String,ArrayList<String>> map, boolean postStore): " + e.toString(), e);
	} catch (final NoSuchMethodException e) {
	    log.error("NoSuchMethodException caught in BaseJpaDAO.processStorePathsCascadeToMany(Object storeVO, HashMap<String,ArrayList<String>> map, boolean postStore): " + e.toString());
	    throw new DataAccessException("Error in BaseJpaDAO.processStorePathsCascadeToMany(Object storeVO, HashMap<String,ArrayList<String>> map, boolean postStore): " + e.toString(), e);
	} catch (final Exception e) {
	    log.error("Exception caught in BaseJpaDAO.processStorePathsCascadeToMany(Object storeVO, HashMap<String,ArrayList<String>> map, boolean postStore): " + e.toString());
	    throw new DataAccessException("Error in BaseJpaDAO.processStorePathsCascadeToMany(Object storeVO, HashMap<String,ArrayList<String>> map, boolean postStore): " + e.toString(), e);
	}
	return notStoredGraphs;
    }

    /**
     * It works only id pAttributeName is a direct reference (ManyToOne,
     * OneToOne)
     *
     * @param pInstance
     * @param pAttributeName
     * @return
     * @throws DataAccessException
     */
    private boolean getNuevoStoreVOHasToBeStored(Object pInstance, String pAttributeName) throws DataAccessException {
	boolean nuevoStoreVOHasToBeStored = true;
	try {
	    final boolean isCascadeAll = isCascade(pInstance, pAttributeName, CascadeType.ALL);
	    if (isCascadeAll) {
		nuevoStoreVOHasToBeStored = false;
	    } else {
		final PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();
		final boolean isCascadePersist = isCascade(pInstance, pAttributeName, CascadeType.PERSIST);
		final boolean isCascadeMerge = isCascade(pInstance, pAttributeName, CascadeType.MERGE);
		final Object pReference = propertyUtilsBean.getProperty(pInstance, pAttributeName);
		nuevoStoreVOHasToBeStored = getNuevoStoreVOHasToBeStored(pInstance, pReference, isCascadeAll, isCascadePersist, isCascadeMerge);

	    }
	} catch (final Exception e) {
	    log.error("Exception caught in BaseJpaDAO.getNuevoStoreVOHasToBeStored(Object pInstance, String pAttributeName): " + e.toString());
	    throw new DataAccessException("Error in BaseJpaDAO.getNuevoStoreVOHasToBeStored(Object pInstance, String pAttributeName): " + e.toString(), e);

	}
	return nuevoStoreVOHasToBeStored;
    }

    private boolean getNuevoStoreVOHasToBeStored(Object pInstance, Object pReference, boolean isCascadeAll, boolean isCascadePersist, boolean isCascadeMerge) throws DataAccessException {
	boolean nuevoStoreVOHasToBeStored = true;
	try {
	    if (isCascadeAll) {
		nuevoStoreVOHasToBeStored = false;
	    } else {
		Boolean isPersistedInstance = null;
		Boolean isPersistedReference = null;
		if (isCascadePersist) {
		    isPersistedInstance = isPersisted(pInstance);
		    if (!isPersistedInstance) {
			isPersistedReference = isPersisted(pReference);
			if (!isPersistedReference) {
			    nuevoStoreVOHasToBeStored = false;
			}
		    }
		}
		if (nuevoStoreVOHasToBeStored && isCascadeMerge) {
		    if (isPersistedInstance == null) {
			isPersistedInstance = isPersisted(pInstance);
		    }
		    if (isPersistedInstance) {
			if (isPersistedReference == null) {
			    isPersistedReference = isPersisted(pReference);
			}
			if (isPersistedReference) {
			    nuevoStoreVOHasToBeStored = false;
			}
		    }
		}
	    }
	} catch (final Exception e) {
	    log.error("Exception caught in BaseJpaDAO.getNuevoStoreVOHasToBeStored(Object pInstance, Object pReference,boolean isCascadeAll,boolean isCascadePersist,boolean isCascadeMerge): "
		    + e.toString());
	    throw new DataAccessException(
		    "Error in BaseJpaDAO.getNuevoStoreVOHasToBeStored(Object pInstance, Object pReference,boolean isCascadeAll,boolean isCascadePersist,boolean isCascadeMerge): " + e.toString(), e);

	}
	return nuevoStoreVOHasToBeStored;
    }

    public Object updateCreateTrees(Object storeVO, Collection<String> trees, Boolean storeVOHasToBeUpdated, Boolean deleteChangedOneToOne, Boolean applyDeletePathCascade,
	    Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) throws DataAccessException, DataOptimisticLockException {
	log.info("************Entering  **************");
	storeVO = updateCreateTreesCore(storeVO, trees, storeVOHasToBeUpdated, deleteChangedOneToOne, applyDeletePathCascade, ifM2NDeleteOnlyRelationship, deleteOneToOne);
	if (flush) {
	    flush();
	}
	log.info("************Done ***************");
	return storeVO;
    }

    public Object updateCreateTrees(Object storeVO, Collection trees, Boolean storeVOHasToBeUpdated) throws DataAccessException, DataOptimisticLockException {
	log.info("************Entering  **************");
	storeVO = updateCreateTreesCore(storeVO, trees, storeVOHasToBeUpdated, Boolean.FALSE, Boolean.TRUE, Boolean.TRUE, Boolean.FALSE);
	if (flush) {
	    flush();
	}
	log.info("************Done ***************");
	return storeVO;
    }

    public Object updateCreateTrees(Object storeVO, Collection trees) throws DataAccessException, DataOptimisticLockException {
	log.info("************Entering  **************");
	storeVO = updateCreateTreesCore(storeVO, trees, Boolean.TRUE, Boolean.FALSE, Boolean.TRUE, Boolean.TRUE, Boolean.FALSE);
	if (flush) {
	    flush();
	}
	log.info("************Done ***************");
	return storeVO;
    }

    private Object updateCreateTreesCore(Object storeVO, Collection<String> trees, Boolean storeVOHasToBeUpdated, Boolean deleteChangedOneToOne, Boolean applyDeletePathCascade,
	    Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne) throws DataAccessException {
	log.info("************Entering  **************");

	try {
	    if (storeVO != null) {
		if (storeVOHasToBeUpdated == null) {
		    storeVOHasToBeUpdated = Boolean.TRUE;
		}
		if (deleteChangedOneToOne == null) {
		    deleteChangedOneToOne = Boolean.FALSE;
		}
		if (applyDeletePathCascade == null) {
		    applyDeletePathCascade = Boolean.TRUE;
		}
		if (ifM2NDeleteOnlyRelationship == null) {
		    ifM2NDeleteOnlyRelationship = Boolean.TRUE;
		}
		if (deleteOneToOne == null) {
		    deleteOneToOne = Boolean.FALSE;
		}
		if (trees == null || trees.isEmpty()) {
		    if (storeVOHasToBeUpdated.booleanValue()) {
			storeVO = storeCore(storeVO);
		    }
		} else {
		    Collection<EntityPaths> changedDirectReferencesInPaths = null;
		    if (deleteChangedOneToOne.booleanValue()) {
			changedDirectReferencesInPaths = getChangedDirectReferencesInPaths(storeVO, trees, Boolean.TRUE);
			if (log.isDebugEnabled()) {
			    log.debug("updateCreateTrees: changedDirectReferencesInPaths.size() = " + changedDirectReferencesInPaths.size());
			}
		    }
		    deleteItemsNotInCollectionsInPathsCore(storeVO, trees, Boolean.TRUE, applyDeletePathCascade, ifM2NDeleteOnlyRelationship, deleteOneToOne);
		    storePathsCascadeCore(storeVO, trees, Boolean.TRUE, storeVOHasToBeUpdated);
		    if (deleteChangedOneToOne.booleanValue() && changedDirectReferencesInPaths != null) {
			final Iterator<EntityPaths> iterator = changedDirectReferencesInPaths.iterator();
			if (applyDeletePathCascade.booleanValue()) {
			    while (iterator.hasNext()) {
				final EntityPaths entityPaths = iterator.next();
				// if(log.isDebugEnabled())
				if (log.isDebugEnabled()) {
				    log.debug("updateCreateTrees: identity =  " + entityPaths.getEntity().toString());
				    final Iterator entityPathsIterator = entityPaths.getPaths().iterator();
				    while (entityPathsIterator.hasNext()) {
					log.debug("updateCreateTrees: entityPathsIterator.next() =  " + entityPathsIterator.next().toString());

				    }
				}
				deletePathsCascadeCore(entityPaths.getEntity(), entityPaths.getPaths(), Boolean.FALSE, ifM2NDeleteOnlyRelationship, deleteOneToOne);
			    }
			} else {
			    while (iterator.hasNext()) {
				final EntityPaths entityPaths = iterator.next();
				getEntityManager().remove(getEntityManager().merge(entityPaths.getEntity()));
			    }
			}
		    }
		}
	    }

	} catch (final Exception e) {
	    log.error(
		    "Exception thrown in BaseJpaDAO.updateCreateTreesCore(Object storeVO,Collection<String> trees, Boolean storeVOHasToBeUpdated, Boolean deleteChangedOneToOne, Boolean applyDeletePathCascade, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne): "
			    + e.toString());
	    throw new DataAccessException(
		    "Error in BaseJpaDAO.updateCreateTreesCore(Object storeVO,Collection<String> trees, Boolean storeVOHasToBeUpdated, Boolean deleteChangedOneToOne, Boolean applyDeletePathCascade, Boolean ifM2NDeleteOnlyRelationship, Boolean deleteOneToOne): "
			    + e.toString(),
		    e);
	}
	log.info("************Done  ***************");
	return storeVO;
    }

    private Collection<EntityPaths> getChangedDirectReferencesInPaths(Object rootVO, Collection<String> paths, Boolean pathsHasToBeSorted) throws DataAccessException {
	log.info("************Entering  **************");
	final ArrayList<EntityPaths> changedDirectReferencesInPaths = new ArrayList<EntityPaths>();
	try {
	    final PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();
	    if (rootVO != null && paths != null && !paths.isEmpty()) {
		// Class rootVOClass = rootVO.getClass();
		String[] pathsArray = new String[paths.size()];
		if (pathsHasToBeSorted.booleanValue()) {
		    final ArrayList<String> pathsList = Collections.list(Collections.enumeration(paths));
		    Collections.sort(pathsList);
		    pathsArray = pathsList.toArray(pathsArray);
		} else {
		    pathsArray = paths.toArray(pathsArray);
		}
		final int pathsArrayLenght = pathsArray.length;
		int index = 0;
		while (index < pathsArrayLenght) {
		    final String path = pathsArray[index];
		    if (path != null && !path.trim().equals("")) {
			final String[] firstAttributeNameAndRemainingPath = Utils.getFirstAttributeNameAndRemainingPath(path);
			final String firstAttributeName = firstAttributeNameAndRemainingPath[0];
			final String remainingPath = firstAttributeNameAndRemainingPath[1];
			final ArrayList<String> subPaths = new ArrayList<String>();
			if (!remainingPath.trim().equals("")) {
			    subPaths.add(remainingPath);
			}
			index++;
			boolean matchingFirstAttributeName = true;
			while (index < pathsArrayLenght && matchingFirstAttributeName) {
			    if (pathsArray[index] != null && !pathsArray[index].trim().equals("")) {
				final String[] firstAttributeNameAndRemainingPath2 = Utils.getFirstAttributeNameAndRemainingPath(pathsArray[index]);
				final String firstAttributeName2 = firstAttributeNameAndRemainingPath2[0];
				if (firstAttributeName2.equals(firstAttributeName)) {
				    if (!firstAttributeNameAndRemainingPath2[1].trim().equals("")) {
					subPaths.add(firstAttributeNameAndRemainingPath2[1]);
				    }
				    index++;
				} else {
				    matchingFirstAttributeName = false;
				}
			    } else {
				index++;
			    }
			}

			if (subPaths.size() <= 1) {
			    final Collection<EntityPath> changedDirectReferencesInPathEntityPathCollection = getChangedDirectReferencesInPath(rootVO, path);
			    if (changedDirectReferencesInPathEntityPathCollection != null) {
				final Iterator<EntityPath> iterator = changedDirectReferencesInPathEntityPathCollection.iterator();
				while (iterator.hasNext()) {
				    changedDirectReferencesInPaths.add(new EntityPaths(iterator.next()));
				}
			    }
			} else {// subPaths.size() >1

			    final Object firstAttributeValue = propertyUtilsBean.getProperty(rootVO, firstAttributeName);
			    // if(isReferenceCollection(rootVO.getClass(),
			    // firstAttributeName)){
			    if (isReferenceCollection(getEntityClass(rootVO), firstAttributeName)) {
				if (firstAttributeValue != null) {
				    final Iterator iterator = ((Collection) firstAttributeValue).iterator();
				    while (iterator.hasNext()) {
					final Collection<EntityPaths> partialChangedDirectReferencesInPaths = getChangedDirectReferencesInPaths(iterator.next(), subPaths, Boolean.FALSE);
					if (partialChangedDirectReferencesInPaths != null) {
					    changedDirectReferencesInPaths.addAll(partialChangedDirectReferencesInPaths);
					}

				    }
				}
			    } else { // firstAttributeValue is not a collection
				final Object changedChild = getChangedChild(rootVO, firstAttributeName);
				if (changedChild != null) {
				    final EntityPaths entityPaths = new EntityPaths(changedChild, subPaths);
				    changedDirectReferencesInPaths.add(entityPaths);
				}
				final Collection<EntityPaths> partialChangedDirectReferencesInPaths = getChangedDirectReferencesInPaths(firstAttributeValue, subPaths, Boolean.FALSE);
				if (partialChangedDirectReferencesInPaths != null) {
				    changedDirectReferencesInPaths.addAll(partialChangedDirectReferencesInPaths);
				}
			    }
			}
		    } else {
			index++;
		    }
		}

	    }
	} catch (final Exception e) {
	    log.error("Exception caught in BaseJpaDAO.getChangedDirectReferencesInPaths (Object rootVO, Collection<String> paths, Boolean pathsHasToBeSorted): " + e.toString());
	    throw new DataAccessException("Error in BaseJpaDAO.getChangedDirectReferencesInPaths (Object rootVO, Collection<String> paths, Boolean pathsHasToBeSorted): " + e.toString(), e);
	}
	log.info("************Done  **************");
	return changedDirectReferencesInPaths;
    }

    private Collection<EntityPath> getChangedDirectReferencesInPath(Object rootVO, String path) throws DataAccessException {
	log.info("************Entering   ***************");
	final ArrayList<EntityPath> changedDirectReferencesInPath = new ArrayList<EntityPath>();
	try {
	    if (rootVO != null && path != null && !path.trim().equals("")) {
		final String[] firstAttributeNameAndRemainingPath = Utils.getFirstAttributeNameAndRemainingPath(path);
		final String firstAttributeName = firstAttributeNameAndRemainingPath[0];
		final String remainingPath = firstAttributeNameAndRemainingPath[1];

		final PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();

		final Object firstAttributeValue = propertyUtilsBean.getProperty(rootVO, firstAttributeName);

		// if (isReferenceCollection(rootVO.getClass(),
		// firstAttributeName)){
		if (isReferenceCollection(getEntityClass(rootVO), firstAttributeName)) {
		    if (firstAttributeValue != null) { // only condition added
						       // by ale 19-nov 2008
						       // todo syncornize design
			final Iterator iterator = ((Collection) firstAttributeValue).iterator();
			while (iterator.hasNext()) {
			    final Collection<EntityPath> partialChangedDirectReferencesInPath = getChangedDirectReferencesInPath(iterator.next(), remainingPath);
			    if (partialChangedDirectReferencesInPath != null) {
				changedDirectReferencesInPath.addAll(partialChangedDirectReferencesInPath);
			    }
			}
		    }
		} else { // direct relationship 1:1
		    final Object changedChild = getChangedChild(rootVO, firstAttributeName);
		    if (changedChild != null) {
			final EntityPath entityPath = new EntityPath(changedChild, remainingPath);
			changedDirectReferencesInPath.add(entityPath);
		    }
		    if (firstAttributeValue != null) {
			final Collection<EntityPath> partialChangedDirectReferencesInPath = getChangedDirectReferencesInPath(firstAttributeValue, remainingPath);
			if (partialChangedDirectReferencesInPath != null) {
			    changedDirectReferencesInPath.addAll(partialChangedDirectReferencesInPath);
			}
		    }

		}

	    }
	} catch (final Exception e) {
	    log.error("Exception caught in BaseJpaDAO.getChangedDirectReferencesInPath(Object rootVO, String path): " + e.toString());
	    throw new DataAccessException("Error in BaseJpaDAO.getChangedDirectReferencesInPath(Object rootVO, String path): " + e.toString(), e);
	}
	log.info("************Done  **************");
	return changedDirectReferencesInPath;

    }

    // private Identity getChangedChildIdentity(Object parentVO ,
    // ObjectReferenceDescriptor objectReferenceDescriptor, PersistenceBroker
    // broker) throws OjbPbCoreException{
    private Object getChangedChild(Object parentVO, String pAttributeName) throws DataAccessException {
	log.info("************Entering  ***************");
	Object changedChild = null;
	try {
	    if (pAttributeName == null || pAttributeName.trim().equals("")) {
		throw new DataAccessException("Error in BaseJpaDAO.getChangedChild(Object parentVO , String pAttributeName)  :: pAttributeName can't be null or empty string. ");
	    }
	    // if(isReferenceCollection(parentVO.getClass(),
	    // pAttributeName))throw new OjbPbCoreException("Error in
	    // BaseJpaDAO.getChangedChild(Object parentVO ,String
	    // pAttributeName) : pAttributeName can't represent a collection.
	    // ");
	    if (isReferenceCollection(getEntityClass(parentVO), pAttributeName)) {
		throw new DataAccessException("Error in BaseJpaDAO.getChangedChild(Object parentVO ,String pAttributeName) : pAttributeName can't represent a collection. ");
	    }
	    if (parentVO != null) {
		final PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();

		// String[] pkNames = getPkNames(parentVO.getClass());
		final String[] pkNames = getPkNames(getEntityClass(parentVO));
		final Object[] keyValues = getKeyValues(parentVO);
		// Object storedChild = findObjectByLogicCondition(new
		// String[]{pAttributeName}, parentVO.getClass(), new
		// LogicSqlCondition(pkNames,keyValues));
		final Object storedChild = findObjectByLogicCondition(new String[] { pAttributeName }, getEntityClass(parentVO), new LogicSqlCondition(pkNames, keyValues));

		if (storedChild != null) {
		    log.debug("storedChild: referencedIdentity = " + storedChild.toString());
		    final Object childVO = propertyUtilsBean.getProperty(parentVO, pAttributeName);
		    if (childVO != null) {
			final FieldComparator fieldComparator = new FieldComparator(pkNames);
			if (fieldComparator.compare(childVO, storedChild) != 0) {
			    changedChild = storedChild;
			}

		    } else {
			log.debug("childVO: is null = ");
			changedChild = storedChild;
		    }
		}

	    }
	} catch (final Exception e) {
	    log.error("Exception thrown in BaseJpaDAO.getChangedChild(Object parentVO , String pAttributeName) : " + e.toString());
	    throw new DataAccessException("Error in BaseJpaDAO.getChangedChild(Object parentVO , String pAttributeName): " + e.toString(), e);
	}

	log.info("************Done  **************");
	return changedChild;
    }

    /****************************************/

    public Class getClassFromPath(Class realClass, String path) throws DataAccessException {
	log.info("************Entering ***************");
	Class classFromPath = null;
	try {
	    if (path != null) {
		if (path.trim().equals("")) {
		    classFromPath = realClass;
		} else {
		    final String[] pathArray = path.split("\\.");
		    Class currentClass = realClass;
		    for (final String element : pathArray) {

			final Field field = currentClass.getDeclaredField(element);
			// if(Collection.class.isAssignableFrom(field.getClass())
			// || List.class.isAssignableFrom(field.getClass()) ||
			// Set.class.isAssignableFrom(field.getClass())){
			if (Collection.class.isAssignableFrom(field.getType()) || List.class.isAssignableFrom(field.getType()) || Set.class.isAssignableFrom(field.getType())) {

			    Class targetEntityClass = Utils.getGenericClass(field.getGenericType());
			    log.debug("targetEntityClass is " + targetEntityClass.toString());
			    if (targetEntityClass == null) {// Generics are not
							    // used, we look for
							    // mappedBy
							    // attribute of
							    // annotation
				OneToMany oneToMany = field.getAnnotation(OneToMany.class);
				if (oneToMany == null) { // we look for
							 // ManytoMany
				    ManyToMany manyToMany = field.getAnnotation(ManyToMany.class);
				    if (manyToMany == null) { // we look for
							      // OneToMany in
							      // the getter
					final Method getter = getGetter(currentClass, field.getName());
					oneToMany = getter.getAnnotation(OneToMany.class);
					if (oneToMany == null) {// we look for
								// ManyToMany in
								// the getter
					    manyToMany = getter.getAnnotation(ManyToMany.class);
					    if (manyToMany == null) {
						throw new DataAccessException(
							"Error in  BaseJpaDAO.getClassFromPath(Class realClass, String path): In the class " + currentClass.getName() + " the property " + element
								+ " is not a List, Collection or Set of Generics, and there is no annotation OneToMany or ManyToMany nor in the field and the getter");
					    } else {
						targetEntityClass = manyToMany.targetEntity();
					    }
					} else {
					    targetEntityClass = oneToMany.targetEntity();
					}
				    } else {
					targetEntityClass = manyToMany.targetEntity();
				    }
				} else {
				    targetEntityClass = oneToMany.targetEntity();
				}
				if (targetEntityClass == null) {
				    throw new DataAccessException("Error in  BaseJpaDAO.getClassFromPath(Class realClass, String path): In the class " + currentClass.getName() + " the property "
					    + element + " is not a List, Collection or Set of Generics, and targetEntity not exists in the annotation");
				}
			    }
			    currentClass = targetEntityClass;

			} else { // oneToOne or ManyToOne
				 // currentClass=field.getClass();
			    currentClass = field.getType();
			}
		    }
		    classFromPath = currentClass;
		}
	    }
	} catch (final SecurityException e) {
	    log.error("SecurityException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getClassFromPath(Class realClass, String path): " + e.toString(), e);
	} catch (final NoSuchFieldException e) {
	    log.error("NoSuchFieldException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getClassFromPath(Class realClass, String path): " + e.toString(), e);
	} catch (final NoSuchMethodException e) {
	    log.error("NoSuchMethodException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getClassFromPath(Class realClass, String path): " + e.toString(), e);
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getClassFromPath(Class realClass, String path): " + e.toString(), e);
	}

	log.info("************Done **************");
	return classFromPath;
    }

    public Class getCollectionClassFromPath(Class realClass, String path) throws DataAccessException {
	log.info("************Entering ***************");
	Class collectionClassFromPath = null;

	try {
	    final String[] exceptLastTokenAndLastToken = Utils.getExceptLastTokenAndLastToken(path);
	    final String exceptLastToken = exceptLastTokenAndLastToken[0];
	    final String lastToken = exceptLastTokenAndLastToken[1];

	    final Class penultimateClass = getClassFromPath(realClass, exceptLastToken);

	    // Field lastField = penultimateClass.getField(lastToken);
	    final Field lastField = penultimateClass.getDeclaredField(lastToken);
	    // collectionClassFromPath = lastField.getClass();
	    collectionClassFromPath = lastField.getType();

	    if (!Collection.class.isAssignableFrom(collectionClassFromPath) && !List.class.isAssignableFrom(collectionClassFromPath) && !Set.class.isAssignableFrom(collectionClassFromPath)) {
		collectionClassFromPath = null;
	    } else {
		if (collectionClassFromPath.isInterface()) {
		    if (Collection.class.isAssignableFrom(collectionClassFromPath) || List.class.isAssignableFrom(collectionClassFromPath)) {
			final ArrayList<?> a = new ArrayList();
			collectionClassFromPath = a.getClass();
		    } else if (Set.class.isAssignableFrom(collectionClassFromPath)) {
			final HashSet<?> a = new HashSet();
			collectionClassFromPath = a.getClass();
		    }
		}
	    }

	} catch (final SecurityException e) {
	    log.error("SecurityException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getCollectionClassFromPath(Class realClass, String path): " + e.toString(), e);
	} catch (final NoSuchFieldException e) {
	    log.error("NoSuchFieldException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getCollectionClassFromPath(Class realClass, String path): " + e.toString(), e);
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getCollectionClassFromPath(Class realClass, String path): " + e.toString(), e);
	}
	log.info("************Done ***************");
	return collectionClassFromPath;
    }

    public Vector getFksToItemClassInDecomposedRelationship(Class realClass, String oneToN, String mToOne) throws DataAccessException {
	log.info("************Entering ***************");
	final Vector flds = new Vector();
	try {
	    /** implemented o n 15/08/2012 */
	    final Class relatedObjectClass = getClassFromPath(realClass, oneToN + "." + mToOne);
	    final List<String> pkNames = new EntityInfo(relatedObjectClass).getListPkNames();
	    if (pkNames != null) {
		for (final String pkName : pkNames) {
		    flds.add(mToOne + "." + pkName);
		}
	    }
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getFksToItemClassInDecomposedRelationship(Class realClass, String oneToN, String mToOne): " + e.toString(), e);
	}

	log.info("************Done ***************");
	return flds;
    }

    public Object[] getKeyValues(Object pInstance) throws DataAccessException {
	log.info("************Entering ***************");
	Object[] keyValues = null;
	try {
	    final PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();
	    // EntityInfo info = new EntityInfo(pInstance.getClass());
	    final EntityInfo info = new EntityInfo(getEntityClass(pInstance));
	    final String[] pkNames = info.getPkNames();
	    keyValues = new Object[pkNames.length];
	    for (int i = 0; i < pkNames.length; i++) {
		keyValues[i] = propertyUtilsBean.getProperty(pInstance, pkNames[i]);
	    }
	} catch (final IllegalAccessException e) {
	    log.error("IllegalAccessException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getKeyValues(Object pInstance): " + e.toString(), e);
	} catch (final InvocationTargetException e) {
	    log.error("InvocationTargetException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getKeyValues(Object pInstance): " + e.toString(), e);
	} catch (final NoSuchMethodException e) {
	    log.error("NoSuchMethodException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getKeyValues(Object pInstance): " + e.toString(), e);
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getKeyValues(Object pInstance): " + e.toString(), e);
	}
	log.info("************Done **************");
	return keyValues;
    }

    private boolean isPersisted(Object pInstance) throws DataAccessException {
	boolean isPersisted = true;
	try {
	    final PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();
	    // EntityInfo info = new EntityInfo(pInstance.getClass());
	    final EntityInfo info = new EntityInfo(getEntityClass(pInstance));
	    final String idName = info.getIdField().getName();
	    final Object idValue = propertyUtilsBean.getProperty(pInstance, idName);
	    if (idValue == null) {
		isPersisted = false;
	    } else {

		final String[] pkNames = info.getPkNames();
		for (int i = 0; i < pkNames.length && isPersisted; i++) {
		    try {
			final Object key = propertyUtilsBean.getProperty(pInstance, pkNames[i]);
			if (key == null) {
			    isPersisted = false;
			    break;
			}
		    } catch (final NestedNullException e) {
			isPersisted = false;
			break;
		    }
		}
		if (isPersisted) {
		    final Object persistedObject = findObjectByLogicCondition(new String[] { idName }, getEntityClass(pInstance), new LogicSqlCondition(idName, "==", idValue));
		    isPersisted = persistedObject != null;
		}
	    }
	} catch (final IllegalAccessException e) {
	    log.error("IllegalAccessException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.isPersisted(Object pInstance): " + e.toString(), e);
	} catch (final InvocationTargetException e) {
	    log.error("InvocationTargetException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.isPersisted(Object pInstance): " + e.toString(), e);
	} catch (final NoSuchMethodException e) {
	    log.error("NoSuchMethodException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.isPersisted(Object pInstance): " + e.toString(), e);
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.isPersisted(Object pInstance): " + e.toString(), e);
	}
	return isPersisted;
    }

    public String[] getPkNames(Class realClass) throws DataAccessException {
	log.info("************Entering ***************");
	String[] pkNames = null;

	try {
	    final EntityInfo info = new EntityInfo(realClass);
	    pkNames = info.getPkNames();
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getPkNames(Class realClass): " + e.toString(), e);
	}

	log.info("************Done ***************");
	return pkNames;
    }

    public String[] getFksToThisClass(Class realClass, String oneToN) throws DataAccessException {
	log.info("************Entering***************");
	final String[] flds = new String[] { getMappedBy(realClass, oneToN) };
	log.info("************Done **************");
	return flds;
    }

    public Vector getForeignKeyFields(Class realClass, String pAttributeName) throws DataAccessException {
	log.info("************Entering ***************");

	final Vector flds = new Vector();

	try {
	    /* implemented 14/08/2008 */
	    final String[] exceptLastTokenAndLastToken = Utils.getExceptLastTokenAndLastToken(pAttributeName);
	    final String exceptLastToken = exceptLastTokenAndLastToken[0];
	    final String lastToken = exceptLastTokenAndLastToken[1];
	    final Class penutlClass = getClassFromPath(realClass, exceptLastToken);
	    final EntityInfo penutlClassEntityInfo = new EntityInfo(penutlClass);

	    final Class pAttributeClass = getClassFromPath(realClass, pAttributeName);
	    final EntityInfo pAttributeClassEntityInfo = new EntityInfo(pAttributeClass);
	    ArrayList<String> listPkNames = null;
	    if (penutlClassEntityInfo.isEmbeddable()) { //
		listPkNames = pAttributeClassEntityInfo.getListPkNames();
	    } else if (pAttributeClassEntityInfo.isEmbeddable()) {
		listPkNames = penutlClassEntityInfo.getListPkNames();
	    }

	    if (listPkNames != null) {
		for (final String pkName : listPkNames) {
		    flds.add(lastToken + "." + pkName);
		}
	    }
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getForeignKeyFields(Class realClass, String pAttributeName): " + e.toString(), e);
	}

	log.info("************Done **************");
	return flds;
    }

    /*
     * Only the one to many case is of interest Int his case in there is a
     * mapped by on the relation the real classe primary keys are returned
     * Actually this could not seem conceptually correct, but with this mapping,
     * the inverse foreing key is represented by the mappedBy, the referes to
     * the realClass. (non-Javadoc)
     *
     * @see
     * it.aco.mandragora.dao.DAO#getInverseForeignKeyFields(java.lang.Class,
     * java.lang.String)
     */
    public Vector getInverseForeignKeyFields(Class realClass, String pAttributeName) throws DataAccessException {
	log.info("************Entering ***************");

	final Vector flds = new Vector();
	/* implemented 14/08/2008 */

	try {
	    final String[] exceptLastTokenAndLastToken = Utils.getExceptLastTokenAndLastToken(pAttributeName);
	    final String exceptLastToken = exceptLastTokenAndLastToken[0];
	    final String lastToken = exceptLastTokenAndLastToken[1];
	    final Class penutlClass = getClassFromPath(realClass, exceptLastToken);
	    if (isOneToMany(penutlClass, lastToken)) {
		final String mappedBy = getMappedBy(penutlClass, lastToken);
		if (!StringUtils.isEmpty(mappedBy)) {
		    final EntityInfo penutlClassEntityInfo = new EntityInfo(penutlClass);
		    final List<String> penutlClassPkNames = penutlClassEntityInfo.getListPkNames();
		    if (penutlClassPkNames != null) {
			for (final String pkName : penutlClassPkNames) {
			    flds.add(mappedBy + "." + pkName);
			}
		    }

		}
	    }
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getInverseForeignKeyFields(Class realClass, String pAttributeName): " + e.toString(), e);
	}
	log.info("************Done **************");
	return flds;
    }

    public void setInverseForeignKeyFields(Collection valueObjects, String pAttributeName) throws DataAccessException {
	log.info("************Entering **************");
	if (valueObjects != null) {
	    final Iterator iterator = valueObjects.iterator();
	    while (iterator.hasNext()) {
		setInverseForeignKeyFields(iterator.next(), pAttributeName);
	    }
	}
	log.info("************Done **************");
    }

    public void setInverseForeignKeyFields(Object pInstance, String pAttributeName) throws DataAccessException {
	log.info("************Entering **************");

	try {

	    final Class pInstanceClass = getEntityClass(pInstance);
	    final PropertyUtilsBean propertyUtilsBean = BeanUtilsBean.getInstance().getPropertyUtils();

	    if (isOneToMany(pInstanceClass, pAttributeName)) {
		final String mappedBy = getMappedBy(pInstanceClass, pAttributeName);
		if (mappedBy != null && !mappedBy.trim().equals("")) {
		    final Collection pAttributeCollection = (Collection) propertyUtilsBean.getProperty(pInstance, pAttributeName);
		    if (pAttributeCollection != null) {
			for (final Object pAttributeCollectionElement : pAttributeCollection) {
			    propertyUtilsBean.setProperty(pAttributeCollectionElement, mappedBy, pInstance);
			}

		    }
		}
	    } else if (isManyToMany(pInstanceClass, pAttributeName)) {

		final Collection pAttributeCollection = (Collection) propertyUtilsBean.getProperty(pInstance, pAttributeName);
		if (pAttributeCollection != null) {
		    final String inverseManyToManyField = getInverseManyToManyField(pInstance, pAttributeName);
		    if (inverseManyToManyField != null && !inverseManyToManyField.equals("")) {
			for (final Object pAttributeCollectionElement : pAttributeCollection) {
			    final Collection inverseCollection = (Collection) propertyUtilsBean.getProperty(pAttributeCollectionElement, inverseManyToManyField);
			    if (!inverseCollection.contains(pInstance)) {
				inverseCollection.add(pInstance);
			    }
			}
		    }
		}
	    }
	} catch (final IllegalAccessException e) {
	    log.error("IllegalAccessException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.setInverseForeignKeyFields(Object pInstance, String pAttributeName): " + e.toString(), e);
	} catch (final InvocationTargetException e) {
	    log.error("InvocationTargetException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.setInverseForeignKeyFields(Object pInstance, String pAttributeName): " + e.toString(), e);
	} catch (final NoSuchMethodException e) {
	    log.error("NoSuchMethodException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.setInverseForeignKeyFields(Object pInstance, String pAttributeName): " + e.toString(), e);
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.setInverseForeignKeyFields(Object pInstance, String pAttributeName): " + e.toString(), e);
	}
	log.info("************Done *************");
    }

    private String getInverseManyToManyField(Object pInstance, String pAttributeName) throws DataAccessException {
	String inverseManyToManyField = null;
	try {
	    final Class pInstanceClass = getEntityClass(pInstance);
	    final ManyToMany manyToMany = (ManyToMany) getAnnotation(pInstanceClass, pAttributeName, ManyToMany.class);
	    if (manyToMany != null) {
		if (!StringUtils.isEmpty(manyToMany.mappedBy())) {
		    inverseManyToManyField = manyToMany.mappedBy();
		} else {
		    Class targetEntityClass = manyToMany.targetEntity();
		    if (targetEntityClass == null) {
			targetEntityClass = Utils.getGenericClass(pInstanceClass.getDeclaredField(pAttributeName).getGenericType());
		    }
		    final Field[] declaredFields = targetEntityClass.getDeclaredFields();
		    if (declaredFields != null) {
			for (int i = 0; i < declaredFields.length && inverseManyToManyField == null; i++) {

			    final ManyToMany inverseManyToMany = declaredFields[i].getAnnotation(ManyToMany.class);
			    if (inverseManyToMany != null && pAttributeName.equals(inverseManyToMany.mappedBy())) {
				inverseManyToManyField = declaredFields[i].getName();
			    }
			}
		    }
		}
	    }
	} catch (final SecurityException e) {
	    log.error("SecurityException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getInverseManyToManyField(Object pInstance, String pAttributeName): " + e.toString(), e);
	} catch (final NoSuchFieldException e) {
	    log.error("NoSuchFieldException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getInverseManyToManyField(Object pInstance, String pAttributeName): " + e.toString(), e);
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getInverseManyToManyField(Object pInstance, String pAttributeName): " + e.toString(), e);
	}
	return inverseManyToManyField;
    }

    private Collection<String> getAssociationOverridesColumnNames(AssociationOverrides associationOverrides) throws DataAccessException {
	final ArrayList<String> columnNames = new ArrayList<String>();
	try {
	    if (associationOverrides != null) {
		final AssociationOverride[] associationOverrideArray = associationOverrides.value();
		for (final AssociationOverride associationOverride : associationOverrideArray) {
		    final JoinColumn[] joinColumns = associationOverride.joinColumns();

		    for (final JoinColumn joinColumn : joinColumns) {
			columnNames.add(joinColumn.name());
		    }
		}
	    }
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getAssociationOverridesColumnNames(AssociationOverrides associationOverrides): " + e.toString(), e);
	}
	return columnNames;
    }

    private Collection<String> getAttributeOverridesColumnNames(AttributeOverrides attributeOverrides) throws DataAccessException {
	final ArrayList<String> columnNames = new ArrayList<String>();
	try {
	    if (attributeOverrides != null) {
		final AttributeOverride[] attributeOverrideArray = attributeOverrides.value();
		for (final AttributeOverride attributeOverride : attributeOverrideArray) {
		    columnNames.add(attributeOverride.column().name());
		}
	    }
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getAttributeOverridesColumnNames(AttributeOverrides attributeOverrides): " + e.toString(), e);
	}
	return columnNames;
    }

    public String[] getPkColumnNames(Class realClass) throws DataAccessException {

	String[] pkColumnNames = null;

	try {
	    final ArrayList<String> pkColumnNamesList = new ArrayList<String>();
	    final EntityInfo entityInfo = new EntityInfo(realClass);
	    final Field pkField = entityInfo.getIdField();
	    if (entityInfo.isEmbeddedIdAnnotated()) {
		final Annotation[] pkFieldAnnotations = pkField.getAnnotations();
		for (final Annotation pkFieldAnnotation : pkFieldAnnotations) {
		    if (pkFieldAnnotation.annotationType().equals(AssociationOverrides.class)) {
			pkColumnNamesList.addAll(getAssociationOverridesColumnNames((AssociationOverrides) pkFieldAnnotation));
		    } else if (pkFieldAnnotation.annotationType().equals(AttributeOverrides.class)) {
			pkColumnNamesList.addAll(getAttributeOverridesColumnNames((AttributeOverrides) pkFieldAnnotation));
		    }
		}
		pkColumnNames = pkColumnNamesList.toArray(new String[0]);

	    } else {
		final String columnName = ((Column) getAnnotation(realClass, pkField.getName(), Column.class)).name();
		pkColumnNames = new String[] { columnName };
	    }
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getPkColumnNames(Class realClass): " + e.toString(), e);
	}

	return pkColumnNames;

    }

    private String[] getJoinTableInverseColumnName(JoinTable joinTable) throws DataAccessException {
	String[] columnName = null;
	try {
	    if (joinTable != null) {
		final JoinColumn[] joinColumns = joinTable.inverseJoinColumns();
		columnName = new String[joinColumns.length];
		for (int i = 0; i < joinColumns.length; i++) {
		    columnName[i] = joinColumns[i].name();
		}
	    }
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getJoinTableInverseColumnName(JoinTable joinTable): " + e.toString(), e);
	}
	return columnName;
    }

    private String[] getJoinTableColumnName(JoinTable joinTable) throws DataAccessException {
	String[] columnName = null;
	try {
	    if (joinTable != null) {
		final JoinColumn[] joinColumns = joinTable.joinColumns();
		columnName = new String[joinColumns.length];
		for (int i = 0; i < joinColumns.length; i++) {
		    columnName[i] = joinColumns[i].name();
		}
	    }
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getJoinTableColumnName(JoinTable joinTable): " + e.toString(), e);
	}
	return columnName;
    }

    private void setQueryParameters(Query query, Map parameters) throws DataAccessException {
	log.debug("************Entering ***************");
	try {

	    final Iterator iterator = parameters.keySet().iterator();
	    while (iterator.hasNext()) {
		final Object key = iterator.next();
		// log.debug("executing query.setParameter(
		// #0,#1",key,parameters.get(key));

		if (Integer.class.isInstance(key)) {
		    query.setParameter(((Integer) key).intValue(), parameters.get(key));
		} else {
		    query.setParameter((String) key, parameters.get(key));
		}
	    }
	} catch (final Exception e) {
	    log.error("Exception caught  : " + e.toString());
	    throw new DataAccessException("Error in  BaseOjbPbCore.setQueryParameters(Query query, Map parameters) : " + e.toString(), e);
	}
	log.info("************Done **************");
    }

    private String translateInAll(String queryString, Map parameters) throws DataAccessException {
	log.debug("************Entering ***************");
	String result = null;
	try {

	    result = translateIn(queryString, parameters);
	    result = translateIn(result);

	} catch (final DataAccessException e) {
	    log.error("DataAccessException caught  : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.translateInAll(String queryString, Map parameter): " + e.toString(), e);
	} catch (final Exception e) {
	    log.error("Exception caught  : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.translateInAll(String queryString, Map parameter): " + e.toString(), e);
	}

	log.debug("************Done ***************");
	return result;
    }

    private String translateIn(String queryString, Map parameters) throws DataAccessException {
	log.debug("************Entering ***************");
	try {
	    if (parameters != null) {
		final Map parametersToSplit = new HashMap();
		final Set keySet = parameters.keySet();
		Iterator iterator = keySet.iterator();

		while (iterator.hasNext()) {
		    final String key = (String) iterator.next();
		    final Object value = parameters.get(key);
		    if (Collection.class.isInstance(value) && ((Collection) value).size() > inLimit) {
			parametersToSplit.put(key, value);
		    }
		}
		if (!parametersToSplit.isEmpty()) {
		    iterator = parametersToSplit.keySet().iterator();
		    while (iterator.hasNext()) {
			final Object key = iterator.next();
			final Object value = parameters.get(key);

			// final String regex =
			// "(\\S+)\\s+(not\\s+)?in\\s*\\((\\s*\\S+(\\s*,\\s*\\S+)*)\\s*\\)";
			// String regex =
			// "(\\w\\.+)\\s+(not\\s+)?in\\s*\\(s*:s*" + key+
			// "\\s*\\)";
			final String regex = "(\\S+)\\s+(not\\s+)?in\\s*\\(\\s*:\\s*" + key + "\\s*\\)";
			final Pattern pattern = Pattern.compile(regex, Pattern.CASE_INSENSITIVE);
			final Matcher matcher = pattern.matcher(queryString);
			if (matcher.find()) {
			    String replacement = "(";
			    final String entityIdentifier = matcher.group(1);
			    final String not = matcher.group(2);
			    if (not != null) {
				// replacement = replacement + " NOT
				// ("+entityIdentifier+orOfInsCollection(key,splitIn((Collection)value),parameters)+"
				// ) ";
				replacement = replacement + " NOT (" + orOfInsCollection(entityIdentifier, key, splitIn((Collection) value), parameters) + " ) ";
			    } else {
				// replacement = replacement +
				// entityIdentifier+orOfInsCollection(key,splitIn((Collection)value),parameters);
				replacement = replacement + " " + orOfInsCollection(entityIdentifier, key, splitIn((Collection) value), parameters);
			    }
			    replacement = replacement + " ) ";
			    queryString = matcher.replaceAll(replacement);
			}
		    }
		}
	    }

	} catch (final DataAccessException e) {
	    log.error("DataAccessException caught  : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.translateIn(String queryString, Map parameter): " + e.toString(), e);
	}

	log.debug("************Done ***************");
	return queryString;
    }

    /**
     * Este metodo quita del parameters el elemento con key parameter, y aade
     * uno para cada lista en splitIn. Devuelve la string IN
     * (:split_0_paramemeter) OR IN (:split_1_paramemeter)...OR IN
     * (:split_N_paramemeter)
     *
     * @param parameter
     * @param splitIn
     * @param parameters
     * @return
     * @throws DataAccessException
     */
    private String orOfInsCollection(String entityIdentifier, Object parameter, ArrayList<List> splitIn, Map parameters) throws DataAccessException {
	log.debug("************Entering ***************");
	String orOfIns = "";
	try {
	    if (splitIn != null) {
		parameters.remove(parameter);
		final Iterator<List> iterator = splitIn.iterator();
		int count = 0;
		if (iterator.hasNext()) {
		    final List in = iterator.next();
		    final String splitParameter = "split_" + count + "_" + parameter.toString();
		    // orOfIns = " IN (:"+splitParameter+" ) ";
		    orOfIns = " " + entityIdentifier + " IN (:" + splitParameter + " ) ";
		    parameters.put(splitParameter, in);
		}
		while (iterator.hasNext()) {
		    count++;
		    final List in = iterator.next();
		    final String splitParameter = "split_" + count + "_" + parameter.toString();
		    // orOfIns = orOfIns +" OR IN (:"+splitParameter+" ) ";
		    orOfIns = orOfIns + " OR " + entityIdentifier + " IN (:" + splitParameter + " ) ";
		    parameters.put(splitParameter, in);
		}
	    }
	} catch (final Exception e) {
	    log.error("Exception caught  : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.orOfInsCollection(String entityIdentifier,Object parameter, ArrayList<List> splitIn, Map parameters): " + e.toString(), e);
	}
	log.debug("************Done ***************");
	return orOfIns;

    }

    /**
     * este metodo devuelve una lista de listas, que son la particion de la
     * lista data en ingreso por inLimit
     *
     * @param in
     * @return
     * @throws DataAccessException
     */
    private ArrayList<List> splitIn(Collection in) throws DataAccessException {
	log.debug("************Entering ***************");
	final ArrayList<List> limitedIns = new ArrayList<List>();
	try {
	    if (in != null && !in.isEmpty()) {

		List toSplitList = null;
		if (List.class.isInstance(in)) {
		    toSplitList = (List) in;
		} else {
		    toSplitList = new ArrayList();
		    toSplitList.addAll(in);
		}

		final int size = toSplitList.size();

		// mod to know how much elements are inputted in last clause IN
		final int mod = size % this.inLimit;
		// calculate how much INs are injected
		final int numberOfIn = size / this.inLimit + (mod == 0 ? 0 : 1);

		for (int i = 0; i < numberOfIn - 1; i++) {
		    final List limitedIn = toSplitList.subList(i * this.inLimit, (i + 1) * this.inLimit);
		    limitedIns.add(limitedIn);
		}
		final List limitedIn = toSplitList.subList((numberOfIn - 1) * this.inLimit, size);
		limitedIns.add(limitedIn);
	    }
	} catch (final Exception e) {
	    log.error("Exception caught  : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.splitIn(Collection in): " + e.toString(), e);
	}
	log.debug("************Done ***************");
	return limitedIns;
    }

    @SuppressWarnings("unused")
    private String orOfInsfromList(ArrayList<List> splitIn) throws DataAccessException {
	log.debug("************Entering ***************");
	String orOfIns = "";
	try {
	    if (splitIn != null) {
		final Iterator<List> iterator = splitIn.iterator();
		if (iterator.hasNext()) {
		    final List in = iterator.next();
		    orOfIns = " IN " + Utils.buildInString(in);
		}
		while (iterator.hasNext()) {
		    final List in = iterator.next();
		    orOfIns = orOfIns + " OR IN " + Utils.buildInString(in);
		}
	    }
	} catch (final Exception e) {
	    log.error("Exception caught  : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.orOfIns(ArrayList<Collection> splitIn): " + e.toString(), e);
	}
	log.debug("************Done ***************");
	return orOfIns;

    }

    private String translateIn(String queryString) throws DataAccessException {
	log.debug("************Entering ***************");
	String result = null;
	try {
	    // final String regex = "(\\w\\.+)\\s+(not\\s+)?in\\s*\\(s*:" +
	    // param+ "\\s*)";
	    // final String regex =
	    // "(\\w\\.+)\\s+(not\\s+)?in\\s*\\((s*.*(s*,s*.*)*)s*\\)";
	    // final String regex =
	    // "(\\S+)\\s+(not\\s+)?in\\s*\\((\\s*\\S+(\\s*,\\s*\\S+)*)\\s*\\)";
	    // final String regex =
	    // "(\\S+)\\s+(not\\s+)?in\\s*\\((\\s*\\S+(\\s*,\\s*\\S+){"+(this.inLimit-1)+",})\\s*\\)";
	    final String regex = "(\\S+)\\s+(not\\s+)?in\\s*\\((\\s*\\S+(\\s*,\\s*\\S+)+)\\s*\\)";

	    final Pattern pattern = Pattern.compile(regex, Pattern.CASE_INSENSITIVE);
	    final Matcher matcher = pattern.matcher(queryString);
	    final StringBuffer sb = new StringBuffer();

	    while (matcher.find()) {
		String replacement = "(";
		final String entityIdentifier = matcher.group(1);
		final String not = matcher.group(2);
		final String in = matcher.group(3);
		if (not != null) {
		    // replacement = replacement + " NOT
		    // ("+entityIdentifier+orOfIns(splitIn(in))+" ) ";
		    replacement = replacement + " NOT (" + orOfIns(entityIdentifier, splitIn(in)) + " ) ";
		} else {
		    // replacement = replacement +
		    // entityIdentifier+orOfIns(splitIn(in));
		    replacement = replacement + orOfIns(entityIdentifier, splitIn(in));
		}
		replacement = replacement + " ) ";
		matcher.appendReplacement(sb, replacement);
	    }
	    matcher.appendTail(sb);
	    // queryString = sb.toString();
	    result = sb.toString();

	} catch (final DataAccessException e) {
	    log.error("DataAccessException caught  : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.translateIn(String queryString): " + e.toString(), e);
	}

	log.debug("************Done ***************");
	return result;
    }

    private String orOfIns(String entityIdentifier, ArrayList<String> toLimitedIns) throws DataAccessException {
	log.debug("************Entering ***************");
	String orOfIns = "";
	try {
	    if (toLimitedIns != null) {
		final Iterator<String> iterator = toLimitedIns.iterator();
		if (iterator.hasNext()) {
		    // orOfIns = " IN ("+iterator.next()+" ) ";
		    orOfIns = " " + entityIdentifier + " IN (" + iterator.next() + " ) ";
		}
		while (iterator.hasNext()) {
		    // orOfIns = orOfIns +" OR IN ("+iterator.next()+" ) ";
		    orOfIns = orOfIns + " OR " + entityIdentifier + " IN (" + iterator.next() + " ) ";
		}
	    }
	} catch (final Exception e) {
	    log.error("Exception caught  : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.orOfIns(String entityIdentifier,ArrayList<String> toLimitedIns): " + e.toString(), e);
	}
	log.debug("************Done ***************");
	return orOfIns;

    }

    private ArrayList<String> splitIn(String in) throws DataAccessException {
	log.debug("************Entering ***************");
	final ArrayList<String> splitIn = new ArrayList<String>();
	try {
	    if (in != null && !in.trim().equals("")) {
		final String[] limitedInsArray = in.split(",");
		// mod to know how much elements are inputted in last clause IN
		final int mod = limitedInsArray.length % this.inLimit;
		// calculate how much INs are injected
		final int numberOfIn = limitedInsArray.length / this.inLimit + (mod == 0 ? 0 : 1);
		for (int i = 0; i < numberOfIn; i++) {
		    String limitedIn = limitedInsArray[i * this.inLimit];
		    for (int k = i * this.inLimit + 1; k < (i + 1) * this.inLimit && k < limitedInsArray.length; k++) {
			limitedIn = limitedIn + "," + limitedInsArray[k];
		    }
		    splitIn.add(limitedIn);
		}
	    }
	} catch (final Exception e) {
	    log.error("Exception caught  : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.splitIn(String in ): " + e.toString(), e);
	}
	log.debug("************Done ***************");
	return splitIn;
    }

    private Query createQuery(Class realClass, LogicCondition logicCondition) throws DataAccessException {
	log.debug("Entering");
	Query query = null;
	try {
	    // query = createQuery(null, realClass, logicCondition,null);
	    query = createQuery(null, null, realClass, logicCondition, null);
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.createQuery(Class realClass, LogicCondition logicCondition): " + e.toString(), e);
	}
	log.debug("Done");
	return query;
    }

    private Query createQuery(String[] selectFields, Class realClass, LogicCondition logicCondition) throws DataAccessException {
	log.debug("Entering");
	Query query = null;
	try {
	    // query = createQuery(selectFields, realClass, logicCondition,
	    // null);
	    query = createQuery(null, selectFields, realClass, logicCondition, null);
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.createQuery(String[] selectFields, Class realClass,  LogicCondition logicCondition): " + e.toString(), e);

	}
	log.debug("Done");
	return query;
    }

    private Query createQuery(Boolean distinct, String[] selectFields, Class realClass, LogicCondition logicCondition, String orderBy) throws DataAccessException {
	log.debug("Entering");
	Query query = null;
	try {
	    query = createQuery(distinct, selectFields, realClass, logicCondition, orderBy, null);
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.createQuery(Boolean distinct,String[] selectFields, Class realClass,  LogicCondition logicCondition, String orderBy): " + e.toString(),
		    e);
	}
	log.debug("Done");
	return query;
    }

    private Query createQuery(Boolean distinct, String[] selectFields, Class realClass, LogicCondition logicCondition, String orderBy, String[] groupBy) throws DataAccessException {
	log.debug("Entering");
	Query query = null;
	try {

	    final Map<String, Object> parametersMap = new HashMap<String, Object>();
	    final String queryString = createQueryString(distinct, selectFields, realClass, logicCondition, orderBy, groupBy, parametersMap);
	    // log.debug("queryString is #0", queryString);
	    query = getEntityManager().createQuery(queryString);

	    setQueryParameters(query, parametersMap);
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException(
		    "Error in  BaseJpaDAO.createQuery(Boolean distinct,String[] selectFields, Class realClass,  LogicCondition logicCondition, String orderBy, String[] groupBy): " + e.toString(), e);

	}
	log.debug("Done");
	return query;
    }

    private boolean isFunction(String fieldName) throws DataAccessException {
	boolean isFuntion = false;
	try {
	    if (fieldName != null) {
		isFuntion = fieldName.contains("(");
	    }
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.isFunction(String fieldName): " + e.toString(), e);
	}
	return isFuntion;
    }

    private HashMap<String, String> createJoinMap(Class realClass, String fieldName, Cursor joinIndex) throws DataAccessException {
	final HashMap<String, String> joinMap = new HashMap<String, String>();
	try {
	    if (fieldName != null && !isFunction(fieldName)) {
		fieldName = fieldName.split(" ")[0];
		String[] firstAttributeNameAndRemainingPath = Utils.getFirstAttributeNameAndRemainingPath(fieldName);
		String firstAttributeName = firstAttributeNameAndRemainingPath[0];
		String remainingPath = firstAttributeNameAndRemainingPath[1];
		// StringBuffer currentPath=new StringBuffer("a.");
		StringBuffer currentPath = new StringBuffer("");
		// int joinIndex=0;
		// String joinPrefix ="bbb";
		Class currentClass = realClass;
		while (!firstAttributeName.trim().equals("")) {

		    if (isReferenceCollection(currentClass, firstAttributeName)) {
			currentPath.append(firstAttributeName);
			String joinAlias = joinMap.get(currentPath.toString());
			if (joinAlias == null) {
			    joinAlias = joinPrefix + joinIndex.getValue();
			    joinMap.put(currentPath.toString(), joinAlias);
			    joinIndex.increment();
			}
			currentClass = Utils.getGenericClass(currentClass.getDeclaredField(firstAttributeName).getGenericType());

			// currentPath=new StringBuffer(firstAttributeName+".");
			currentPath = new StringBuffer(joinAlias + ".");

		    } else {
			currentPath.append(firstAttributeName + ".");
			currentClass = currentClass.getDeclaredField(firstAttributeName).getType();
		    }
		    firstAttributeNameAndRemainingPath = Utils.getFirstAttributeNameAndRemainingPath(remainingPath);
		    firstAttributeName = firstAttributeNameAndRemainingPath[0];
		    remainingPath = firstAttributeNameAndRemainingPath[1];
		}
	    }
	} catch (final SecurityException e) {
	    log.error("SecurityException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.createJoinMap(Class realClass,String fieldName, Cursor joinIndex): " + e.toString(), e);
	} catch (final NoSuchFieldException e) {
	    log.error("NoSuchFieldException caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.createJoinMap(Class realClass,String fieldName, Cursor joinIndex): " + e.toString(), e);
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.createJoinMap(Class realClass,String fieldName, Cursor joinIndex): " + e.toString(), e);
	}

	return joinMap;
    }

    private HashMap<String, String> createJoinMap(Class realClass, String[] selectFields, Cursor joinIndex) throws DataAccessException {
	final HashMap<String, String> joinMap = new HashMap<String, String>();

	try {
	    if (selectFields != null) {
		for (final String selectField : selectFields) {
		    joinMap.putAll(createJoinMap(realClass, selectField, joinIndex));
		}
	    }
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.createJoinMap(Class realClass,String[] selectFields): " + e.toString(), e);
	}

	return joinMap;
    }

    private HashMap<String, String> createJoinMap(Class realClass, LogicCondition logicCondition, Cursor joinIndex) throws DataAccessException {
	final HashMap<String, String> joinMap = new HashMap<String, String>();
	try {
	    while (logicCondition != null) {
		final SimpleCondition simpleCondition = logicCondition.getSimpleCondition();
		final String fieldName = (String) simpleCondition.getParameter().iterator().next();
		joinMap.putAll(createJoinMap(realClass, fieldName, joinIndex));
		logicCondition = logicCondition.getLogicCondition();
	    }
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.createJoinMap(Class realClass,LogicCondition logicCondition, Cursor joinIndex): " + e.toString(), e);
	}

	return joinMap;

    }

    private void replanceLogicConditionFieldsWithJoinMap(LogicCondition logicCondition, Map<String, String> joinMap) throws DataAccessException {
	try {
	    if (joinMap != null) {
		while (logicCondition != null) {
		    final SimpleCondition simpleCondition = logicCondition.getSimpleCondition();
		    final Collection replacedParameters = new ArrayList();
		    final Iterator iterator = simpleCondition.getParameter().iterator();
		    String fieldName = (String) iterator.next();
		    fieldName = replanceFieldWithJoinMap(fieldName, joinMap);
		    replacedParameters.add(fieldName);
		    while (iterator.hasNext()) {
			replacedParameters.add(iterator.next());
		    }
		    simpleCondition.setParameter(replacedParameters);
		    logicCondition = logicCondition.getLogicCondition();
		}
	    }
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.replanceLogicConditionFieldsWithJoinMap(LogicCondition logicCondition, Map<String,String> joinMap): " + e.toString(), e);
	}
    }

    private void replanceFieldsWithJoinMap(String[] fields, Map<String, String> joinMap) throws DataAccessException {
	if (fields != null) {
	    for (int i = 0; i < fields.length; i++) {
		fields[i] = replanceFieldWithJoinMap(fields[i], joinMap);
	    }
	}
    }

    private String replanceFieldWithJoinMap(String field, Map<String, String> joinMap) throws DataAccessException {
	String replacedField = field;

	try {
	    if (joinMap != null && replacedField != null) {
		boolean fullReplaced = false;
		while (!fullReplaced) {
		    final Iterator<String> iterator = joinMap.keySet().iterator();
		    boolean replaced = false;
		    while (iterator.hasNext() && !replaced) {
			final String join = iterator.next();
			if (replacedField.contains(join)) {
			    replacedField = replacedField.replace(join, joinMap.get(join));
			    replaced = true;
			}
		    }
		    if (!replaced) {
			fullReplaced = true;
		    }
		}
	    }
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.replanceFieldWithJoinMap(String field, Map<String,String> joinMap): " + e.toString(), e);
	}
	return replacedField;
    }

    // private String createSelectString(Boolean distinct, String[]
    // selectFields, boolean isCount, Map<String,String> joinMap){
    // String selectString="";
    // selectString = createSelectString(distinct, selectFields, isCount);
    //
    // if(joinMap!=null){
    // Iterator<String> iterator = joinMap.keySet().iterator();
    // while(iterator.hasNext()){
    // String join =iterator.next();
    // selectString=selectString.replace(join, joinMap.get(join));
    // }
    // }
    // return selectString;
    // }

    private String prefixNotJoinFieldName(String fieldName) throws DataAccessException {
	String prefixedFieldName = fieldName;
	try {
	    if (prefixedFieldName != null && !prefixedFieldName.startsWith(joinPrefix) && !isFunction(prefixedFieldName)) {
		prefixedFieldName = " a." + prefixedFieldName;
	    }
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.prefixNotJoinFieldName(String fieldName): " + e.toString(), e);
	}
	return prefixedFieldName;

    }

    private String createSelectString(Boolean distinct, String[] selectFields, boolean isCount) throws DataAccessException {
	log.debug("Entering");
	String selectString = "";
	try {
	    // String selectString ="";
	    if (selectFields != null && selectFields.length > 0) {
		for (int i = 0; i < selectFields.length; i++) {
		    // selectString=selectString+"a."+selectFields[i];
		    selectString = selectString + prefixNotJoinFieldName(selectFields[i]);
		    if (i < selectFields.length - 1) {
			selectString = selectString + ",";
		    }
		}
	    } else {
		selectString = "a";
	    }

	    if (distinct != null && distinct.booleanValue()) {
		if (!isCount) {
		    selectString = "SELECT DISTINCT " + selectString + " ";
		} else {
		    selectString = "SELECT COUNT (DISTINCT " + selectString + ") ";
		}
	    } else {
		if (!isCount) {
		    selectString = "SELECT " + selectString + " ";
		} else {
		    selectString = "SELECT COUNT (" + selectString + ") ";
		}
	    }

	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.createSelectString(Boolean distinct, String[] selectFields,boolean isCount): " + e.toString(), e);
	}
	log.debug("Done");
	return selectString;

    }

    private String createSelectString(Boolean distinct, String[] selectFields) throws DataAccessException {
	log.debug("Entering");
	String selectString = "";
	try {

	    selectString = createSelectString(distinct, selectFields, false);

	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.createSelectString(Boolean distinct, String[] selectFields): " + e.toString(), e);
	}
	log.debug("Done");
	return selectString;

    }

    private String createWhereString(Class realClass, LogicCondition logicCondition, Map<String, Object> parametersMap) throws DataAccessException {
	log.debug("Entering");
	String whereString = "";
	try {
	    if (logicCondition != null) {

		// String whereCondition = " WHERE "+
		// translateLogicCondition(realClass, logicCondition,
		// parametersMap);
		whereString = " WHERE " + translateLogicCondition(realClass, logicCondition, parametersMap);
		// log.debug("whereCondition is #0", whereCondition);
		// whereString = " WHERE "+whereCondition;
	    }
	    log.debug("whereString is " + whereString);

	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.createWhereString(Class realClass,  LogicCondition logicCondition,  Map<String,Object> parametersMap): " + e.toString(), e);

	}
	log.debug("Done");
	return whereString;

    }

    private String createGroupByString(String[] groupBy) throws DataAccessException {
	log.debug("Entering");
	String groupByString;
	try {
	    groupByString = "";

	    if (groupBy != null && groupBy.length > 0) {
		groupByString = " GROUP BY ";
		for (final String element : groupBy) {
		    groupByString += prefixNotJoinFieldName(element) + ", ";
		}
		groupByString = groupByString.substring(0, groupByString.lastIndexOf(","));
	    }
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.createGroupByString(String[] groupBy): " + e.toString(), e);
	}
	log.debug("Done");
	return groupByString;
    }

    private String[] buildOrderByArray(String orderBy) {
	String[] orderByArray = null;
	if (orderBy != null && !orderBy.trim().equals("")) {
	    orderByArray = orderBy.split(",");

	}
	return orderByArray;
    }

    private String createOrderByString(String[] orderByArray, Map<String, String> joinMap) throws DataAccessException {
	log.debug("Entering");
	String orderByString = "";

	try {
	    if (orderByArray != null) {
		String finalOrderBy = "";
		for (int k = 0; k < orderByArray.length; k++) {
		    final String[] splitOrderBy = orderByArray[k].split(" ");
		    // finalOrderBy=finalOrderBy+prefixNotJoinFieldName(replanceFieldWithJoinMap(splitOrderBy[0],joinMap))+"
		    // "+splitOrderBy[1];
		    /**
		     * TODO verificar bien este cambio
		     */
		    finalOrderBy = finalOrderBy + prefixNotJoinFieldName(replanceFieldWithJoinMap(splitOrderBy[0], joinMap)) + " " + (splitOrderBy.length > 1 ? splitOrderBy[1] : "");
		    if (k < orderByArray.length - 1) {
			finalOrderBy = finalOrderBy + ",";
		    }
		}
		orderByString = orderByString + " ORDER BY " + finalOrderBy;
	    }
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.createOrderByString(String[] orderByArray, Map<String,String> joinMap): " + e.toString(), e);
	}

	log.debug("Done");
	return orderByString;
    }

    private String createOrderByString(String orderBy) throws DataAccessException {
	log.debug("Entering");
	String orderByString = "";
	try {
	    //
	    if (orderBy != null && !orderBy.trim().equals("")) {
		final String[] orderBySplit = orderBy.split(",");
		String finalOrderBy = "";
		for (int k = 0; k < orderBySplit.length; k++) {
		    // finalOrderBy=finalOrderBy+" a."+orderBySplit[k];
		    finalOrderBy = finalOrderBy + prefixNotJoinFieldName(orderBySplit[k]);
		    if (k < orderBySplit.length - 1) {
			finalOrderBy = finalOrderBy + ",";
		    }
		}
		orderByString = orderByString + " ORDER BY " + finalOrderBy;

		// orderByString = createOrderByString(orderBySplit);
	    }

	    // log.debug("orderByString is #0", orderByString);
	    log.debug("orderByString is " + orderByString);

	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.createOrderByString(String orderBy): " + e.toString(), e);

	}
	log.debug("Done");
	return orderByString;

    }

    @SuppressWarnings("unused")
    private String createQueryString(Boolean distinct, String[] selectFields, Class realClass, LogicCondition logicCondition, String orderBy, Map<String, Object> parametersMap)
	    throws DataAccessException {
	log.debug("Entering");
	String queryString = null;
	try {

	    queryString = createQueryString(distinct, selectFields, realClass, logicCondition, orderBy, null, parametersMap);

	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException(
		    "Error in  BaseJpaDAO.createQueryString(Boolean distinct,String[] selectFields, Class realClass,  LogicCondition logicCondition, String orderBy, Map<String,Object> parametersMap): "
			    + e.toString(),
		    e);
	}
	log.debug("Done");
	return queryString;
    }

    private String createFromString(Class realClass, Map<String, String> joinMap) throws DataAccessException {
	String fromString = null;
	try {
	    fromString = " FROM " + realClass.getSimpleName() + " a ";
	    if (joinMap != null && !joinMap.isEmpty()) {
		final Iterator<String> iterator = joinMap.keySet().iterator();
		while (iterator.hasNext()) {
		    final String join = iterator.next();
		    final String joinAlias = joinMap.get(join);
		    // fromString+=" JOIN "+join+" "+joinAlias+" ";
		    fromString += " JOIN " + prefixNotJoinFieldName(join) + " " + joinAlias + " ";
		}
	    }
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.createFromString(Class realClass, Map<String,String> joinMap): " + e.toString(), e);
	}
	return fromString;
    }

    private String createQueryString(Boolean distinct, String[] selectFields, Class realClass, LogicCondition logicCondition, String orderBy, String[] groupBy, Map<String, Object> parametersMap)
	    throws DataAccessException {
	log.debug("Entering");
	String queryString = null;
	try {

	    // String unqualifiedClassName = realClass.getSimpleName();
	    // Integer joinIndex=0;
	    final Cursor joinIndex = new Cursor();
	    final HashMap<String, String> joinMap = createJoinMap(realClass, selectFields, joinIndex);
	    log.info("joinIndex = " + joinIndex);
	    joinMap.putAll(createJoinMap(realClass, logicCondition, joinIndex));
	    log.info("joinIndex = " + joinIndex);
	    joinMap.putAll(createJoinMap(realClass, groupBy, joinIndex));
	    log.info("joinIndex = " + joinIndex);

	    final String[] orderByArray = buildOrderByArray(orderBy);
	    joinMap.putAll(createJoinMap(realClass, orderByArray, joinIndex));
	    log.info("joinIndex = " + joinIndex);

	    replanceFieldsWithJoinMap(selectFields, joinMap);

	    final String selectString = createSelectString(distinct, selectFields);

	    final String fromString = createFromString(realClass, joinMap);
	    // queryString =selectString +" FROM "+unqualifiedClassName +" a ";

	    queryString = selectString + " " + fromString + " ";

	    replanceLogicConditionFieldsWithJoinMap(logicCondition, joinMap);

	    queryString = queryString + createWhereString(realClass, logicCondition, parametersMap);

	    replanceFieldsWithJoinMap(groupBy, joinMap);

	    queryString = queryString + createGroupByString(groupBy);

	    // queryString = queryString + createOrderByString(orderBy);
	    queryString = queryString + createOrderByString(orderByArray, joinMap);
	    // log.debug("queryString is #0", queryString);
	    log.debug("queryString is " + queryString);
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException(
		    "Error in  BaseJpaDAO.createQueryString(Boolean distinct,String[] selectFields, Class realClass,  LogicCondition logicCondition, String orderBy, String[] groupBy, Map<String,Object> parametersMap): "
			    + e.toString(),
		    e);
	}
	log.debug("Done");
	return queryString;
    }

    @SuppressWarnings("unused")
    private Query createCountQuery(Boolean distinct, String[] selectFields, Class realClass, LogicCondition logicCondition) throws DataAccessException {
	log.debug("Entering");
	Query query = null;
	try {

	    if (distinct != null && distinct.booleanValue() && (selectFields == null || selectFields.length == 0)) {
		log.error("distinct can't be true without selectFields");
		throw new DataAccessException(
			"Error in  BaseJpaDAO.createCountQuery(String[] selectFields,Class realClass, LogicCondition logicCondition): distinct can't be true without selectFields");

	    }
	    // String unqualifiedClassName =
	    // Utils.getExceptLastTokenAndLastToken(realClass.getName())[1];
	    final String unqualifiedClassName = realClass.getSimpleName();

	    String queryString = "";
	    String selectString = "";
	    if (selectFields == null || selectFields.length == 0) {
		selectString = "SELECT COUNT(*) ";
	    } else {
		// selectString = "SELECT COUNT("+createSelectString(distinct,
		// selectFields)+") ";
		selectString = createSelectString(distinct, selectFields, true);
	    }
	    final Map<String, Object> parametersMap = new HashMap<String, Object>();
	    final String whereString = createWhereString(realClass, logicCondition, parametersMap);
	    queryString = queryString + selectString + " FROM " + unqualifiedClassName + " a ";
	    queryString = queryString + whereString;

	    // log.debug("queryString is #0", queryString);
	    log.debug("queryString is " + queryString);

	    query = getEntityManager().createQuery(queryString);

	    setQueryParameters(query, parametersMap);
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.createCountQuery(Boolean distinct,String[] selectFields,Class realClass, LogicCondition logicCondition): " + e.toString(), e);

	}
	log.debug("Done");
	return query;

    }

    @SuppressWarnings("unused")
    private Query createCountQuery(Class realClass, LogicCondition logicCondition) throws DataAccessException {
	log.debug("Entering");
	Query query = null;
	try {
	    // String unqualifiedClassName =
	    // Utils.getExceptLastTokenAndLastToken(realClass.getName())[1];
	    final String unqualifiedClassName = realClass.getSimpleName();

	    String queryString = "SELECT count(*) FROM " + unqualifiedClassName + " a ";

	    final Map<String, Object> parametersMap = new HashMap<String, Object>();

	    if (logicCondition != null) {
		final String whereCondition = translateLogicCondition(realClass, logicCondition, parametersMap);
		queryString = queryString + " WHERE " + whereCondition;
	    }

	    // log.debug("queryString is #0", queryString);
	    log.debug("queryString is " + queryString);

	    query = getEntityManager().createQuery(queryString);

	    setQueryParameters(query, parametersMap);
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.createCountQuery(Class realClass, LogicCondition logicCondition): " + e.toString(), e);

	}
	log.debug("Done");
	return query;

    }

    private String translateLogicCondition(Class realClass, LogicCondition logicCondition, Map<String, Object> parametersMap) throws DataAccessException {
	return translateLogicCondition(0, realClass, logicCondition, parametersMap);
    }

    private String translateLogicCondition(int progr, Class realClass, LogicCondition logicCondition, Map<String, Object> parametersMap) throws DataAccessException {
	log.debug("Entering");
	String condition = "";
	try {
	    final int newProgr = progr + 1;
	    condition = translateSimpleCondition(progr, realClass, logicCondition.getSimpleCondition(), parametersMap);
	    // criteria =
	    // translateSimpleCondition(broker,realClass,logicCondition.getSimpleCondition());
	    if (logicCondition.getLogicCondition() != null) {
		if (logicCondition.getAndOr().equalsIgnoreCase("AND")) {
		    condition = condition + " AND (" + translateLogicCondition(newProgr, realClass, logicCondition.getLogicCondition(), parametersMap) + " )";
		    // criteria.addAndCriteria(translateLogicCondition(broker,realClass,logicCondition.getLogicCondition()));
		} else if (logicCondition.getAndOr().equalsIgnoreCase("OR")) {
		    condition = condition + " OR (" + translateLogicCondition(newProgr, realClass, logicCondition.getLogicCondition(), parametersMap) + " )";
		    // criteria.addOrCriteria(translateLogicCondition(broker,realClass,logicCondition.getLogicCondition()));
		} else {
		    throw new Exception("Error in  BaseJpaDAO.translateLogicCondition(int progr,Class realClass,LogicCondition logicCondition,Map<String,Object> parametersMap): AND/OR missing");
		}
	    }
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.translateLogicCondition(int progr,Class realClass,LogicCondition logicCondition,Map<String,Object> parametersMap): " + e.toString(), e);

	}
	log.debug("Done");
	return condition;
    }

    private String translateSimpleCondition(int progr, Class realClass, SimpleCondition simpleCondition, Map<String, Object> parametersMap) throws DataAccessException {
	log.debug("Entering");
	String condition = "";
	String field = null;
	Object value = null;
	try {
	    final Operator operator = simpleCondition.getOperator();
	    final Collection parameters = simpleCondition.getParameter();
	    final Iterator iterator = parameters.iterator();
	    if (iterator.hasNext()) {
		field = (String) iterator.next();
	    }
	    if (iterator.hasNext()) {
		value = iterator.next();
	    }
	    String fieldLastToken = null;
	    if (field != null) {
		fieldLastToken = Utils.getExceptLastTokenAndLastToken(field)[1];
		// fieldLastToken = fieldLastToken+"A"+progr;
		fieldLastToken = fieldLastToken.replaceAll("(|)", "a") + "A" + progr;

	    }

	    /**********************
	     * operators mapping
	     ********************************************/
	    boolean staticCondition = false;
	    if (operator.getName().equalsIgnoreCase("==") || operator.getName().equalsIgnoreCase("=")) {
		// condition ="a."+field+"= :"+field;
		// condition =field+"= :"+field;
		condition = field + "= :" + fieldLastToken;
		// parametersMap.put(field, value);
		parametersMap.put(fieldLastToken, value);
	    } else if (operator.getName().equalsIgnoreCase("isNull")) {
		// condition ="a."+field+" IS NULL";
		condition = field + " IS NULL";
		// TODO add the OR empty string
	    } else if (operator.getName().equalsIgnoreCase("isNotNull")) {
		// condition ="a."+field+" IS NOT NULL";
		condition = field + " IS NOT NULL";
	    } else if (operator.getName().equalsIgnoreCase("IN")) { // added
								    // 29/08/2005
		// if(value!=null&&!((Collection)value).isEmpty())
		// criteria.addIn(field,(Collection)value);
		// condition ="a."+field+" IN :"+field;
		// condition =field+" IN :"+field;
		// if (value == null || ((List) value).isEmpty()) {
		if (value == null || ((Collection) value).isEmpty()) {
		    condition = " 1 = 2"; // false condition
		    staticCondition = true;
		} else if (((Collection) value).size() > this.inLimit) {
		    final ArrayList<List> splitIn = splitIn((Collection) value);
		    // condition =field + orOfInsCollection(fieldLastToken,
		    // splitIn, parametersMap);
		    condition = orOfInsCollection(prefixNotJoinFieldName(field), fieldLastToken, splitIn, parametersMap);
		    staticCondition = true;
		} else {
		    condition = field + " IN (:" + fieldLastToken + ")";
		    // parametersMap.put(field, value);
		    // parametersMap.put(fieldLastToken, value);
		    parametersMap.put(fieldLastToken, value);
		}

	    } else if (operator.getName().equalsIgnoreCase("NOT IN") || operator.getName().equalsIgnoreCase("NOTIN")) {
		// if(value!=null&&!((Collection)value).isEmpty())
		// criteria.addNotIn(field,(Collection)value);
		// condition ="a."+field+" NOT IN :"+field;
		// condition =field+" NOT IN :"+field;
		if (value == null || ((Collection) value).isEmpty()) {
		    condition = " 1 = 1"; // true condition
		    staticCondition = true;
		} else if (((Collection) value).size() > this.inLimit) {
		    final ArrayList<List> splitIn = splitIn((Collection) value);

		    // condition =" NOT ("+ ((field!=null &&
		    // !field.trim().equals(""))?"a."+field:"a ") +
		    // orOfInsCollection(fieldLastToken, splitIn,
		    // parametersMap)+" ) ";
		    final String nuevoField = field != null && !field.trim().equals("") ? prefixNotJoinFieldName(field) : "a ";
		    condition = " NOT (" + orOfInsCollection(nuevoField, fieldLastToken, splitIn, parametersMap) + " ) ";
		    staticCondition = true;
		} else {
		    condition = field + " NOT IN (:" + fieldLastToken + ")";
		    // parametersMap.put(field, value);
		    parametersMap.put(fieldLastToken, value);
		}
	    } else if (operator.getName().equalsIgnoreCase("<=")) {
		// condition ="a."+field+"<= :"+field;
		// condition =field+"<= :"+field;
		condition = field + "<= :" + fieldLastToken;
		// parametersMap.put(field, value);
		parametersMap.put(fieldLastToken, value);
	    } else if (operator.getName().equalsIgnoreCase(">=")) {
		// condition ="a."+field+">= :"+field;
		// condition =field+">= :"+field;
		condition = field + ">= :" + fieldLastToken;
		// parametersMap.put(field, value);
		parametersMap.put(fieldLastToken, value);
	    } else if (operator.getName().equalsIgnoreCase("<")) {
		// condition ="a."+field+"< :"+field;
		// condition =field+"< :"+field;
		condition = field + "< :" + fieldLastToken;
		// parametersMap.put(field, value);
		parametersMap.put(fieldLastToken, value);
	    } else if (operator.getName().equalsIgnoreCase(">")) {
		// condition ="a."+field+"> :"+field;
		// condition =field+"> :"+field;
		condition = field + "> :" + fieldLastToken;
		// parametersMap.put(field, value);
		parametersMap.put(fieldLastToken, value);
	    } else if (operator.getName().equalsIgnoreCase("!=") || operator.getName().equalsIgnoreCase("<>")) {
		// condition ="a."+field+"<> :"+field;
		// condition =field+"<> :"+field;
		condition = field + "<> :" + fieldLastToken;
		// parametersMap.put(field, value);
		parametersMap.put(fieldLastToken, value);
	    } else if (operator.getName().equalsIgnoreCase("LEFTLIKE")) {
		// condition ="a."+field+"LIKE % :"+field;
		// condition =field+"LIKE % :"+field;
		// condition = field + " LIKE lower(concat('%',:" +
		// fieldLastToken
		condition = "lower(a." + field + ") LIKE lower(concat('%',:" + fieldLastToken + "))";
		staticCondition = true;
		parametersMap.put(field, value);
		// criteria.addLike(field,"%"+value);
	    } else if (operator.getName().equalsIgnoreCase("RIGHTLIKE")) {
		// condition ="a."+field+"LIKE :"+field+"%";
		// condition =field+"LIKE :"+field+"%";
		// condition = field + " LIKE lower(concat(:" + fieldLastToken
		condition = "lower(a." + field + ") LIKE lower(concat(:" + fieldLastToken + ",'%'))";
		staticCondition = true;
		// parametersMap.put(field, value);
		parametersMap.put(fieldLastToken, value);
		// criteria.addLike(field,value+"%");
	    } else if (operator.getName().equalsIgnoreCase("LIKE") || operator.getName().equalsIgnoreCase("BOTHLIKE")) {
		// condition ="a."+field+"LIKE % :"+field+"%";
		// condition =field+"LIKE % :"+field+"%";
		// condition = field + " LIKE lower(concat('%',:" +
		// fieldLastToken
		condition = "lower(a." + field + ") LIKE lower(concat('%',:" + fieldLastToken + ",'%'))";
		staticCondition = true;
		// parametersMap.put(field, value);
		parametersMap.put(fieldLastToken, value);
		// criteria.addLike(field,"%"+value+"%");
	    }
	    // condition = "a."+condition;//deleted by alessandro 14-enero -2010
	    if (!staticCondition) {
		if (field != null && !field.trim().equals("")) { // added by
								 // alessandro
								 // 14-enero
								 // -2010
		    // condition = "a." + condition;
		    condition = prefixNotJoinFieldName(condition);
		} else {
		    condition = "a" + condition;
		}
	    }

	    /**********************
	     * end operators mapping
	     ********************************************/
	} catch (final Exception e) {
	    log.error("Exception caught : " + e.toString());
	    throw new DataAccessException(
		    "Error in  BaseJPADAO.translateSimpleCondition(int progr,Class realClass, SimpleCondition simpleCondition, Map<String,Object> parametersMap): " + e.toString(), e);

	}
	log.debug("Done");
	return condition;
    }

    // private String translateSimpleCondition(int progr,Class realClass,
    // SimpleCondition simpleCondition, Map<String,Object> parametersMap) throws
    // DataAccessException{
    // log.debug("Entering");
    // String condition = "";
    // String field = null;
    // Object value = null;
    // try {
    // Operator operator= simpleCondition.getOperator();
    // Collection parameters = simpleCondition.getParameter();
    // Iterator iterator = parameters.iterator();
    // if (iterator.hasNext()){
    // field = (String)iterator.next();
    // }
    // if (iterator.hasNext()){
    // value = iterator.next();
    // }
    // String fieldLastToken=null;
    // if(field!=null){
    // fieldLastToken = Utils.getExceptLastTokenAndLastToken(field)[1];
    // //fieldLastToken = fieldLastToken+"A"+progr;
    // fieldLastToken = fieldLastToken.replaceAll("(|)", "a")+"A"+progr;
    //
    // }
    //
    // /********************** operators mapping
    // ********************************************/
    // boolean staticCondition = false;
    // if
    // (operator.getName().equalsIgnoreCase("==")||operator.getName().equalsIgnoreCase("=")){
    // //condition ="a."+field+"= :"+field;
    // //condition =field+"= :"+field;
    // condition =field+"= :"+fieldLastToken;
    // //parametersMap.put(field, value);
    // parametersMap.put(fieldLastToken, value);
    // }else if(operator.getName().equalsIgnoreCase("isNull")) {
    // //condition ="a."+field+" IS NULL";
    // condition =field+" IS NULL";
    // //TODO add the OR empty string
    // }else if(operator.getName().equalsIgnoreCase("isNotNull")) {
    // //condition ="a."+field+" IS NOT NULL";
    // condition =field+" IS NOT NULL";
    // } else if(operator.getName().equalsIgnoreCase("IN")) { //added 29/08/2005
    // //if(value!=null&&!((Collection)value).isEmpty())
    // criteria.addIn(field,(Collection)value);
    // //condition ="a."+field+" IN :"+field;
    // //condition =field+" IN :"+field;
    // if(value == null || ((List)value).isEmpty()){
    // condition= " 1 = 2"; // false condition
    // staticCondition=true;
    // }else if ( ((List)value).size()>this.inLimit){
    // ArrayList<List> splitIn = splitIn((Collection)value);
    // //condition =field + orOfInsCollection(fieldLastToken, splitIn,
    // parametersMap);
    // //condition =orOfInsCollection("a."+field,fieldLastToken, splitIn,
    // parametersMap);
    // condition
    // =orOfInsCollection(prefixNotJoinFieldName(field),fieldLastToken, splitIn,
    // parametersMap);
    // staticCondition=true;
    // }else{
    // condition =field+" IN (:"+fieldLastToken+")";
    // //parametersMap.put(field, value);
    // //parametersMap.put(fieldLastToken, value);
    // parametersMap.put(fieldLastToken, value);
    // }
    //
    // } else if(operator.getName().equalsIgnoreCase("NOT
    // IN")||operator.getName().equalsIgnoreCase("NOTIN")) {
    // //if(value!=null&&!((Collection)value).isEmpty())
    // criteria.addNotIn(field,(Collection)value);
    // //condition ="a."+field+" NOT IN :"+field;
    // //condition =field+" NOT IN :"+field;
    // if(value == null || ((List)value).isEmpty()){
    // condition= " 1 = 1"; // true condition
    // staticCondition=true;
    // }else if ( ((List)value).size()>this.inLimit){
    // ArrayList<List> splitIn = splitIn((Collection)value);
    //
    // //condition =" NOT ("+ ((field!=null &&
    // !field.trim().equals(""))?"a."+field:"a ") +
    // orOfInsCollection(fieldLastToken, splitIn, parametersMap)+" ) ";
    // //String nuevoField = ((field!=null &&
    // !field.trim().equals(""))?"a."+field:"a ");
    // String nuevoField = ((field!=null &&
    // !field.trim().equals(""))?prefixNotJoinFieldName(field):"a ");
    // condition =" NOT ("+ orOfInsCollection(nuevoField,fieldLastToken,
    // splitIn, parametersMap)+" ) ";
    // staticCondition=true;
    // }else{
    // condition =field+" NOT IN (:"+fieldLastToken+")";
    // //parametersMap.put(field, value);
    // parametersMap.put(fieldLastToken, value);
    // }
    // } else if(operator.getName().equalsIgnoreCase("<=")) {
    // //condition ="a."+field+"<= :"+field;
    // //condition =field+"<= :"+field;
    // condition =field+"<= :"+fieldLastToken;
    // //parametersMap.put(field, value);
    // parametersMap.put(fieldLastToken, value);
    // } else if(operator.getName().equalsIgnoreCase(">=")) {
    // //condition ="a."+field+">= :"+field;
    // //condition =field+">= :"+field;
    // condition =field+">= :"+fieldLastToken;
    // //parametersMap.put(field, value);
    // parametersMap.put(fieldLastToken, value);
    // }else if(operator.getName().equalsIgnoreCase("<")) {
    // //condition ="a."+field+"< :"+field;
    // //condition =field+"< :"+field;
    // condition =field+"< :"+fieldLastToken;
    // //parametersMap.put(field, value);
    // parametersMap.put(fieldLastToken, value);
    // }else if(operator.getName().equalsIgnoreCase(">")) {
    // //condition ="a."+field+"> :"+field;
    // //condition =field+"> :"+field;
    // condition =field+"> :"+fieldLastToken;
    // //parametersMap.put(field, value);
    // parametersMap.put(fieldLastToken, value);
    // }else
    // if(operator.getName().equalsIgnoreCase("!=")||operator.getName().equalsIgnoreCase("<>"))
    // {
    // //condition ="a."+field+"<> :"+field;
    // //condition =field+"<> :"+field;
    // condition =field+"<> :"+fieldLastToken;
    // //parametersMap.put(field, value);
    // parametersMap.put(fieldLastToken, value);
    // }else if(operator.getName().equalsIgnoreCase("LEFTLIKE")) {
    // //condition ="a."+field+"LIKE % :"+field;
    // //condition =field+"LIKE % :"+field;
    // condition =field+" LIKE lower(concat('%',:" + fieldLastToken + "))";
    // //parametersMap.put(field, value);
    // parametersMap.put(fieldLastToken, value);
    // //criteria.addLike(field,"%"+value);
    // }else if(operator.getName().equalsIgnoreCase("RIGHTLIKE")) {
    // //condition ="a."+field+"LIKE :"+field+"%";
    // //condition =field+"LIKE :"+field+"%";
    // condition =field+" LIKE lower(concat(:" + fieldLastToken + ",'%'))";
    // //parametersMap.put(field, value);
    // parametersMap.put(fieldLastToken, value);
    // //criteria.addLike(field,value+"%");
    // }else
    // if(operator.getName().equalsIgnoreCase("LIKE")||operator.getName().equalsIgnoreCase("BOTHLIKE"))
    // {
    // //condition ="a."+field+"LIKE % :"+field+"%";
    // //condition =field+"LIKE % :"+field+"%";
    // condition =field+" LIKE lower(concat('%',:" + fieldLastToken + ",'%'))";
    // //parametersMap.put(field, value);
    // parametersMap.put(fieldLastToken, value);
    // //criteria.addLike(field,"%"+value+"%");
    // }
    // //condition = "a."+condition;//deleted by alessandro 14-enero -2010
    // if(!staticCondition){
    // if(field!=null && !field.trim().equals("")){ //added by alessandro
    // 14-enero -2010
    // //condition = "a."+condition;
    // condition = prefixNotJoinFieldName(condition);
    // }else{
    // condition = "a "+condition;
    // }
    // }
    //
    //
    // /********************** end operators mapping
    // ********************************************/
    // }
    // catch (Exception e){
    // log.error("Exception caught : " + e.toString());
    // throw new DataAccessException("Error in
    // BaseJpaDAO.translateSimpleCondition(int progr,Class realClass,
    // SimpleCondition simpleCondition, Map<String,Object> parametersMap): " +
    // e.toString(),e);
    //
    // }
    // log.debug("Done");
    // return condition;
    // }

    private Annotation getAnnotation(Class realClass, String pAttributeName, Class annotationClass) throws DataAccessException {
	log.debug("Entering");
	Annotation annotation = null;

	try {

	    Field field = null;
	    try {
		field = realClass.getDeclaredField(pAttributeName);
	    } catch (final NoSuchFieldException e) {
		log.warn(pAttributeName + "is not a field of " + realClass.toString());
	    }

	    if (field != null) {
		annotation = field.getAnnotation(annotationClass);
		if (annotation == null) {
		    final Method getter = getGetter(realClass, pAttributeName);
		    annotation = getter.getAnnotation(annotationClass);
		}
	    }

	} catch (final SecurityException e) {
	    log.error("SecurityException caught : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getAnnotation(Class realClass, String pAttributeName, Class annotationClass): " + e.toString(), e);
	} /*
	   * catch (NoSuchFieldException e) {
	   * log.error("NoSuchFieldException caught : " + e.toString()); throw
	   * new
	   * DataAccessException("Error in  BaseJpaDAO.getAnnotation(Class realClass, String pAttributeName, Class annotationClass): "
	   * + e.toString(),e); }
	   */
	log.debug("Done");
	return annotation;
    }

    /**
     *
     * @param realClass
     * @return the first EmbeddedId or Id annotation found iterating over fields
     *         and methods of realClass
     * @throws DataAccessException
     */
    @SuppressWarnings("unused")
    private Annotation getEmbeddedIdOrId(Class realClass) throws DataAccessException {
	log.debug("Entering");
	Annotation annotation = null;
	try {
	    EmbeddedId embeddedId = null;
	    Id idAnnotation = null;
	    /*******
	     * start looking for EmbeddedId or Id anntoations on fields
	     *******/
	    final Field[] fields = realClass.getDeclaredFields();
	    // Field field = null;
	    for (final Field field : fields) {
		embeddedId = field.getAnnotation(EmbeddedId.class);
		// if(embeddedId!=null ||idAnnotation!=null) {
		if (embeddedId != null) {
		    annotation = embeddedId;
		    break;
		} else {
		    idAnnotation = field.getAnnotation(Id.class);
		    if (idAnnotation != null) {
			annotation = idAnnotation;
			break;
		    }
		}
	    }

	    /*******
	     * start looking for EmbeddedId or Id anntoations on getters
	     *******/
	    // Method idGetter = null;
	    // if(embeddedId==null && field==null){
	    if (annotation == null) {
		final Method[] metods = realClass.getMethods();

		for (final Method metod : metods) {
		    embeddedId = metod.getAnnotation(EmbeddedId.class);
		    if (embeddedId != null) {
			annotation = embeddedId;
			break;
		    } else {
			idAnnotation = metod.getAnnotation(Id.class);
			if (idAnnotation != null) {
			    annotation = idAnnotation;
			    break;
			}
		    }
		}
	    }
	} catch (final SecurityException e) {
	    log.error("SecurityException caught : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getEmbeddedIdOrId(Class realClass): " + e.toString(), e);
	}
	log.debug("Done");
	return annotation;

    }

    /**
     *
     * @param realClass
     * @return the first EmbeddedId annotation found iterating over fields and
     *         methods of realClass
     * @throws DataAccessException
     */
    @SuppressWarnings("unused")
    private EmbeddedId getEmbeddedId(Class realClass) throws DataAccessException {
	log.debug("Entering");
	EmbeddedId embeddedId = null;
	try {
	    /******* start looking for EmbeddedId on fields *******/
	    final Field[] fields = realClass.getDeclaredFields();
	    for (final Field field : fields) {
		embeddedId = field.getAnnotation(EmbeddedId.class);
		if (embeddedId != null) {
		    break;
		}
	    }

	    /*******
	     * start looking for EmbeddedId or Id anntoations on getters
	     *******/
	    if (embeddedId == null) {
		final Method[] metods = realClass.getMethods();

		for (final Method metod : metods) {
		    embeddedId = metod.getAnnotation(EmbeddedId.class);
		    if (embeddedId != null) {
			break;
		    }
		}
	    }
	} catch (final SecurityException e) {
	    log.error("SecurityException caught : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getEmbeddedId(Class realClass) : " + e.toString(), e);
	}
	log.debug("Done");
	return embeddedId;

    }

    /**
     *
     * @param realClass
     * @return the first EmbeddedId or Id annotation found iterating over fields
     * @throws DataAccessException
     */
    @SuppressWarnings("unused")
    private Annotation getEmbeddedIdOrIdOnField(Class realClass) throws DataAccessException {
	log.debug("Entering");
	Annotation annotation = null;
	try {
	    EmbeddedId embeddedId = null;
	    Id idAnnotation = null;
	    /*******
	     * start looking for EmbeddedId or Id anntoations on fields
	     *******/
	    final Field[] fields = realClass.getDeclaredFields();
	    // Field field = null;
	    for (final Field field : fields) {
		embeddedId = field.getAnnotation(EmbeddedId.class);
		// if(embeddedId!=null ||idAnnotation!=null) {
		if (embeddedId != null) {
		    annotation = embeddedId;
		    break;
		} else {
		    idAnnotation = field.getAnnotation(Id.class);
		    if (idAnnotation != null) {
			annotation = idAnnotation;
			break;
		    }
		}
	    }
	} catch (final SecurityException e) {
	    log.error("SecurityException caught : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getEmbeddedIdOrIdOnField(Class realClass): " + e.toString(), e);
	}
	log.debug("Done");
	return annotation;

    }

    /**
     *
     * @param realClass
     * @return the first EmbeddedId or Id annotation found iterating over
     *         methods of realClass
     * @throws DataAccessException
     */
    @SuppressWarnings("unused")
    private Annotation getEmbeddedIdOrIdOnMethod(Class realClass) throws DataAccessException {
	log.debug("Entering");
	Annotation annotation = null;
	try {
	    EmbeddedId embeddedId = null;
	    Id idAnnotation = null;

	    /*******
	     * start looking for EmbeddedId or Id anntoations on getters
	     *******/
	    // Method idGetter = null;
	    // if(embeddedId==null && field==null){

	    final Method[] metods = realClass.getMethods();

	    for (final Method metod : metods) {
		embeddedId = metod.getAnnotation(EmbeddedId.class);
		if (embeddedId != null) {
		    annotation = embeddedId;
		    break;
		} else {
		    idAnnotation = metod.getAnnotation(Id.class);
		    if (idAnnotation != null) {
			annotation = idAnnotation;
			break;
		    }
		}
	    }

	} catch (final SecurityException e) {
	    log.error("SecurityException caught : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getEmbeddedIdOrIdOnMethod(Class realClass): " + e.toString(), e);
	}
	log.debug("Done");
	return annotation;

    }

    private Field getEmbeddedIdOrIdAnnotatedField(Class realClass) throws DataAccessException {
	log.debug("Entering");
	Field field = null;
	try {
	    final Field[] fields = realClass.getDeclaredFields();
	    for (final Field field2 : fields) {
		if (field2.isAnnotationPresent(EmbeddedId.class) || field2.isAnnotationPresent(Id.class)) {
		    field = field2;
		    break;
		}
	    }
	} catch (final SecurityException e) {
	    log.error("SecurityException caught : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getEmbeddedIdOrIdAnnotatedField(Class realClass): " + e.toString(), e);
	}
	log.debug("Done");
	return field;
    }

    private Method getEmbeddedIdOrIdAnnotatedMethod(Class realClass) throws DataAccessException {
	log.debug("Entering");
	Method idGetter = null;
	try {
	    final Method[] metods = realClass.getMethods();
	    for (final Method metod : metods) {
		if (metod.isAnnotationPresent(EmbeddedId.class) || metod.isAnnotationPresent(Id.class)) {
		    idGetter = metod;
		    break;
		}
	    }
	} catch (final SecurityException e) {
	    log.error("SecurityException caught : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getEmbeddedIdOrIdAnnotatedMethod(Class realClass): " + e.toString(), e);
	}

	log.debug("Done");
	return idGetter;
    }

    private AccessibleObject getEmbeddedIdOrIdAnnotatedAccessibleObject(Class realClass) throws DataAccessException {
	log.debug("Entering");
	AccessibleObject accessibleObject = null;
	try {
	    accessibleObject = getEmbeddedIdOrIdAnnotatedField(realClass);
	    if (accessibleObject == null) {
		accessibleObject = getEmbeddedIdOrIdAnnotatedMethod(realClass);
	    }
	} catch (final Exception e) {
	    log.error("Exception caught : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getEmbeddedIdOrIdAnnotatedAccessibleObject(Class realClass): " + e.toString(), e);
	}
	log.debug("Done");
	return accessibleObject;
    }

    private boolean isCascade(Object pInstance, String pAttributeName, CascadeType cascadeType) throws DataAccessException {
	boolean isCascade = false;
	try {
	    final CascadeType[] cascades = getCascade(pInstance, pAttributeName);
	    if (cascades != null) {
		for (int i = 0; i < cascades.length && !isCascade; i++) {
		    isCascade = cascades[i].equals(cascadeType);
		}
	    }
	} catch (final DataAccessException e) {
	    log.error("Exception caught : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.isCascade(Object pInstance, String pAttributeName, CascadeType cascadeType): " + e.toString(), e);
	}
	return isCascade;
    }

    private CascadeType[] getCascade(Object pInstance, String pAttributeName) throws DataAccessException {

	CascadeType[] cascades = null;
	try {
	    final Annotation annotation = getRelationMappingAnnotation(pInstance, pAttributeName);
	    if (annotation != null) {
		if (annotation instanceof ManyToMany) {
		    cascades = ((ManyToMany) annotation).cascade();
		} else if (annotation instanceof OneToMany) {
		    cascades = ((OneToMany) annotation).cascade();
		} else if (annotation instanceof ManyToOne) {
		    cascades = ((ManyToOne) annotation).cascade();
		} else if (annotation instanceof OneToOne) {
		    cascades = ((OneToOne) annotation).cascade();
		}
	    }
	} catch (final Exception e) {
	    log.error("Exception caught : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getCascade(Object pInstance, String pAttributeName): " + e.toString(), e);
	}
	return cascades;
    }

    private Annotation getRelationMappingAnnotation(Class realClass, String pAttributeName) throws DataAccessException {
	Annotation annotation = null;
	try {
	    final ManyToMany manyToMany = (ManyToMany) getAnnotation(realClass, pAttributeName, ManyToMany.class);
	    if (manyToMany != null) {
		annotation = manyToMany;
	    } else {
		final OneToMany oneToMany = (OneToMany) getAnnotation(realClass, pAttributeName, OneToMany.class);
		if (oneToMany != null) {
		    annotation = oneToMany;
		} else {
		    final ManyToOne manyToOne = (ManyToOne) getAnnotation(realClass, pAttributeName, ManyToOne.class);
		    if (manyToOne != null) {
			annotation = manyToOne;
		    } else {
			final OneToOne oneToOne = (OneToOne) getAnnotation(realClass, pAttributeName, OneToOne.class);
			if (oneToOne != null) {
			    annotation = oneToOne;
			}
		    }
		}
	    }
	} catch (final Exception e) {
	    log.error("Exception caught : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getRelationMappingAnnotation(Class realClass, String pAttributeName): " + e.toString(), e);
	}
	return annotation;
    }

    private Annotation getRelationMappingAnnotation(Object pInstance, String pAttributeName) throws DataAccessException {
	Annotation annotation = null;
	try {
	    final Class realClass = getEntityClass(pInstance);
	    annotation = getRelationMappingAnnotation(realClass, pAttributeName);
	} catch (final Exception e) {
	    log.error("Exception caught : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getRelationMappingAnnotation(Object pInstance, String pAttributeName): " + e.toString(), e);
	}
	return annotation;
    }

    private String getMappedBy(Class realClass, String pAttributeName) throws DataAccessException {
	log.debug("Entering");
	String mappedBy;
	try {
	    mappedBy = null;
	    // Annotation annotation = getAnnotation(pInstance.getClass(),
	    // pAttributeName, OneToMany.class);
	    Annotation annotation = getAnnotation(realClass, pAttributeName, OneToMany.class);
	    if (annotation == null) {
		// annotation = getAnnotation(pInstance.getClass(),
		// pAttributeName, ManyToMany.class);
		annotation = getAnnotation(realClass, pAttributeName, ManyToMany.class);
		if (annotation == null) {
		    throw new DataAccessException(
			    "DataAccessException thrown in BaseJpaDAO.getMappedBy(Class realClass, String pAttributeName) : pAttributeName or its getter must be annotated with OneToMany or ManyToMany ");
		}
		mappedBy = ((ManyToMany) annotation).mappedBy();
	    } else {
		mappedBy = ((OneToMany) annotation).mappedBy();
	    }

	} catch (final Exception e) {
	    log.error("Exception caught : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getMappedBy(Object pInstance, String pAttributeName): " + e.toString(), e);
	}
	log.debug("Done");
	return mappedBy;
    }

    private String getMappedBy(Object pInstance, String pAttributeName) throws DataAccessException {
	log.debug("Entering");
	String mappedBy;
	try {

	    final Class realClass = getEntityClass(pInstance);
	    mappedBy = getMappedBy(realClass, pAttributeName);
	    // Annotation annotation = getAnnotation(realClass, pAttributeName,
	    // OneToMany.class);
	    // if (annotation== null){
	    // annotation = getAnnotation(realClass, pAttributeName,
	    // ManyToMany.class);
	    // if (annotation==null) throw new
	    // DataAccessException("DataAccessException thrown in
	    // BaseJpaDAO.getMappedBy(Object pInstance, String pAttributeName) :
	    // pAttributeName or its getter must be annotated with OneToMany or
	    // ManyToMany ");
	    // mappedBy = ((ManyToMany)annotation).mappedBy();
	    // }else{
	    // mappedBy = ((OneToMany)annotation).mappedBy();
	    // }

	} catch (final Exception e) {
	    log.error("Exception caught : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getMappedBy(Object pInstance, String pAttributeName): " + e.toString(), e);
	}
	log.debug("Done");
	return mappedBy;
    }

    private Method getGetter(Class realClass, String pAttributeName) throws DataAccessException {
	Method getter = null;
	try {
	    if (realClass == null || pAttributeName == null || pAttributeName.trim().equals("")) {
		throw new DataAccessException("Error in  BaseJpaDAO.getGetter(Class realClass, String pAttributeName): realClass is null or pAttributeName is null or empty string");
	    }
	    // getter =
	    // realClass.getDeclaredMethod("get"+pAttributeName.substring(0,0).toUpperCase()+pAttributeName.substring(1));
	    getter = realClass.getDeclaredMethod("get" + pAttributeName.substring(0, 1).toUpperCase() + pAttributeName.substring(1));
	} catch (final SecurityException e) {
	    log.error("SecurityException caught : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getGetter(Class realClass, String pAttributeName): " + e.toString(), e);
	} catch (final NoSuchMethodException e) {
	    log.error("NoSuchMethodException caught : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.getGetter(Class realClass, String pAttributeName): " + e.toString(), e);
	}
	return getter;
    }

    public void flush() throws DataAccessException, DataOptimisticLockException {
	log.debug("************Entering ***************");
	try {

	    getEntityManager().flush();
	} /*
	   * catch (InvalidStateException e) { // quitado porqu con
	   * hibernate-validator-4.2.0 no funciona
	   * log.error("BaseJpaDAO.flush()" + e.toString(), e); InvalidValue[]
	   * invalid = e.getInvalidValues(); for (int i = 0; i < invalid.length;
	   * ++i) { InvalidValue bad = invalid[i];
	   * log.error("BaseJpaDAO.flush(), " + bad.getPropertyPath() + ":"+
	   * bad.getPropertyName() + ":" + bad.getMessage() + ": value is " +
	   * bad.getValue()); } throw new
	   * DataAccessException("Error in  BaseJpaDAO.flush(): "+
	   * e.getCause()!=null ? e.getCause().toString():"no cause ", e); }
	   */catch (final OptimisticLockException e) {
	    log.error("OptimisticLockException caught: " + e.toString());
	    throw new OptimisticLockException("Error in  BaseJpaDAO.flush(): " + e.toString(), e);
	} catch (final Exception e) {
	    log.error("Exception caught: " + e.toString());
	    if (e.getCause() != null && e.getCause().getCause() != null) {
		throw new DataAccessException("Error in  BaseJpaDAO.flush(): " + e.getCause().toString() + " " + e.getCause().getCause().toString(), e);
	    }
	    if (e.getCause() != null) {
		throw new DataAccessException("Error in  BaseJpaDAO.flush(): " + e.getCause().toString(), e);
	    }

	    throw new DataAccessException("Error in  BaseJpaDAO.flush(): " + e.toString(), e);

	}
	log.debug("************Done **************");
    }

    protected Class getEntityClass(Object entity) throws DataAccessException {
	try {
	    return PersistenceUtil.getEntityClass(entity);
	} catch (final Exception e) {
	    log.error("InvocationTargetException caught in   JpaPersistenceContextDAO.getEntityClass(Object entity): " + e.toString());
	    throw new DataAccessException("Error in   BaseJpaDAO.getEntityClass(Object entity): " + e.toString(), e);
	}
    }

    public void updateByNativeQueryString(String queryString) throws DataAccessException {
	log.debug("************Entering ***************");
	try {
	    final Query query = getEntityManager().createNativeQuery(queryString);
	    query.executeUpdate();

	} catch (final Exception e) {
	    log.error("Exception caught  : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.updateByNativeQueryString(String queryString) : " + e.toString(), e);
	}
	log.debug("************Done **************");
    }

    public void updateByNativeQueryString(String queryString, Map parameters) throws DataAccessException {
	log.debug("************Entering ***************");
	try {
	    final Query query = getEntityManager().createNativeQuery(queryString);
	    setQueryParameters(query, parameters);
	    query.executeUpdate();

	} catch (final Exception e) {
	    log.error("Exception caught  : " + e.toString());
	    throw new DataAccessException("Error in  BaseJpaDAO.updateByNativeQueryString(String queryString, , Map parameters) : " + e.toString(), e);
	}
	log.debug("************Done **************");
    }

}
